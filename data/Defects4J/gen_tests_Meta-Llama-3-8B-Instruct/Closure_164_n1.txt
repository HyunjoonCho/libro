java
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collection;

import static org.junit.Assert.assertThrows;

@RunWith(Parameterized.class)
public class FunctionTypeTest {

    @Parameters
    public static Collection<Object[]> data() {
        return Arrays.asList(new Object[][]{
                {paramFunc1(), "function(string, number):boolean", "function(string, number)"},
                {paramFunc2(), "function(string, number, boolean):boolean", "function(string, number)"}});
    }

    private final Method method;
    private final String expectedReturnType;
    private final String actualReturnType;

    public FunctionTypeTest(Method method, String expectedReturnType, String actualReturnType) {
        this.method = method;
        this.expectedReturnType = expectedReturnType;
        this.actualReturnType = actualReturnType;
    }

    @Test
    public void testFunctionType() {
        assertThrows(UnsupportedOperationException.class, () -> {
            func(method);
        });
    }

    private void func(Method method) {
        // Simulate the function call
        method.invoke(null);
    }

    private Method paramFunc1() {
        return new Method() {
            @Override
            public Class<?> getReturnType() {
                return boolean.class;
            }

            @Override
            public Class<?>[] getParameterTypes() {
                return new Class<?>[]{String.class, int.class};
            }
        };
    }

    private Method paramFunc2() {
        return new Method() {
            @Override
            public Class<?> getReturnType() {
                return boolean.class;
            }

            @Override
            public Class<?>[] getParameterTypes() {
                return new Class<?>[]{String.class, int.class, boolean.class};
            }
        };
    }
}
