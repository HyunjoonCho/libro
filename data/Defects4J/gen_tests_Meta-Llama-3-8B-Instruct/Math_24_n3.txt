
import org.apache.commons.math3.optimization.univariate.BrentOptimizer;
import org.junit.Test;

public class BrentOptimizerTest {
    @Test
    public void testBrentOptimizer() {
        BrentOptimizer optimizer = new BrentOptimizer();
        // Define a test function that returns the square of the input
        double function(double x) {
            return x * x;
        }
        // Define the initial search range
        double min = 0;
        double max = 2;
        // Optimize the function
        double result = optimizer.optimize(function, min, max).getValue();
        // Check that the result is not the best point
        double previousBest = Double.NEGATIVE_INFINITY;
        for (double x : optimizer.getIterationHistory()) {
            if (function(x) < previousBest) {
                previousBest = function(x);
            }
        }
        // The last evaluated point might be slightly worse than the one before last
        // So, we check that the best point is not the last evaluated point
        assertNotEquals(optimizer.getIterationHistory().get(optimizer.getIterationHistory().size() - 1), result);
    }
}
