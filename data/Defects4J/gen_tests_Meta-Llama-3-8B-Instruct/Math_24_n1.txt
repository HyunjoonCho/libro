java
import org.apache.commons.math.optimization.univariate.BrentOptimizer;
import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class BrentOptimizerTest {

    @Test
    public void testBrentOptimizerNotAlwaysReportingTheBestPoint() {
        // Setup the test function
        final double[] x = new double[] {1.0, 2.0, 3.0};
        final double[] y = new double[] {1.0, 2.0, 3.0};
        final UnivariateRealFunction function = new UnivariateRealFunction() {
            @Override
            public double value(double x) {
                return x * x + y[(int) x];
            }
        };

        // Create a BrentOptimizer and optimize the function
        BrentOptimizer optimizer = new BrentOptimizer();
        OptimizablePointValuePair result = optimizer.optimize(new OptimizableFunction(function), 1.0, 2.0);

        // Check if the returned point is the best one
        double bestValue = Double.NEGATIVE_INFINITY;
        double worstValue = Double.POSITIVE_INFINITY;
        for (double x : x) {
            double value = function.value(x);
            if (value > bestValue) {
                bestValue = value;
            }
            if (value < worstValue) {
                worstValue = value;
            }
        }
        assertTrue("The returned point is not the best one", result.getValue() == bestValue);
    }
}
