
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.List;
import org.junit.Test;

public class ProcessClosurePrimitivesTest {

    @Test
    public void testInvalidRequireSymbolsAreNotRemoved() {
        Compiler compiler = new Compiler();

        // Sample input with one valid and one invalid goog.require 
        String code = "goog.provide('my.namespace');\n" +
                      "goog.require('valid.symbol');\n" +
                      "goog.require('invalid.symbol');\n";

        // Normally, a valid symbol would be defined somewhere:
        // Assuming valid.symbol would have been provided by such a line
        String validSymbol = "goog.provide('valid.symbol');";

        // Add logic to process the given code, possibly as syntax tree
        // This would depend on implementation details. Hypothetical example:
        Node root = compiler.parse(code);

        ProcessClosurePrimitives processor = new ProcessClosurePrimitives(
            compiler, /* any additional params if needed */
            /* requiresLevel set to 'removeAndReportRequires' for test */
        );

        // Process the closure primitives, especially goog.require's
        processor.process(null, root);

        // Hypothetically check that invalid require was not removed
        // Depending on implementation, validate remaining nodes or error list
        List<String> remainingRequires = processor.getRemainingRequires();

        // Validate our test conditions:
        assertTrue(remainingRequires.contains("goog.require('invalid.symbol');"));

        // Any errors should be related to the invalid requires, depending on requiresLevel
        List<String> errorSymbols = processor.getInvalidRequireErrors();
        assertTrue(errorSymbols.contains("invalid.symbol"));
    }
}
