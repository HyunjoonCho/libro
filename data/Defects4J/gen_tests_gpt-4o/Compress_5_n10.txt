
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.junit.Test;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.zip.ZipException;

public class ZipArchiveInputStreamTest {

    @Test(expected = IOException.class)
    public void testTruncatedZipArchive() throws IOException {
        // Create a byte array for a truncated ZIP file
        byte[] truncatedZip = new byte[] {
            0x50, 0x4B, 0x03, 0x04, // Local file header signature
            0x14, 0x00, // Version needed to extract
            0x00, 0x00, // General purpose bit flag
            0x00, 0x00, // Compression method
            0x00, 0x00, 0x00, 0x00, // File last modification time and date
            0x00, 0x00, 0x00, 0x00, // CRC-32
            0x00, 0x00, 0x00, 0x00, // Compressed size
            0x00, 0x00, 0x00, 0x00, // Uncompressed size
            0x05, 0x00, // File name length
            0x00, 0x00, // Extra field length
            // File name (e.g., "file" but truncated)
            0x66, 0x69, 0x6C, 0x65
        };

        // Create an input stream from the truncated array
        ByteArrayInputStream bais = new ByteArrayInputStream(truncatedZip);
        ZipArchiveInputStream zis = new ZipArchiveInputStream(bais);

        // Attempt to read the truncated archive, expecting an IOException
        byte[] buffer = new byte[1024];
        int bytesRead = zis.read(buffer);

        // If the code reaches here, it means the exception was not thrown as expected
        throw new AssertionError("Expected IOException due to truncated ZIP file but read " + bytesRead + " bytes.");
    }
}
