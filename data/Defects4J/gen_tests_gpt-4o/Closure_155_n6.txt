
import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class JavaScriptOptimizationTest {

    @Test
    public void testOverzealousArgumentsOptimization() throws ScriptException, NoSuchMethodException {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        // JavaScript function before optimization
        String originalFunction = 
            "function d3_call(callback) {\n" +
            "    var f = callback;\n" +
            "    arguments[0] = this;\n" +
            "    return f.apply(this, arguments);\n" +
            "}";

        // JavaScript function after optimization that causes the issue
        String optimizedFunction =
            "function d3_call(callback) {\n" +
            "    arguments[0] = this;\n" +
            "    return callback.apply(this, arguments);\n" +
            "}";

        // JavaScript code to test the behavior with both functions
        String testScript = originalFunction + optimizedFunction + 
            "var resultOriginal = d3_call(function(a) { return a; }, 'test');\n" +
            "var resultOptimized = callback_result_optimized = d3_call(function(a) { return a; }, 'test');\n" +
            "resultOriginal + ',' + resultOptimized;"; 

        engine.eval(testScript);

        Invocable invocable = (Invocable) engine;

        // Execute the JavaScript test and check if the results differ
        String results = (String) invocable.invokeFunction("eval", "resultOriginal + ',' + resultOptimized;");
        String[] resultsArray = results.split(",");

        // Check if the original result is 'this' and optimized result is also 'this'
        // But we demonstrate here that both should match expectations according to the bug description
        assertEquals(resultsArray[0], resultsArray[1]);
    }
}
