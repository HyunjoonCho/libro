
import com.google.javascript.jscomp.CommandLineRunner;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JSError;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;
import org.junit.Test;

import java.util.Collections;

import static org.junit.Assert.assertTrue;

public class ClosureCompilerTypedefTest {

    @Test
    public void testTypedefResolution() {
        String code = "goog.provide('a.b.c');\n\n" +
                      "goog.scope(function() {\n" +
                      "var b = a.b;\n" +
                      "var c = b.c;\n\n" +
                      "/** @typedef {string} */\n" +
                      "c.MyType;\n\n" +
                      "/** @param {c.MyType} x The variable. */\n" +
                      "c.myFunc = function(x) {};\n" +
                      "});";

        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        // Set options as needed, for example:
        // options.setClosurePass(true);

        SourceFile input = SourceFile.fromCode("TestInput", code);
        Result result = compiler.compile(Collections.emptyList(), Collections.singletonList(input), options);

        // Here, we expect that result.errors should contain at least one error
        // because of the typedef resolution issue described in the bug.
        boolean hasTypedefError = false;
        for (JSError error : result.errors) {
            if (error.description.contains("typedef")) {
                hasTypedefError = true;
                break;
            }
        }

        assertTrue("JSCompiler should not resolve typedefs recursively, but it did.", hasTypedefError);
    }
}
