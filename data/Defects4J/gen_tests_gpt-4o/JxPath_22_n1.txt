
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.Pointer;
import org.apache.commons.jxpath.ri.model.dom.DOMNodePointer;
import org.junit.Test;
import org.w3c.dom.Document;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import static org.junit.Assert.fail;

public class NamespaceLoopTest {

    @Test
    public void testNamespaceLoopInAsPath() {
        try {
            // Create the XML document
            String xmlContent =
                    "<b:foo xmlns:b=\"bla\" xmlns=\"test111\">" +
                        "<b:bar>a</b:bar>" +
                        "<test xmlns=\"\"></test>" +
                    "</b:foo>";

            // Parse the XML content to a Document
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.parse(new java.io.ByteArrayInputStream(xmlContent.getBytes()));

            // Create the JXPath context
            JXPathContext context = JXPathContext.newContext(document);

            // Get the Pointer and call asPath()
            Pointer pointer = context.getPointer("//test");

            // Attempt to get the path, which should cause the bug as described.
            String path = ((DOMNodePointer) pointer).asPath();

            // If it doesn't loop, validate the path. This is what we're assessing for the bug.
            System.out.println("XPath: " + path);
            if (path.contains("null")) {
                fail("asPath contains 'null', indicating incorrect namespace handling");
            }
        } catch (Exception e) {
            e.printStackTrace();
            fail("Exception occurred: " + e.getMessage());
        }
    }
}
