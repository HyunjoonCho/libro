
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.util.JsonParserSequence;
import org.junit.Test;

import java.io.IOException;

import static org.junit.Assert.assertEquals;

public class JsonParserSequenceTest {

    @Test
    public void testParserSequenceDoesNotSkipToken() throws IOException {
        JsonFactory factory = new JsonFactory();

        // First parser with a simple JSON object
        JsonParser parser1 = factory.createParser("{\"key1\":\"value1\"}");
        // Advance to the START_OBJECT token
        parser1.nextToken();

        // Second parser with another simple JSON object
        JsonParser parser2 = factory.createParser("{\"key2\":\"value2\"}");
        // Advance to the START_OBJECT token
        parser2.nextToken();

        // Concatenate parsers using JsonParserSequence
        JsonParserSequence sequence = JsonParserSequence.createFlattened(parser1, parser2);

        // Verify sequence of tokens
        assertEquals(JsonToken.START_OBJECT, sequence.nextToken());
        assertEquals(JsonToken.FIELD_NAME, sequence.nextToken());
        assertEquals("key1", sequence.getCurrentName());
        assertEquals(JsonToken.VALUE_STRING, sequence.nextToken());
        assertEquals("value1", sequence.getText());

        assertEquals(JsonToken.END_OBJECT, sequence.nextToken());

        // Without the bug, it should correctly pick up the second parser's tokens
        assertEquals(JsonToken.START_OBJECT, sequence.nextToken());
        assertEquals(JsonToken.FIELD_NAME, sequence.nextToken());
        assertEquals("key2", sequence.getCurrentName());
        assertEquals(JsonToken.VALUE_STRING, sequence.nextToken());
        assertEquals("value2", sequence.getText());

        assertEquals(JsonToken.END_OBJECT, sequence.nextToken());

        // At the end, the sequence should return null
        assertEquals(null, sequence.nextToken());
    }
}
