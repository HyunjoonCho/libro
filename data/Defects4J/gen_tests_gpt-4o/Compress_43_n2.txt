
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.junit.Test;
import static org.junit.Assert.*;

public class ZipVersionMismatchTest {

    @Test
    public void testZipVersionMismatch() throws IOException {
        // Create a simple byte array output stream to capture the ZIP output
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

        // Create the ZipArchiveOutputStream
        try (ZipArchiveOutputStream zipOutputStream = new ZipArchiveOutputStream(byteArrayOutputStream)) {

            // Create a new entry with DEFLATE compression
            ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
            entry.setMethod(ZipArchiveOutputStream.DEFLATED);

            // Add some test data
            byte[] data = "This is some test data".getBytes();

            // Add the entry to the ZIP output stream
            zipOutputStream.putArchiveEntry(entry);
            
            // Write data
            zipOutputStream.write(data, 0, data.length);
            
            // Close the current entry
            zipOutputStream.closeArchiveEntry();
        }

        // Convert the generated ZIP file content to a byte array
        byte[] zipBytes = byteArrayOutputStream.toByteArray();

        // The first two bytes of the version needed to extract in the local file header
        int localVersionNeededToExtract = ((zipBytes[6] & 0xFF) | ((zipBytes[7] & 0xFF) << 8));

        // Extract the version needed to extract from the central directory header
        int centralVersionNeededToExtract = -1;
        for (int i = 0; i < zipBytes.length - 4; i++) {
            // Look for the signature of the central directory file header (0x02014b50)
            if ((zipBytes[i] & 0xFF) == 0x50 && (zipBytes[i + 1] & 0xFF) == 0x4b &&
                (zipBytes[i + 2] & 0xFF) == 0x01 && (zipBytes[i + 3] & 0xFF) == 0x02) {

                // The version needed to extract in the central directory header
                centralVersionNeededToExtract = ((zipBytes[i + 6] & 0xFF) | ((zipBytes[i + 7] & 0xFF) << 8));
                break;
            }
        }

        // Verify that the version needed to extract in the local and central directory headers are the same
        assertEquals("Version needed to extract should be the same in both headers", 
                     localVersionNeededToExtract, centralVersionNeededToExtract);
    }
}
