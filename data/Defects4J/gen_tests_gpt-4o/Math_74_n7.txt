
import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;
import org.apache.commons.math3.ode.FirstOrderIntegrator;
import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;
import org.apache.commons.math3.ode.sampling.StepHandler;
import org.apache.commons.math3.ode.sampling.StepInterpolator;
import org.junit.Test;
import static org.junit.Assert.assertTrue;

public class EmbeddedRungeKuttaIntegratorTest {

    @Test
    public void testWrongInitialStepSize() {
        
        FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {
            public int getDimension() {
                return 1;
            }

            public void computeDerivatives(double t, double[] y, double[] yDot) {
                yDot[0] = -0.5 * y[0];
            }
        };

        double[] y0 = new double[] { 1.0 };
        double[] y = new double[1];

        // Define tolerances
        final double absTolerance = 1e-10;
        final double relTolerance = 1e-10;

        // Create integrator with wide step size bounds to allow the issue to manifest
        FirstOrderIntegrator integrator = new DormandPrince853Integrator(1.0e-8, 100.0, absTolerance, relTolerance);
        
        integrator.addStepHandler(new StepHandler() {
            public void handleStep(StepInterpolator interpolator, boolean isLast) {
                // Check if an unrealistic large step size is used initially
                double stepSize = interpolator.getCurrentStepStart() - interpolator.getPreviousTime();
                assertTrue("Step size too large", Math.abs(stepSize) < 10.0);
            }

            public void init(double t0, double[] y0, double t) {
            }
        });

        integrator.integrate(ode, 0.0, y0, 10.0, y);
    }
}
