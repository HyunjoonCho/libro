
import static org.junit.Assert.assertEquals;
import org.junit.Test;

public class MathUtilsTest {

    @Test
    public void testFactorial() {
        // Testing factorial for n from 1 to 20
        assertEquals(1, MathUtils.factorial(1));
        assertEquals(2, MathUtils.factorial(2));
        assertEquals(6, MathUtils.factorial(3));
        assertEquals(24, MathUtils.factorial(4));
        assertEquals(120, MathUtils.factorial(5));
        assertEquals(720, MathUtils.factorial(6));
        assertEquals(5040, MathUtils.factorial(7));
        assertEquals(40320, MathUtils.factorial(8));
        assertEquals(362880, MathUtils.factorial(9));
        assertEquals(3628800, MathUtils.factorial(10));
        assertEquals(39916800, MathUtils.factorial(11));
        assertEquals(479001600, MathUtils.factorial(12));
        assertEquals(6227020800L, MathUtils.factorial(13));
        assertEquals(87178291200L, MathUtils.factorial(14));
        assertEquals(1307674368000L, MathUtils.factorial(15));
        assertEquals(20922789888000L, MathUtils.factorial(16));
        assertEquals(355687428096000L, MathUtils.factorial(17)); // Expected value should cause failure
        assertEquals(6402373705728000L, MathUtils.factorial(18)); // Expected value should cause failure
        assertEquals(121645100408832000L, MathUtils.factorial(19)); // Expected value should cause failure
        assertEquals(2432902008176640000L, MathUtils.factorial(20)); // Overflow expected, should cause failure
    }
}

class MathUtils {
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("n must be non-negative");
        }

        // Using a long to prevent overflow for allowed n
        long result = 1;
        for (int i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }
}
