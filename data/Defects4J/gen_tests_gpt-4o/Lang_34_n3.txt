
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

public class MemoryLeakTest {

    static class TestObject {
        private final int id;
        private final String name;

        public TestObject(int id, String name) {
            this.id = id;
            this.name = name;
        }

        @Override
        public String toString() {
            // Using ToStringBuilder with various styles
            return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)
                    .append("id", id)
                    .append("name", name)
                    .toString();
        }

        @Override
        public int hashCode() {
            // Using HashCodeBuilder
            return new HashCodeBuilder(17, 37)
                    .append(id)
                    .append(name)
                    .toHashCode();
        }
    }

    @Test
    public void testForPotentialMemoryLeak() {
        // Creating a list of TestObject instances
        List<TestObject> objects = new ArrayList<>();

        // Simulate multiple deployments by creating and discarding instances
        for (int i = 0; i < 10000; i++) {
            objects.add(new TestObject(i, "Name" + i));
        }

        // Explicitly clear list to simulate removal on application stop/reload
        objects.clear();

        // Force garbage collection
        System.gc();

        // The focus of the test is to detect leaks using external tools, such as a profiling tool,
        // to inspect whether the ThreadLocal values are cleaned up.
    }
}
