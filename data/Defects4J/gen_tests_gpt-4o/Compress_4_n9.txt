
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.compress.utils.IOUtils;
import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

import static org.junit.Assert.assertArrayEquals;

public class ArchiveOutputStreamTest {

    @Test
    public void testDirectFinishMethodInvocation() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ArchiveOutputStream archiveOutputStream = new TarArchiveOutputStream(baos);

        // Write some data to the archive
        archiveOutputStream.write("Test data".getBytes(StandardCharsets.UTF_8));

        // Directly calling finish() instead of relying on close()
        archiveOutputStream.finish();

        // Since finish() was called directly, let's assume that further writes should not happen.
        // Attempt to write more data after calling finish() to check for corruption or exceptions.
        try {
            archiveOutputStream.write("More data".getBytes(StandardCharsets.UTF_8));
        } catch (IllegalStateException | IOException e) {
            // Expected behavior as stream should not allow writing after finish() has been called.
        } finally {
            archiveOutputStream.close();
        }

        // Directly compare with expected output assuming initial data should be finalized.
        byte[] expected = "Test data".getBytes(StandardCharsets.UTF_8);
        byte[] actual = baos.toByteArray();

        // Check whether the output is as expected despite premature finish().
        assertArrayEquals("The output data should match the expected partial data.", expected, actual);
    }
}
