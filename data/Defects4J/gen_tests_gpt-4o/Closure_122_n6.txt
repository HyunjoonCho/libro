
import static org.junit.Assert.*;

import com.google.javascript.jscomp.*;

import org.junit.Test;

public class ClosureCompilerCommentTest {

    @Test
    public void testNonJSDocCommentHandling() {
        // Set up the compiler
        Compiler compiler = new Compiler();
        
        // Set up the options (similar to those used in a command-line compile)
        CompilerOptions options = new CompilerOptions();
        CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);

        // Source code that contains the problematic comment
        String code = "/* @license Foo License */ alert('foo');";

        // Set up the externs (empty for this test)
        SourceFile extern = SourceFile.fromCode("externs.js", "");

        // Input source file
        SourceFile input = SourceFile.fromCode("test.js", code);

        // Compile the source
        compiler.compile(extern, input, options);

        // Check that compilation results in a specific warning
        assertEquals(1, compiler.getWarningCount());
        
        JSError warning = compiler.getWarnings()[0];
        assertEquals("Parse error. Non-JSDoc comment has annotations. Did you mean to start it with '/**'?", 
                     warning.description);

        // Now test with a '/*!' comment, which according to the bug report, neither warns nor preserves
        code = "/*! @license Foo License */ alert('foo');";
        input = SourceFile.fromCode("test.js", code);

        // Reset the compiler and compile again
        compiler = new Compiler();
        compiler.compile(extern, input, options);

        // This should not result in any warnings, but it should have preserved the comment
        assertEquals("/* @license Foo License */ alert('foo');", compiler.toSource());
    }
}
