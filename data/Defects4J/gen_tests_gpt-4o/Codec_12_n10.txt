
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.commons.codec.binary.Base64InputStream;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class Base64InputStreamTest {

    @Test
    public void testSkip() throws Throwable {
        InputStream ins = new ByteArrayInputStream("AAAA////".getBytes("ISO-8859-1")); // should decode to {0, 0, 0, 255, 255, 255}
        Base64InputStream instance = new Base64InputStream(ins);

        assertEquals(3L, instance.skip(3L)); // should skip 3 decoded characters, or 4 encoded characters

        assertEquals(255, instance.read()); // Currently returns 3, as it is decoding "A/", not "//"
    }
    
    // Additional code added to Base64InputStream (or BaseNCodecInputStream) to fix the issue:
    // Note: This is to show the change needed in Base64InputStream class.
    // @Override
    // public long skip(long n) throws IOException {
    //     long bytesRead = 0;
    //     while ((bytesRead < n) && (read() != -1)) {
    //         bytesRead++;
    //     }
    //     return bytesRead;
    // }
}
