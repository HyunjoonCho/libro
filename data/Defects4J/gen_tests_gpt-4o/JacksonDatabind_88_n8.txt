
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;

import static org.junit.Assert.fail;

public class TypeCheckTest {

    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
    @JsonSubTypes({
            @JsonSubTypes.Type(value = SubTypeA.class, name = "A"),
            @JsonSubTypes.Type(value = SubTypeB.class, name = "B")
    })
    static abstract class BaseType {
        public String commonProperty;
    }

    static class SubTypeA extends BaseType {
        public String specificPropertyA;
    }

    static class SubTypeB extends BaseType {
        public String specificPropertyB;
    }

    @Test
    public void testMissingTypeCheckWithPolymorphicTypeId() {
        ObjectMapper mapper = new ObjectMapper();

        // JSON with type id refers to SubTypeB, but the content is structured for SubTypeA
        String jsonInput = "{\"type\":\"B\", \"commonProperty\":\"commonValue\", \"specificPropertyA\":\"valueA\"}";

        try {
            // Attempting to deserialize the JSON into the base type
            BaseType baseType = mapper.readValue(jsonInput, BaseType.class);
            fail("Expected an exception due to type mismatch between the declared type and the actual type content.");
        } catch (JsonProcessingException e) {
            // Expected consequence due to type mismatch
            System.out.println("Caught expected JsonProcessingException: " + e.getMessage());
        }
    }
}
