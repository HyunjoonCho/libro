public void testCallbackFunctionWarning() {
    // Define a parametrized function using JSDoc to specify a function type
    // The function expects an object with a structure {func: function(): undefined}
    // Annotate the parameter type
    String js = "/** @param {{func: function()}} obj */ function test1(obj) {};";
    
    // Simulate the JavaScript compilation
    TestErrorManager errorManager = new TestErrorManager();
    CompilerOptions options = new CompilerOptions();

    // Set warning level options if needed
    options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.WARNING);

    // Create a compiler object
    Compiler compiler = new Compiler(errorManager);
    
    // Add externally defined libraries if necessary
    List<SourceFile> externs = AbstractCommandLineRunner.getBuiltinExterns(CompilerOptions.Environment.BROWSER);

    // Define source files for our testing code block
    SourceFile input = SourceFile.fromCode("testcode", js + "var fnStruc1 = {}; fnStruc1.func = function() {}; test1(fnStruc1);");

    // Compile the code
    compiler.compile(externs, Collections.singletonList(input), options);

    // Verify that there are warnings
    assertTrue("Expected warnings", errorManager.getWarningCount() > 0);
    
    // Check if the specific warning message is in the error manager
    String expectedWarning = "actual parameter 1 of func does not match formal parameter";
    boolean foundWarning = errorManager.getWarnings().stream()
                                .anyMatch(warning -> warning.getDescription().contains(expectedWarning));
    
    assertTrue("Expected specific warning message was found", foundWarning);
}