
import org.junit.Test;
import static org.junit.Assert.*;

public class RecordTypeTest {
    @Test
    public void testPropertiesDefinedOnAnyRecordType() {
        String jsCode1 = ""
            + "/** @typedef {{name: string, id: number}} */\n"
            + "var RecordType1;\n\n"
            + "/**\n"
            + " * @param {RecordType1} rec\n"
            + " */\n"
            + "var func = function(rec) {\n"
            + "  alert(rec.name2);\n"
            + "};\n"
            + "func({name: 'jim', id: 0});\n";

        String jsCode2 = ""
            + "/** @typedef {{name: string, id: number}} */\n"
            + "var RecordType1;\n\n"
            + "/** @typedef {{name2: string}} */\n"
            + "var RecordType2;\n\n"
            + "/**\n"
            + " * @param {RecordType1} rec\n"
            + " */\n"
            + "var func = function(rec) {\n"
            + "  alert(rec.name2);\n"
            + "};\n"
            + "func({name: 'jim', id: 0});\n";

        try {
            // Assuming compileJS is a method that compiles JS code with Closure Compiler
            boolean error1 = compileJS(jsCode1);
            boolean error2 = compileJS(jsCode2);

            assertTrue("First code block should generate an error.", error1);
            assertFalse("Second code block should not generate an error.", error2);

        } catch (Exception e) {
            fail("Compilation process failed: " + e.getMessage());
        }
    }

    // Mock method to simulate JS compilation with Closure Compiler
    private boolean compileJS(String jsCode) {
        // Code to invoke Closure Compiler and return true if it detects errors
        // This is just a placeholder to reflect the test logic
        return jsCode.contains("name2 never defined");
    }
}
