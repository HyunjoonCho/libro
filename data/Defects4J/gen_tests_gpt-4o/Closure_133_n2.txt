
import com.google.javascript.jscomp.parsing.ParserRunner;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.jstype.JSTypeExpression;
import com.google.javascript.jscomp.parsing.parser.Parser;
import com.google.javascript.jscomp.parsing.parser.Parser.Config;
import com.google.javascript.jscomp.parsing.parser.SourceFile;
import com.google.javascript.jscomp.parsing.Config.LanguageMode;
import com.google.javascript.jscomp.parsing.Config.StrictMode;
import org.junit.Test;

public class JsDocParserTest {

    @Test
    public void testJsDocParsingError() {
        String jsCode = 
            "/** \n" +
            " * @return {@code foo} bar \n" +
            " * baz. */\n" +
            "var x;";

        SourceFile sourceFile = SourceFile.fromCode("test.js", jsCode);
        
        ParserRunner.Config config = ParserRunner.createConfig(LanguageMode.ECMASCRIPT_2020, StrictMode.SLOPPY);
        
        try {
            // Attempt to parse the JavaScript code with JSDoc
            Node root = ParserRunner.parse(sourceFile, config, null, null).ast;
            // If no exceptions are thrown, we expect the parser to succeed without exceptions
            assertNotNull("Parsing should produce a non-null AST", root);
        } catch (Exception e) {
            // If we catch unexpected exceptions, the test should fail
            fail("Exception should not be thrown when parsing valid JSDoc: " + e.getMessage());
        }
    }
}
