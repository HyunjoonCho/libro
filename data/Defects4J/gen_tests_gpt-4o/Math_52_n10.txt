
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;
import org.apache.commons.math3.geometry.euclidean.threed.Rotation;
import org.apache.commons.math3.geometry.euclidean.threed.RotationConvention;
import org.apache.commons.math3.exception.MathIllegalArgumentException;
import org.junit.Test;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class RotationNumericalIssueTest {

    @Test
    public void testNumericalIssuesInRotationCreation() {
        // Given vectors u1, u2, v1, v2
        Vector3D u1 = new Vector3D(-4921140.837095533, -2.1512094250440013E7, -890093.279426377);
        Vector3D u2 = new Vector3D(-2.7238580938724895E9, -2.169664921341876E9, 6.749688708885301E10);
        Vector3D v1 = new Vector3D(1, 0, 0);
        Vector3D v2 = new Vector3D(0, 0, 1);

        try {
            // When constructing a rotation from these vector pairs
            Rotation rotation = new Rotation(u1, u2, v1, v2, RotationConvention.VECTOR_OPERATOR);
            
            // Get the quaternion representation of the rotation
            double q0 = rotation.getQ0();
            double q1 = rotation.getQ1();
            double q2 = rotation.getQ2();
            double q3 = rotation.getQ3();

            // Then the quaternion should not have any NaN components
            assertFalse(Double.isNaN(q0));
            assertFalse(Double.isNaN(q1));
            assertFalse(Double.isNaN(q2));
            assertFalse(Double.isNaN(q3));

        } catch (MathIllegalArgumentException e) {
            // If an exception is caught, the test should fail
            assertTrue("A MathIllegalArgumentException was thrown indicating numerical instability or invalid rotation", false);
        }
    }
}
