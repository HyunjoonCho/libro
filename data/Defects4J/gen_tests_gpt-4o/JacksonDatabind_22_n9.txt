
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.core.JsonGenerator;
import org.junit.Test;

import java.io.IOException;

import static org.junit.Assert.*;

public class CustomSerializerWithJsonValueTest {

    static class CustomPojo {
        private final String value;

        public CustomPojo(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return "JsonValue: " + value;
        }
    }

    static class CustomPojoSerializer extends JsonSerializer<CustomPojo> {
        @Override
        public void serialize(CustomPojo value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeString("CustomSerializer: " + value.value);
        }
    }

    @Test
    public void testCustomSerializerPrecedence() throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addSerializer(CustomPojo.class, new CustomPojoSerializer());
        objectMapper.registerModule(module);

        CustomPojo pojo = new CustomPojo("test");
        String jsonResult = objectMapper.writeValueAsString(pojo);

        // The expected behavior is that the custom serializer is used,
        // but due to the bug, it uses the method annotated with @JsonValue.
        assertEquals("\"CustomSerializer: test\"", jsonResult);
    }
}
