
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresFactory;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresBuilder;
import org.apache.commons.math3.fitting.leastsquares.MultivariateJacobianFunction;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem;
import org.apache.commons.math3.linear.RealVector;
import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.util.Pair;
import org.junit.Test;
import static org.junit.Assert.assertArrayEquals;

public class LevenbergMarquardtInconsistencyTest {

    @Test
    public void testInconsistencyInLevenbergMarquardt() {
        // Define a simple model, such as y = a * x + b
        MultivariateJacobianFunction model = new MultivariateJacobianFunction() {
            @Override
            public Pair<RealVector, RealMatrix> value(RealVector point) {
                double a = point.getEntry(0);
                double b = point.getEntry(1);
                double[] values = new double[] { a * 1 + b, a * 2 + b, a * 3 + b };
                RealMatrix jacobian = new Array2DRowRealMatrix(new double[][]{
                    {1, 1},
                    {2, 1},
                    {3, 1}
                });
                return new Pair<>(new ArrayRealVector(values), jacobian);
            }
        };

        // Target observed values, for example
        double[] target = { 1.0, 2.0, 3.0 };
        double[] initialGuess = { 0.0, 0.0 };

        // Build the least squares problem
        LeastSquaresOptimizer optimizer = new LevenbergMarquardtOptimizer();
        LeastSquaresProblem problem = new LeastSquaresBuilder()
                .model(model)
                .target(target)
                .start(initialGuess)
                .maxEvaluations(1000)
                .maxIterations(1000)
                .build();

        // Perform the optimization
        LeastSquaresOptimizer.Optimum optimum = optimizer.optimize(problem);

        // Retrieve the optimized parameters
        double[] optimizedPoint = optimum.getPoint().toArray();

        // Calculate the residuals and check the cost
        RealVector calculatedValues = model.value(new ArrayRealVector(optimizedPoint)).getFirst();
        RealVector residuals = calculatedValues.subtract(new ArrayRealVector(target));

        // Ensure that the optimized point corresponds to the residuals and cost
        assertArrayEquals("Optimized parameters should lead to correct residuals",
                          residuals.toArray(), optimum.getResiduals().toArray(), 1e-6);
    }
}
