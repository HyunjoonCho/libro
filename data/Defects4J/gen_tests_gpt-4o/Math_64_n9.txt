public void testLevenbergMarquardtOptimization() {
    LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();
    DifferentiableMultivariateVectorialFunction function = new DifferentiableMultivariateVectorialFunction() {
        @Override
        public double[] value(double[] point) {
            return new double[] { point[0] * point[0] + point[1], point[0] + point[1] * point[1] };
        }
        
        @Override
        public MultivariateMatrixFunction jacobian() {
            return new MultivariateMatrixFunction() {
                @Override
                public double[][] value(double[] point) {
                    return new double[][] { { 2 * point[0], 1 }, { 1, 2 * point[1] } };
                }
            };
        }
    };
    double[] startPoint = new double[] {1.0, 1.0};
    double[] target = new double[] {0.0, 0.0};
    double[] weight = new double[] {1.0, 1.0};
    VectorialPointValuePair result = optimizer.optimize(function, target, weight, startPoint);
    
    double[] computedPoint = result.getPoint();
    double[] residuals = function.value(computedPoint);

    double computedCost = 0.0;
    for (int i = 0; i < residuals.length; i++) {
        computedCost += residuals[i] * residuals[i] * weight[i];
    }
    computedCost = Math.sqrt(computedCost);

    assertEquals("Cost computed from residuals should match the objective function value", computedCost, optimizer.getRMS(), 1e-6);
    assertArrayEquals("Computed point values should match function results", result.getValue(), function.value(computedPoint), 1e-6);
}