
import org.apache.commons.compress.utils.BitInputStream;
import org.junit.Test;
import java.io.ByteArrayInputStream;
import java.nio.ByteOrder;

import static org.junit.Assert.*;

public class BitInputStreamTest {
    
    @Test
    public void testOverflowInBitInputStream() {
        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {87, 45, 66, 15, 90, 29, 88, 61, 33, 74});
        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);

        try {
            // Read 5 bits - should work fine
            long firstRead = bin.readBits(5);
            assertEquals(23, firstRead); // Expected: 23 (first 5 bits of 87 in little endian)

            // Attempt to read 63 bits - this should cause an overflow internally.
            long secondRead = bin.readBits(63);
            // Not asserting here as we expect incorrect behavior due to bug

            // Read 12 bits - results will be incorrect because of previous overflow
            long thirdRead = bin.readBits(12);
            // Not asserting here as well; testing for handling overflow

            // Use debug prints to see the outputs (optional, helpful during exploration)
            System.out.println("First Read (5 bits): " + firstRead);
            System.out.println("Second Read (63 bits): " + secondRead);
            System.out.println("Third Read (12 bits): " + thirdRead);

        } catch (Exception e) {
            // The test should not throw an exception, even though results won't be correct
            fail("An exception should not have been thrown.");
        }
    }
}
