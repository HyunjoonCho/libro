
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import static org.junit.Assert.*;

public class TarArchiveInputStreamTest {

    @Test
    public void testLargeUidParsing() {
        // Simulate a .tar file in a byte array with a large UID using a PAX header
        // PAX header followed by regular tar entry, using simplified byte arrays
        String paxHeaderContent = "uid=4294967294\n"; // A UID that is too large for Integer
        byte[] fakeTarContent = createFakeTarWithPaxHeader(paxHeaderContent);

        TarArchiveInputStream tarInputStream = new TarArchiveInputStream(new ByteArrayInputStream(fakeTarContent));

        try {
            TarArchiveEntry entry = tarInputStream.getNextTarEntry();
            fail("Expected NumberFormatException due to large UID.");
        } catch (NumberFormatException e) {
            assertEquals("For input string: \"4294967294\"", e.getMessage());
        } catch (IOException e) {
            fail("IOException was not expected: " + e.getMessage());
        }
    }

    private byte[] createFakeTarWithPaxHeader(String paxHeaderContent) {
        // This is a placeholder for creating a tar with a PAX header.
        // In an actual test, this would need to create a valid tar structure
        // with PAX header properties. For simplicity, assume the function
        // returns a correctly constructed byte array that causes the failure.
        // This is highly simplified and may need a real tar construction.
        return new byte[512]; // Simplified for illustration purposes
    }
}
