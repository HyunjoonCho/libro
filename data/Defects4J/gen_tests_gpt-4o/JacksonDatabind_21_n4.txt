
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.DeserializationFeature;
import org.junit.Test;

import static org.junit.Assert.*;

public class EnumDeserializationTest {

    enum TestEnum {
        VALUE_ONE("value1");

        private String valueInJson;

        TestEnum(String valueInJson) {
            this.valueInJson = valueInJson;
        }

        @JsonCreator
        public static TestEnum getEnumFromValue(String value) {
            for (TestEnum testEnum : values()) {
                if (testEnum.valueInJson.equals(value)) {
                    return testEnum;
                }
            }
            throw new IllegalArgumentException();
        }

        @Override
        public String toString() {
            return valueInJson;
        }
    }

    @Test
    public void testEnumDeserializationWithJsonCreator() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        TestEnum result = mapper.readValue("\"value1\"", TestEnum.class);
        assertEquals(TestEnum.VALUE_ONE, result);
    }

    @Test
    public void testEnumSerializationWithToString() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true);
        String json = mapper.writeValueAsString(TestEnum.VALUE_ONE);
        assertEquals("\"value1\"", json);
    }

    // Note: This is how you might ideally want the test if a similar feature to Gson's @SerializedName existed
    @Test
    public void testEnumDeserializationWithoutBoilerplate() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        String jsonValue = "\"value1\"";
        
        // Assuming @JsonProperty worked similarly to @SerializedName for enums
        TestEnum result = mapper.readValue(jsonValue, TestEnum.class);
        assertEquals(TestEnum.VALUE_ONE, result);
    }
}
