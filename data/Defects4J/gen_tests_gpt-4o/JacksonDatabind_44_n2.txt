
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;
import org.junit.Test;
import static org.junit.Assert.*;

public class PolymorphicDeserializationTest {

    // Define the base and subtypes
    public static class Base {
        public String baseProperty;

        // Define a constructor for easier test setup
        public Base() {}
        
        public Base(String baseProperty) {
            this.baseProperty = baseProperty;
        }
    }

    public static class SubType extends Base {
        public String subProperty;

        public SubType() {}
        
        public SubType(String baseProperty, String subProperty) {
            super(baseProperty);
            this.subProperty = subProperty;
        }
    }

    @Test
    public void testPolymorphicDeserializationWithDefaultImpl() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        
        // Configure the ObjectMapper to use a defaultImpl for polymorphic types
        StdTypeResolverBuilder typeResolver = new StdTypeResolverBuilder()
                .init(Id.CLASS, null)
                .inclusion(As.PROPERTY)
                .typeProperty("@class")
                .defaultImpl(SubType.class);
        
        mapper.setDefaultTyping(typeResolver);

        // JSON string without the type information, should use defaultImpl (SubType)
        String json = "{\"baseProperty\":\"baseValue\",\"subProperty\":\"subValue\"}";
        
        Base result = mapper.readValue(json, Base.class);

        // Assertions to test if both base and subtype properties are resolved properly
        assertNotNull(result);
        assertTrue(result instanceof SubType);
        assertEquals("baseValue", result.baseProperty);
        assertEquals("subValue", ((SubType) result).subProperty);
    }
}
