public void testCMAESOptimizerBoundsPrecision() {
    double[] startPoint = {0.5, 0.5};
    double[] lowerBound = {0.0, 0.0};
    double[] upperBound = {1.0, 1.0};
    CMAESOptimizer optimizer = new CMAESOptimizer(10000, 0.0, true, 0, 0, new Well19937c(), false);

    MultivariateFunction fitnessFunction = new MultivariateFunction() {
        @Override
        public double value(double[] point) {
            double sum = 0;
            for (double v : point) {
                sum += v;
            }
            return -sum;
        }
    };

    PointValuePair result = optimizer.optimize(
            new MaxEval(1000),
            new ObjectiveFunction(fitnessFunction),
            new SimpleBounds(lowerBound, upperBound),
            new InitialGuess(startPoint),
            GoalType.MINIMIZE,
            new CMAESOptimizer.Sigma(new double[]{0.3, 0.3})
    );

    double[] optimalPoint = result.getPoint();

    // The bug described should ideally show a difference in precision between the lower bound and upper bound.
    // Expect the optimizer to converge close to the lower bound, and we should test near both bounds for precision.
    assertTrue("Precision near lower bound not as expected", Math.abs(optimalPoint[0]) < 1e-5);
    assertTrue("Precision near upper bound not as expected", Math.abs(optimalPoint[1] - upperBound[1]) < 1e-1);
}