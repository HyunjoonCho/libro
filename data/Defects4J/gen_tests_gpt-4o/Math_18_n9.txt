
import org.apache.commons.math3.optimization.PointValuePair;
import org.apache.commons.math3.optimization.direct.CMAESOptimizer;
import org.apache.commons.math3.analysis.MultivariateFunction;
import org.junit.Test;
import static org.junit.Assert.assertTrue;

public class CMAESOptimizerTest {
    
    @Test
    public void testCMAESOptimizerResolutionNearBounds() {
        // Define the objective function: simple quadratic function with minimum at (5,5).
        MultivariateFunction objectiveFunction = new MultivariateFunction() {
            @Override
            public double value(double[] point) {
                // Objective function: f(x) = (x0-5)^2 + (x1-5)^2
                // The global minimum is at (5, 5) with a value of 0.
                return Math.pow(point[0] - 5, 2) + Math.pow(point[1] - 5, 2);
            }
        };
        
        // Initialization parameters
        double[] startPoint = {0.5, 0.5}; // Starting point for optimization
        double[] lowerBound = {0, 0}; // Lower bound of the parameters
        double[] upperBound = {10, 10}; // Upper bound of the parameters

        // Create a CMAESOptimizer with a set number of max evaluations
        CMAESOptimizer optimizer = new CMAESOptimizer(10000, 1e-9, true, 0, 0, null, false, null);

        // Perform optimization
        PointValuePair result = optimizer.optimize( 
                new CMAESOptimizer.SimpleBounds(lowerBound, upperBound),
                CMAESOptimizer.GoalType.MINIMIZE,
                objectiveFunction,
                CMAESOptimizer.CMAESOptimizerMode.SIGMA,
                new CMAESOptimizer.Sigma(new double[] {1.0, 1.0}),
                startPoint
        );

        // Get optimized point
        double[] optimizedPoint = result.getPoint();

        // Test if the optimizer finds a solution close enough to the known global minimum point
        double errorTolerance = 0.1; // Define how close we need to be
        assertTrue("The optimizer failed to converge to near the global minimum!", 
                   Math.abs(optimizedPoint[0] - 5) < errorTolerance 
                && Math.abs(optimizedPoint[1] - 5) < errorTolerance);
    }
}
