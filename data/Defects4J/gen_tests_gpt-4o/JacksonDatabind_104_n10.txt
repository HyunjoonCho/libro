
import com.fasterxml.jackson.databind.util.StdDateFormat;
import org.junit.Test;

import java.text.ParseException;
import java.util.Date;

import static org.junit.Assert.*;

public class LargeYearFormattingTest {

    @Test
    public void testLargeYearDateFormatting() {
        StdDateFormat formatter = new StdDateFormat();

        // Test case for parsing and formatting dates with large years
        String formattedDate;
        try {
            // Create a date with a year beyond 9999
            Date largeYearDate = new Date(Long.MAX_VALUE);
            formattedDate = formatter.format(largeYearDate);

            // This should either succeed with a proper formatted date or throw an exception
            Date parsedDate = formatter.parse(formattedDate);

            // If no exception, check that the parsed date matches the original date's time
            assertEquals(largeYearDate.getTime(), parsedDate.getTime());
        } catch (ParseException e) {
            // If the implementation doesn't support large years, it should at least throw an exception
            fail("Parsing large year dates should be handled or explicitly rejected: " + e.getMessage());
        }
    }

    @Test(expected = ParseException.class)
    public void testNegativeDatesHandling() throws ParseException {
        StdDateFormat formatter = new StdDateFormat();

        // Attempt to create and format a date with Long.MIN_VALUE
        Date negativeDate = new Date(Long.MIN_VALUE);
        String formattedDate = formatter.format(negativeDate);

        // This should throw an exception or correctly handle the parsing
        formatter.parse(formattedDate);
    }
}
