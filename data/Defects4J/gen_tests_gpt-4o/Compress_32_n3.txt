
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import static org.junit.Assert.assertEquals;

public class TarArchiveInputStreamTest {

    @Test
    public void testLargeUIDHandling() throws IOException {
        // Construct a minimal PAX header with a large UID: 4294967294 (unsigned int max - 1)
        String paxHeader =
                "30 uid=4294967294\n" +
                "24 path=largeUIDFile\n" +
                "52 atime=0\n" +
                "52 ctime=0\n" +
                "52 mtime=0\n";
        byte[] data = createTarWithPaxHeader(paxHeader);

        try (TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(data))) {
            TarArchiveEntry entry = tais.getNextTarEntry();
            assertEquals(4294967294L, entry.getLongUserId()); // Assuming TarArchiveEntry handles it as Long
            assertEquals("largeUIDFile", entry.getName());
        }
    }

    private byte[] createTarWithPaxHeader(String paxHeader) {
        // This method should create a valid tar archive byte array with the provided PAX header

        // PAX header block
        byte[] paxHeaderBytes = new byte[512];
        System.arraycopy(paxHeader.getBytes(), 0, paxHeaderBytes, 0, paxHeader.length());

        // Normal tar header block (with minimal required info)
        byte[] tarHeaderBytes = new byte[512];
        // fill tarHeaderBytes with appropriate values
        System.arraycopy("largeUIDFile".getBytes(), 0, tarHeaderBytes, 0, "largeUIDFile".length());

        // Concatenate both headers to simulate a tar file stream
        byte[] tarFileData = new byte[1024];
        System.arraycopy(paxHeaderBytes, 0, tarFileData, 0, 512);
        System.arraycopy(tarHeaderBytes, 0, tarFileData, 512, 512);

        return tarFileData;
    }
}
