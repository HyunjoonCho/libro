
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import org.junit.Test;
import static org.junit.Assert.*;

public class PolymorphicTypeIdTest {

    // Base class with type info
    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
    @JsonSubTypes({
        @JsonSubTypes.Type(value = SubType1.class, name = "type1"),
        @JsonSubTypes.Type(value = SubType2.class, name = "type2")
    })
    static abstract class BaseType {
        public String name;
    }

    // Subtype 1
    static class SubType1 extends BaseType {
        public int specificField1;
    }

    // Subtype 2
    static class SubType2 extends BaseType {
        public String specificField2;
    }

    @Test
    public void testIncompatibleTypeDeserialization() {
        ObjectMapper objectMapper = new ObjectMapper();

        // JSON intended for SubType1 but with "type" indicating SubType2
        String json = "{\"type\":\"type2\", \"name\":\"TestName\", \"specificField1\": 42}";

        try {
            BaseType result = objectMapper.readValue(json, BaseType.class);
            // We should not reach this point; an exception should be thrown
            fail("Expected exception due to incompatible types not thrown.");
        } catch (Exception e) {
            // Check that an exception is thrown and it's due to type incompatibility
            assertTrue(e.getMessage().contains("unrecognized field") || e.getMessage().contains("cannot deserialize"));
        }
    }
}
