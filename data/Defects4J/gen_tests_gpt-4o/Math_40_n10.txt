
import org.apache.commons.math3.analysis.UnivariateFunction;
import org.apache.commons.math3.analysis.solvers.AllowedSolution;
import org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver;
import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class BracketingNthOrderBrentSolverTest {

    @Test
    public void testAgingFeatureFailure() {
        // Define a function that has roots close to the bracketing points described
        UnivariateFunction function = new UnivariateFunction() {
            @Override
            public double value(double x) {
                if (x == 12500.0) {
                    return 3.7e-16;
                } else if (x == 12500.03) {
                    return -7.0e-5;
                }
                return 0.0; // Ideally simulate values near the actual root to reproduce stuck behavior
            }
        };

        // Setup the solver with sufficient precision and max evaluations
        BracketingNthOrderBrentSolver solver = new BracketingNthOrderBrentSolver(
                1.0e-15, 1.0e-10, 1.0e-8, 5 // 5 is the default nth order
        );

        // Attempt to solve within the bracket where failure was observed
        double lowerBound = 12500.0;
        double upperBound = 12500.03;

        try {
            // Forcing the solver to evaluate within this interval and handle allowed solution
            double root = solver.solve(1000, function, lowerBound, upperBound, AllowedSolution.ANY_SIDE);
            // Check conditions here to ensure that proper handling occurs, expect root to be near lowerBound
            assertTrue(Math.abs(root - lowerBound) < 1.0e-5 || Math.abs(root - upperBound) < 1.0e-5);
        } catch (Exception e) {
            // Fail the test if an exception is thrown
            e.printStackTrace();
            assertTrue("Solver should not fail with exception: " + e.getMessage(), false);
        }
    }
}
