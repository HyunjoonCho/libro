public void testTypeInferenceWithUndefined() {
    // Create a function f that takes an undefined type
    // and tries to call function g if x is not undefined
    CompilerOptions options = new CompilerOptions();
    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
    Compiler compiler = new Compiler();
    String jsCode = ""
        + "/** @param {string} x */"
        + "function g(x) {}"
        + "/** @param {undefined} x */"
        + "function f(x) {"
        + "  if (x != undefined) { g(x); }"
        + "}";
    
    WarningReporter reporter = new WarningReporter();
    compiler.compile(
        CommandLineRunner.getDefaultExterns(options),
        ImmutableList.of(SourceFile.fromCode("test.js", jsCode)),
        options);

    assertFalse("Unexpected warning or error", reporter.hasWarningOrError());
}

class WarningReporter extends BasicErrorManager {
    private boolean hasWarningOrError = false;

    @Override
    public void report(CheckLevel level, JSError error) {
        super.report(level, error);
        hasWarningOrError = true;
    }

    @Override
    protected void printSummary() {}

    public boolean hasWarningOrError() {
        return hasWarningOrError;
    }
}