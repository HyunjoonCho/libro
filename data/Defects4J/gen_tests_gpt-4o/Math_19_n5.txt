
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.math3.analysis.MultivariateFunction;
import org.junit.Test;
import static org.junit.Assert.fail;

public class CMAESOptimizerTest {

    @Test
    public void testWideBoundsCausesNaNParameters() {
        // Define a simple fitness function that fails on NaN inputs
        MultivariateFunction fitnessFunction = point -> {
            for (double value : point) {
                if (Double.isNaN(value)) {
                    fail("FitnessFunction received NaN as input.");
                }
            }
            return 0; // Fitness value is not important for this test
        };

        // Very wide bounds that may lead to computations involving NaN
        double[] lowerBound = new double[] {-Double.MAX_VALUE, -Double.MAX_VALUE};
        double[] upperBound = new double[] {Double.MAX_VALUE, Double.MAX_VALUE};

        CMAESOptimizer optimizer = new CMAESOptimizer.Builder(1000)
                .setCheckFeasableCount(0)
                .build();

        try {
            optimizer.optimize(
                    new CMAESOptimizer.OptimizationData() {
                        @Override
                        public <T> T getData(Class<T> clazz) {
                            return null;
                        }
                    },
                    new ObjectiveFunction(fitnessFunction),
                    GoalType.MINIMIZE,
                    new InitialGuess(new double[] {0, 0}),
                    new SimpleBounds(lowerBound, upperBound)
            );
        } catch (Exception e) {
            e.printStackTrace();
            fail("Optimizer threw an unexpected exception: " + e.getMessage());
        }
    }
}
