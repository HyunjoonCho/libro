
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.type.SimpleType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

import static org.junit.Assert.*;

public class SimpleTypeRegressionTest {

    static class SampleClass {
        public int value;
    }

    @Test
    public void testSimpleTypeConstructMethod() throws Exception {
        // Using the deprecated SimpleType.construct(Class) method
        JavaType simpleType = SimpleType.construct(SampleClass.class);

        // Validate the class type
        assertEquals(SampleClass.class, simpleType.getRawClass());
        
        // Check if we can introspect fields correctly
        Field[] fields = SampleClass.class.getDeclaredFields();
        assertNotNull(fields);
        assertEquals(1, fields.length);
        assertEquals("value", fields[0].getName());

        // Check if we can introspect methods correctly
        Method[] methods = SampleClass.class.getDeclaredMethods();
        assertNotNull(methods);
        // Confirm presence of methods, expect at least one method
        assertTrue(methods.length > 0);
    }

    @Test
    public void testTypeFactoryResolution() {
        TypeFactory typeFactory = TypeFactory.defaultInstance();
        JavaType resolvedType = typeFactory.constructType(SampleClass.class);

        // Creating a type using TypeFactory should behave correctly
        assertEquals(SampleClass.class, resolvedType.getRawClass());
        
        // Utilizing resolved type further in Jackson's ObjectMapper
        ObjectMapper mapper = new ObjectMapper();
        // We check here whether we can do something basic like a serialization
        SampleClass sampleObject = new SampleClass();
        sampleObject.value = 123;

        String serialized = mapper.writeValueAsString(sampleObject);
        assertTrue(serialized.contains("value"));
    }
}
