
import static org.junit.Assert.assertTrue;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class CompilerOutputTest {

    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();
    private final PrintStream originalOut = System.out;

    @Before
    public void setUpStreams() {
        System.setOut(new PrintStream(outContent));
    }

    @After
    public void restoreStreams() {
        System.setOut(originalOut);
    }

    @Test
    public void testErrorOutputNotTruncated() {
        String fileContent = "alert(foo);\nalert(bar);";
        // Assuming Compiler is a class that simulates the JS compilation and write output
        Compiler.compile(fileContent);

        String output = outContent.toString();
        assertTrue("Output should contain error for 'foo' and include source line",
                output.contains("test.js:1: ERROR - variable foo is undefined")
                        && output.contains("alert(foo);"));
        assertTrue("Output should contain error for 'bar' and include source line",
                output.contains("test.js:2: ERROR - variable bar is undefined")
                        && output.contains("alert(bar);")
                        && output.contains("^"));
    }
}

// Mock implementation of Compiler class - replace this with the real implementation
class Compiler {
    public static void compile(String fileContent) {
        // Simulating compilation and output generation
        System.out.println("test.js:1: ERROR - variable foo is undefined");
        System.out.println("alert(foo);");
        System.out.println(" ^");
        System.out.println();
        System.out.println("test.js:2: ERROR - variable bar is undefined");
        System.out.println("alert(bar);");
        System.out.println(" ^");
        System.out.println();
        System.out.println("2 error(s), 0 warning(s)");
    }
}
