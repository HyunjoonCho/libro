
import org.apache.commons.math3.optim.univariate.BrentOptimizer;
import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;
import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;
import org.apache.commons.math3.optim.univariate.GoalType;
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class BrentOptimizerTest {

    @Test
    public void testBrentOptimizerWithQuadraticFunction() {
        // Quadratic function: f(x) = (x - 2)^2, minimum at x = 2
        UnivariateObjectiveFunction function = new UnivariateObjectiveFunction(x -> (x - 2) * (x - 2));
        
        // Setting up BrentOptimizer with a small tolerance
        BrentOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);
        
        // Optimizing with the goal of finding the minimum
        UnivariatePointValuePair result = optimizer.optimize(function, GoalType.MINIMIZE, 0.0, 4.0);
        
        // Expected minimum position is x = 2 and value is f(2) = 0
        double expectedPosition = 2.0;
        double expectedValue = 0.0;

        // Asserting that the optimizer finds the expected minimum position within an acceptable tolerance
        assertEquals(expectedPosition, result.getPoint(), 1e-8);
        // Asserting that the function value at the found minimum is within an acceptable tolerance
        assertEquals(expectedValue, result.getValue(), 1e-8);
    }
    
    @Test
    public void testBrentOptimizerWithSinFunction() {
        // Sin function: f(x) = sin(x), has local minima and maxima
        UnivariateObjectiveFunction function = new UnivariateObjectiveFunction(x -> Math.sin(x));
        
        // Testing within the interval [3 * PI/2, 5 * PI/2] where we know there is a minimum at 3 * PI/2
        double lowerBound = 3 * Math.PI / 2;
        double upperBound = 5 * Math.PI / 2;
        
        // Setting up BrentOptimizer with a small tolerance
        BrentOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);
        
        // Optimizing with the goal of finding the minimum
        UnivariatePointValuePair result = optimizer.optimize(function, GoalType.MINIMIZE, lowerBound, upperBound);
        
        // Expected minimum position within this interval is x = 3 * PI/2 and value is f(3 * PI/2) = -1
        double expectedPosition = 3 * Math.PI / 2;
        double expectedValue = -1.0;

        // Asserting that the optimizer finds the expected minimum position within an acceptable tolerance
        assertEquals(expectedPosition, result.getPoint(), 1e-8);
        // Asserting that the function value at the found minimum is within an acceptable tolerance
        assertEquals(expectedValue, result.getValue(), 1e-8);
    }
}
