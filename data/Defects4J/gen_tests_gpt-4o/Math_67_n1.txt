
import org.apache.commons.math3.optim.univariate.MultiStartUnivariateOptimizer;
import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;
import org.apache.commons.math3.optim.univariate.SearchInterval;
import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;
import org.apache.commons.math3.optim.univariate.BracketFinder;
import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class MultiStartUnivariateRealOptimizerTest {

    private MultiStartUnivariateOptimizer optimizer;

    @Before
    public void setUp() {
        // Initialize the MultiStartUnivariateOptimizer with a base optimizer.
        // For demonstration, assume there's a simple optimizer provided by a library.
        optimizer = new MultiStartUnivariateOptimizer(new BracketFinder(), 10);
    }

    @Test
    public void testGetResultMatchesBestOptimization() {
        // Define the function to optimize; for example, a simple quadratic function.
        UnivariateObjectiveFunction function = new UnivariateObjectiveFunction(x -> (x - 3) * (x - 3));

        // Running the optimization over given search interval.
        SearchInterval interval = new SearchInterval(-10, 10);
        UnivariatePointValuePair optimum = optimizer.optimize(function, interval);

        // Verify that the result from getResult matches the best known result
        double bestResult = optimizer.getResult();

        // The best known optimum result should have the same x-value
        assertEquals(optimum.getPoint(), bestResult, 1e-9);
        
        // Additionally, verify that getFunctionValue also returns the best known value
        double bestFunctionValue = optimizer.getFunctionValue();
        
        // The function value at this optimum point should match
        assertEquals(optimum.getValue(), bestFunctionValue, 1e-9);
    }
}
