
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;
import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;

// Simple data model to test generic type deserialization
class ResponseWrapper<T> {
    public T data;
}

// Custom type resolver to return a specific generic type
class CustomTypeIdResolver extends TypeIdResolverBase {
    @Override
    public void init(JavaType baseType) {
    }

    @Override
    public String idFromValue(Object value) {
        return null; // not needed for this test
    }

    @Override
    public String idFromValueAndType(Object value, Class<?> suggestedType) {
        return null; // not needed for this test
    }

    @Override
    public JavaType typeFromId(com.fasterxml.jackson.databind.DatabindContext context, String id) {
        return context.constructType(ResponseWrapper.class);
    }

    @Override
    public JsonTypeInfo.Id getMechanism() {
        return JsonTypeInfo.Id.CUSTOM;
    }
}

public class JacksonTypeIdResolverTest {

    @Test
    public void testGenericTypeRespectedByTypeIdResolver() throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        String json = "{\"data\": \"expectedData\"}";

        // Attempt to deserialize JSON into ResponseWrapper<String>
        JavaType type = mapper.getTypeFactory().constructParametricType(ResponseWrapper.class, String.class);

        ResponseWrapper<String> result = mapper.readerFor(type).withTypeIdResolver(new CustomTypeIdResolver()).readValue(json);

        // Verify if the data field contains the expected value
        assertEquals("expectedData", result.data);
    }
}
