
import org.apache.commons.compress.archivers.ar.ArArchiveEntry;
import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;
import org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

public class ArArchiveTest {

    @Test
    public void testArArchiveDeletionIssue() throws IOException {
        // Setup: Create a sample AR archive with two entries
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ArArchiveOutputStream arOutputStream = new ArArchiveOutputStream(byteArrayOutputStream);

        byte[] entryContent1 = "Content of file 1".getBytes();
        byte[] entryContent2 = "Content of file 2".getBytes();

        ArArchiveEntry entry1 = new ArArchiveEntry("test1.xml", entryContent1.length);
        ArArchiveEntry entry2 = new ArArchiveEntry("test2.xml", entryContent2.length);

        arOutputStream.putArchiveEntry(entry1);
        arOutputStream.write(entryContent1);
        arOutputStream.closeArchiveEntry();

        arOutputStream.putArchiveEntry(entry2);
        arOutputStream.write(entryContent2);
        arOutputStream.closeArchiveEntry();

        arOutputStream.finish();

        // Simulated deletion: Remove test2.xml from entries
        // NOTE: However, the function may not physically remove the entry from the archive, causing the issue described.
        // Instead, we simulate deletion by just excluding the entry while recreating the archive.
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
        ArArchiveInputStream arInputStream = new ArArchiveInputStream(byteArrayInputStream);

        List<ArArchiveEntry> entries = new ArrayList<>();
        ArArchiveEntry entry;
        while ((entry = arInputStream.getNextArEntry()) != null) {
            if (!"test2.xml".equals(entry.getName())) {
                entries.add(entry);
            }
        }

        // Check: Simulate reading the entries and check if deletion occurred
        assertEquals(1, entries.size());
        assertEquals("test1.xml", entries.get(0).getName());

        // Further Tests: Attempt to add a new entry and check file formats as described in the bug
        byteArrayOutputStream = new ByteArrayOutputStream();
        arOutputStream = new ArArchiveOutputStream(byteArrayOutputStream);

        for (ArArchiveEntry retainedEntry : entries) {
            arOutputStream.putArchiveEntry(retainedEntry);
            arOutputStream.write(entryContent1); // Assume correct content linkage
            arOutputStream.closeArchiveEntry();
        }

        // Add new entry
        byte[] newContent = "Content of new file".getBytes();
        ArArchiveEntry newEntry = new ArArchiveEntry("test.txt", newContent.length);
        arOutputStream.putArchiveEntry(newEntry);
        arOutputStream.write(newContent);
        arOutputStream.closeArchiveEntry();

        arOutputStream.finish();

        // Verifying the content results in proper structure
        byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
        arInputStream = new ArArchiveInputStream(byteArrayInputStream);

        // Ensure we can read the archive and it has the right entries
        entry = arInputStream.getNextArEntry();
        assertNotNull(entry);
        assertEquals("test1.xml", entry.getName());

        entry = arInputStream.getNextArEntry();
        assertNotNull(entry);
        assertEquals("test.txt", entry.getName());

        // The issue behavior may be observable when using real external tools such as command line `ar` to inspect
        // the archive; such actions aren't captured purely via Java AR analytic tools.
    }
}
