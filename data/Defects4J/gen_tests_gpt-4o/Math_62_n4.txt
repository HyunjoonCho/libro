
import org.apache.commons.math4.optim.ConvergenceChecker;
import org.apache.commons.math4.optim.PointValuePair;
import org.apache.commons.math4.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BrentOptimizer;
import org.apache.commons.math4.analysis.UnivariateFunction;
import org.apache.commons.math4.analysis.function.Sin;
import org.junit.Test;
import static org.junit.Assert.*;

public class BrentOptimizerTest {

    @Test
    public void testBrentOptimizerWithoutChecker() {
        // Define a basic univariate function (e.g., Sin function)
        UnivariateFunction function = new Sin();

        // Set up a BrentOptimizer without a convergence checker
        BrentOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);
        
        // Trying to optimize without setting a ConvergenceChecker.
        try {
            optimizer.optimize(new org.apache.commons.math4.optim.MaxEval(100),
                               new org.apache.commons.math4.optim.UnivariateObjectiveFunction(function),
                               GoalType.MINIMIZE,
                               new org.apache.commons.math4.optim.univariate.SearchInterval(3.0, 4.0));
            fail("Expected a NullPointerException due to missing ConvergenceChecker");
        } catch (NullPointerException e) {
            // Expected outcome: since no ConvergenceChecker was set, a NPE should occur.
        }
    }

    @Test
    public void testSpecificConvergenceChecker() {
        // Define a basic univariate function (e.g., Sin function)
        UnivariateFunction function = new Sin();

        // Set up a BrentOptimizer with a custom convergence checker
        BrentOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);
        optimizer.setConvergenceChecker(new ConvergenceChecker<PointValuePair>() { 
            @Override
            public boolean converged(int iteration, PointValuePair previous, PointValuePair current) {
                // Custom convergence logic (e.g., check based on distance)
                double threshold = 1e-5;
                return Math.abs(previous.getValue() - current.getValue()) < threshold;
            }
        });

        try {
            optimizer.optimize(new org.apache.commons.math4.optim.MaxEval(100),
                               new org.apache.commons.math4.optim.UnivariateObjectiveFunction(function),
                               GoalType.MINIMIZE,
                               new org.apache.commons.math4.optim.univariate.SearchInterval(3.0, 4.0));
        } catch (Exception e) {
            fail("Optimization should complete without exceptions, error: " + e.getMessage());
        }
    }
}
