
import org.junit.jupiter.api.Test;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class IOUtilsTest {

    @Test
    public void testSkipWithCipherInputStream() throws Exception {
        // Prepare a byte array input stream with some data
        byte[] data = new byte[2048];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) (i % 256);
        }

        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(data);

        // Create a Cipher for encryption
        Cipher cipher = Cipher.getInstance("AES");
        SecretKey secretKey = generateSecretKey();
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);

        // Wrap the ByteArrayInputStream with a CipherInputStream
        try (CipherInputStream cipherInputStream = new CipherInputStream(byteArrayInputStream, cipher)) {
            long numToSkip = 1024;

            // This is where IOUtils.skip() could potentially fail
            long skippedBytes = IOUtils.skip(cipherInputStream, numToSkip);

            // Validate the number of bytes actually skipped
            // Based on the bug report, we expect the old implementation
            // to fail this, assuming full skip even when it didn't.
            assertEquals(numToSkip, skippedBytes, "IOUtils.skip failed to skip the expected number of bytes.");
        }
    }

    private SecretKey generateSecretKey() throws NoSuchAlgorithmException {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(128); // AES key size in bits
        return keyGen.generateKey();
    }

    // Mock implementation (to be replaced with your actual method)
    public static class IOUtils {
        public static long skip(CipherInputStream input, long numToSkip) throws IOException {
            long remaining = numToSkip;
            while (remaining > 0) {
                long skipped = input.skip(remaining);
                if (skipped == 0) {
                    // Attempt to read a single byte to break potential cycle
                    if (input.read() == -1) {
                        break; // EOF reached
                    }
                    skipped = 1;
                }
                remaining -= skipped;
            }
            return numToSkip - remaining;
        }
    }
}
