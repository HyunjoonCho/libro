
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.verification.VerificationMode;

import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

public class CustomVerificationModeTest {

    public static class FirstInvocationVerificationMode implements VerificationMode {

        @Override
        public void verify(org.mockito.invocation.Invocation i, org.mockito.invocation.MatchableInvocation wc) {
            // Custom logic for verification can go here
        }

        @Override
        public boolean equals(Object obj) {
            // Simulating Issue: equal check fails even if it's the same instance
            return obj instanceof FirstInvocationVerificationMode;
        }
    }

    @Test
    public void testCustomVerificationMode() {
        // Create a mock object
        SomeClass mockObject = mock(SomeClass.class);

        // Invoke method on mock object
        mockObject.someMethod();

        // Create a custom verification mode instance
        VerificationMode customMode1 = new FirstInvocationVerificationMode();
        VerificationMode customMode2 = new FirstInvocationVerificationMode();

        // Use the custom verification mode for verification
        try {
            verify(mockObject, customMode1).someMethod();
            assertTrue("Custom verification mode instances should be considered equal.", customMode1.equals(customMode2));
        } catch (Exception e) {
            e.printStackTrace();
            // Test fails because customMode1 and customMode2 are not considered equal, reproducing the bug
        }
    }

    public static class SomeClass {
        public void someMethod() {
        }
    }
}
