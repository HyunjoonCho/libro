
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex;
import org.apache.commons.math3.optim.SimpleValueChecker;
import org.apache.commons.math3.optim.PointValuePair;

public class MultiDirectionalTest {

    public static void main(String[] args) {
        testMultiDirectionalCorrectStart();
    }

    public static void testMultiDirectionalCorrectStart() {
        // Define a simple quadratic objective function that has a minimum
        MultivariateOptimizer optimizer = new MultivariateOptimizer(new SimpleValueChecker(1e-9, 1e-9)) {
            @Override
            public PointValuePair optimize(OptimizationData... optData) {
                return super.optimize(optData);
            }
        };

        double[] startPoint = new double[]{1.0, 1.0}; // Start point at the known minimum

        // MultiDirectional optimizer setup with simplex
        MultiDirectionalSimplex simplex = new MultiDirectionalSimplex(2);

        try {
            // Try to optimize the function
            PointValuePair result = optimizer.optimize(
                new org.apache.commons.math3.optim.MaxEval(1000),
                simplex,
                new org.apache.commons.math3.optim.InitialGuess(startPoint),
                new org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction(point -> {
                    // Quadratic function with a minimum at (1, 1)
                    return Math.pow(point[0] - 1, 2) + Math.pow(point[1] - 1, 2);
                }),
                org.apache.commons.math3.optim.nonlinear.scalar.GoalType.MINIMIZE
            );

            // Verify that the found point is near the minimum
            double[] foundPoint = result.getPointRef();
            System.out.println("Found point: (" + foundPoint[0] + ", " + foundPoint[1] + ")");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
