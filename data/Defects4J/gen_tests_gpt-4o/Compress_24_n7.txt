
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

public class TarInputStreamTest {

    @Test(expected = IllegalArgumentException.class)
    public void testTarInputStreamLargeUserId() throws IOException {
        // Create a TAR entry header with a large user-id value '62410554'
        // The octal representation of '62410554' is 0x3B6C802, which will be embedded in the header

        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
        
        byte[] header = new byte[512]; // TAR header block size is 512 bytes

        // Writing sample values to header with large uid at a specific position
        // Following is a placeholder for illustration
        // 0-100: File name
        System.arraycopy("testfile.txt".getBytes(), 0, header, 0, "testfile.txt".length());
        // 100-108: File mode (example mode)
        System.arraycopy("0000777".getBytes(), 0, header, 100, 7);
        // 108-116: User ID (in octal)
        System.arraycopy("62410554".getBytes(), 0, header, 108, "62410554".length());
        // 116-124: Group ID
        System.arraycopy("0000000".getBytes(), 0, header, 116, 7);
        // Other header fields would be initialized similarly...

        byteOut.write(header);

        // Fill the rest with zeroes to form a complete TAR file structure even if just a header is evaluated
        byteOut.write(new byte[1024]); // Additional zero blocks to simulate end-of-file in TAR archives

        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteOut.toByteArray());
             TarArchiveInputStream tarInputStream = new TarArchiveInputStream(byteArrayInputStream)) {
            // Attempt to read the next Tar Archive Entry which will trigger the exception
            TarArchiveEntry entry = tarInputStream.getNextTarEntry();
        }
    }
}
