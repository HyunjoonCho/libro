
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;
import org.jsoup.safety.Cleaner;
import org.jsoup.safety.Whitelist;
import org.junit.Assert;
import org.junit.Test;

public class JsoupBugTest {

    // Test fragments that are improperly returning true based on the issue description
    private static String[] htmlFragments = {
            "<html></html>",
            "<head></head>",
            "<body></body>"
    };

    @Test
    public void testEmptyWhitelist() {
        Whitelist emptyWhitelist = new Whitelist();
        for (String htmlFragment : htmlFragments) {
            Assert.assertFalse("Jsoup.isValid should return false for empty whitelist",
                               Jsoup.isValid(htmlFragment, emptyWhitelist));
        }
    }

    @Test
    public void testWhitelistNone() {
        Whitelist noneWhitelist = Whitelist.none();
        for (String htmlFragment : htmlFragments) {
            Assert.assertFalse("Jsoup.isValid should return false for Whitelist.none()",
                               Jsoup.isValid(htmlFragment, noneWhitelist));
        }
    }

    @Test
    public void testTypicalWhitelist() {
        Whitelist whitelist = new Whitelist();
        whitelist.addTags("p"); // Whitelist only allows <p> tags
        for (String htmlFragment : htmlFragments) {
            Assert.assertFalse("Jsoup.isValid should return false for typical whitelist without html, head, body",
                               Jsoup.isValid(htmlFragment, whitelist));
        }
    }

    @Test
    public void testCleanerIsValid() {
        Cleaner cleaner = new Cleaner(Whitelist.none());
        for (String htmlFragment : htmlFragments) {
            Document dirty = Parser.parseBodyFragment(htmlFragment, "");
            Assert.assertFalse("Cleaner.isValid should return false for parsed body fragment",
                               cleaner.isValid(dirty));
        }
    }
}
