
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.std.SqlDateSerializer;
import org.junit.Test;

import java.sql.Date;
import java.text.SimpleDateFormat;

import static org.junit.Assert.assertEquals;

public class SqlDateSerializerTest {

    @Test
    public void testCustomSqlDateFormat() throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configOverride(java.sql.Date.class)
              .setFormat(JsonFormat.Value.forPattern("yyyy-MM-dd"));

        // Creating a SQL Date object for testing
        Date sqlDate = Date.valueOf("2023-10-01");

        // Serialize the date as a string using the configured format
        String jsonOutput = mapper.writeValueAsString(sqlDate);

        // Ensure that the serialized format is as expected
        assertEquals("\"2023-10-01\"", jsonOutput);

        // Additional test for the hacky workaround
        ObjectMapper workaroundMapper = new ObjectMapper();
        workaroundMapper.registerModule(new SimpleModule() {{
            addSerializer(
                    java.sql.Date.class,
                    new SqlDateSerializer().withFormat(false, new SimpleDateFormat("yyyy-MM-dd"))
            );
        }});

        String jsonOutputWorkaround = workaroundMapper.writeValueAsString(sqlDate);
        assertEquals("\"2023-10-01\"", jsonOutputWorkaround);
    }
}
