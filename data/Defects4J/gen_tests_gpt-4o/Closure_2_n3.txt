
import static org.junit.Assert.fail;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import org.mozilla.javascript.ErrorReporter;
import org.mozilla.javascript.EvaluatorException;
import org.mozilla.javascript.tools.shell.Global;
import com.google.javascript.jscomp.CompilationLevel;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.DefaultErrorManager;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;
import org.junit.Test;

public class ClosureCompilerTest {
    
    @Test
    public void testCompileIncorrectInterfaceSyntax() {
        String code = 
              "/**\n" +
              " * @interface\n" +
              " * @extends {unknown_1}\n" +
              " * @extends {unknown_2}\n" +
              " */\n" +
              "function Foo() {}";

        Compiler compiler = new Compiler();

        CompilerOptions options = new CompilerOptions();
        CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);

        SourceFile input = SourceFile.fromCode("test.js", code);
        SourceFile extern = SourceFile.fromCode("externs.js", "");

        DefaultErrorManager errorManager = new DefaultErrorManager();
        compiler.setErrorManager(errorManager);

        compiler.compile(extern, input, options);

        if (errorManager.getErrorCount() > 0 || errorManager.getWarningCount() > 0) {
            fail("Compiler errors/warnings occurred: " + errorManager.getErrors() + "\n" + errorManager.getWarnings());
        }
    }
}
