
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.DependencyOptions;
import com.google.javascript.jscomp.JSSourceFile;
import org.junit.Test;
import static org.junit.Assert.assertTrue;

public class CompilerTest {

    @Test
    public void testDependencySortingWithoutClosurePass() {
        // Create a new compiler instance
        Compiler compiler = new Compiler();

        // Set compiler options
        CompilerOptions options = new CompilerOptions();
        options.setClosurePass(false); // Do not remove goog.require/goog.provide
        DependencyOptions dependencyOptions = new DependencyOptions();
        dependencyOptions.setDependencySorting(true); // Enable dependency sorting
        options.setDependencyOptions(dependencyOptions);

        // Input JavaScript sources with dependencies
        JSSourceFile input1 = JSSourceFile.fromCode("input1.js",
                "goog.provide('foo');\n" +
                "foo.bar = function() {};");

        JSSourceFile input2 = JSSourceFile.fromCode("input2.js",
                "goog.require('foo');\n" +
                "foo.bar();");

        // Result buffer
        JSSourceFile[] inputs = new JSSourceFile[] {input1, input2};
        JSSourceFile[] externs = new JSSourceFile[] {};  // Usually provided, can be empty for this test

        // Compile and test ordering
        compiler.compile(externs, inputs, options);
        String compiledCode = compiler.toSource();

        // Check if dependency sorting was applied (input1 should come before input2)
        int indexInput1 = compiledCode.indexOf("foo.bar = function() {};");
        int indexInput2 = compiledCode.indexOf("foo.bar();");

        // Ensure input1 appears before input2
        assertTrue("Dependency sorting failed, input1 should appear before input2",
                indexInput1 != -1 && indexInput2 != -1 && indexInput1 < indexInput2);
    }
}
