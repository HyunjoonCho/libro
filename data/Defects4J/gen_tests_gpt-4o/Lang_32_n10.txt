public void testThreadLocalMemoryLeakInToStringStyle() throws Exception {
    ToStringStyle style = ToStringStyle.DEFAULT_STYLE;
    // Simulate usage of ToStringStyle in a container environment
    for (int i = 0; i < 1000; i++) {
        new ToStringBuilder(new Object(), style).append("field", "value").toString();
    }

    // Simulate a web application reload by checking if ThreadLocal is cleared
    System.gc(); // Hint to JVM to clean up unused objects
    Field threadLocalsField = Thread.class.getDeclaredField("threadLocals");
    threadLocalsField.setAccessible(true);
    Object threadLocalsMap = threadLocalsField.get(Thread.currentThread());

    // Check if the ToStringStyle class still has any lingering references
    Field tableField = threadLocalsMap.getClass().getDeclaredField("table");
    tableField.setAccessible(true);
    Object[] table = (Object[]) tableField.get(threadLocalsMap);

    boolean isLeaked = false;
    for (Object entry : table) {
        if (entry != null) {
            Object value = ((WeakReference<?>) entry).get();
            if (value != null && value.getClass().getName().contains("ToStringStyle")) {
                isLeaked = true;
                break;
            }
        }
    }

    assertFalse("Detected a memory leak via a lingering ThreadLocal reference to ToStringStyle", isLeaked);
}