script
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.assertTrue;

public class VarArgsTypeCheckTest {
    private ByteArrayOutputStream outContent;
    private PrintStream originalOut;

    @Before
    public void setUpStreams() {
        outContent = new ByteArrayOutputStream();
        originalOut = System.out;
        System.setOut(new PrintStream(outContent));
    }

    @Test
    public void testFooWithVarArgs() {
        String jsCode = 
            "/**\n" +
            " * @param {...string} var_args\n" +
            " */\n" +
            "function foo(var_args) {\n" +
            "  return arguments.length;\n" +
            "}\n" +
            "foo('hello'); // no warning - ok\n" +
            "foo(123); // warning - ok\n" +
            "foo('hello', 123); // no warning! error.\n";

        // Assuming we have a method `typeCheckJsCode` that runs the Closure Compiler with type checking
        String result = typeCheckJsCode(jsCode);

        // Expectation: There should be a type mismatch warning in the output
        assertTrue("Expected type-mismatch warning for foo('hello', 123);", result.contains("type-mismatch"));
    }

    public String typeCheckJsCode(String jsCode) {
        // Simulate type checking with Closure Compiler
        // This is just a placeholder for the actual implementation.
        // This function should invoke the Closure Compiler, perform type checking, and return any warnings.
        // Replace this content with the actual method call and logic to interact with the Closure Compiler

        // For demonstration purposes, we're assuming the output as a string result
        String simulatedCompilerOutput = "WARNING - actual provided type (number) does not match the expected type (string).";
        System.out.print(simulatedCompilerOutput);
        return outContent.toString();
    }
}
