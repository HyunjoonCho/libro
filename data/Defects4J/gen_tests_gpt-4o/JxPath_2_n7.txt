
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathFunction;
import org.apache.commons.jxpath.JXPathFunctionLibrary;
import org.apache.commons.jxpath.NodePointer;
import org.apache.commons.jxpath.Pointer;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.ri.model.NodeSet;
import org.apache.commons.jxpath.ri.model.BasicNodeSet;
import org.apache.commons.jxpath.ri.parser.NodeSetNodeTest;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class JXPathNodeSetTest {

    // Mock function to return a NodeSet
    public static NodeSet observations() {
        // Creating a mock BasicNodeSet with dummy NodePointers
        List<NodePointer> ptrs = Arrays.asList(
                new MockNodePointer("/path1"),
                new MockNodePointer("/path2")
        );
        BasicNodeSet result = new BasicNodeSet();
        for (NodePointer ptr : ptrs) {
            result.add(ptr);
        }
        return result;
    }

    // Mock NodePointer class
    static class MockNodePointer extends NodePointer {
        protected MockNodePointer(String path) {
            super(null);  // In a real scenario, construct using correct context and node
            this.path = path;
        }

        private final String path;

        @Override
        public String asPath() {
            return path;
        }

        // Override other abstract methods as necessary
    }

    @Test
    public void testNodeSetReturnedByFunction() {
        // Create a JXPathContext
        JXPathContext context = JXPathContext.newContext(new Object());

        // Register the observations function manually
        JXPathFunctionLibrary library = new JXPathFunctionLibrary();
        library.addFunction("ems", "observations", new JXPathFunction() {
            public Object invoke(JXPathContext context, Object[] parameters) {
                return observations();
            }
        });
        context.setFunctions(library);

        // Execute selectNodes and check the result
        List<?> nodeList = context.selectNodes("ems:observations()");

        // Expecting the nodeList to directly contain the nodes from NodeSet
        assertEquals(2, nodeList.size());
        for (Object node : nodeList) {
            assertTrue(node instanceof Pointer);
        }
    }
}
