
import org.junit.Test;
import static org.junit.Assert.*;
import com.google.javascript.jscomp.*;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;

import java.util.List;

public class InvalidTypeAnnotationTest {

    @Test
    public void testCrypticErrorMessageOnInvalidTypeAnnotation() {
        // Test JavaScript input
        String jsCode = "/**\n" +
                        " * @type function\n" +
                        " */\n" +
                        "var callback;";

        // Initialize the compiler
        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();

        // Compile the JavaScript code
        SourceFile extern = SourceFile.fromCode("externs.js", "");
        SourceFile input = SourceFile.fromCode("test.js", jsCode);

        // Perform the compilation
        Result result = compiler.compile(extern, input, options);

        // Check if the correct warning error is there
        List<JSError> warnings = compiler.getWarnings();
        assertFalse("Expected a warning to be generated", warnings.isEmpty());
        
        // Assert that the warning message is related to the annotation issue
        String expectedMessagePart = "expected '('";
        boolean annotationErrorFound = warnings.stream().anyMatch(warning -> warning.description.contains(expectedMessagePart));
        
        assertTrue("Expected specific warning message related to annotation, but found: " + warnings, annotationErrorFound);
    }
}
