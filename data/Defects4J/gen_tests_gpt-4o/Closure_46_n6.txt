
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.Node;
import java.util.ArrayList;
import java.util.List;

public class TypeCheckTest {

    public void testClassCastExceptionDuringTypeCheck() {
        // Simulating a small JavaScript code snippet that involves a typedef
        String jsCode = ""
                + "/** @typedef {{key1: string, key2: number}} */\n"
                + "var MyType;\n"
                + "\n"
                + "/** @type {MyType} */\n"
                + "var obj = {key1: 'value', key2: 123};\n";

        Compiler compiler = new Compiler();
        List<SourceFile> externs = new ArrayList<>();
        List<SourceFile> inputs = new ArrayList<>();
        inputs.add(SourceFile.fromCode("test.js", jsCode));

        Result result = compiler.compile(externs, inputs, new TypedScopeCreator().getPassConfig());

        // Verify that there are no compilation errors
        assertEquals(0, compiler.getErrorCount());

        // Simulate the point where ClassCastException would occur
        Node root = compiler.getRoot();
        // Normally the ClassCastException would have occurred when types are being resolved
        // We assume the patch fixes this issue, and the above lines should run without exceptions
    }

    private void assertEquals(int expected, int actual) {
        if (expected != actual) {
            throw new AssertionError("Expected: " + expected + " but got: " + actual);
        }
    }

    public static void main(String[] args) {
        TypeCheckTest test = new TypeCheckTest();
        test.testClassCastExceptionDuringTypeCheck();
        System.out.println("Test completed without ClassCastException.");
    }
}
