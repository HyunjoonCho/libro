
import org.junit.Test;

import static org.junit.Assert.*;

public class AdvancedModeCompilerTest {
    
    // Clone the class structure and method signatures
    public class Foo {
        
        // Original methods
        public int add(int a, int b) {
            return a + b;
        }
        
        public int sub(int a, int b) {
            throw new UnsupportedOperationException("This method should be overridden");
        }
    }

    public class Bar extends Foo {

        // Overridden methods with different signatures (simulating the JS issue)
        
        // This should raise an issue because it doesn't match Foo's add(int, int)
        // if this were being validated in the same way as in JS Closure Compiler
        @Override
        public int add(int one) {
            return one;
        }
        
        // This would match the missing functionality as it doesn't override correctly
        @Override
        public int sub(int one) {
            return one;
        }
    }

    @Test
    public void testBarAdd() {
        Bar bar = new Bar();
        // This simulates the unexpected signature mismatch error
        assertEquals(3, bar.add(3)); // Should show compile issue in static analysis
    }

    @Test
    public void testBarSub() {
        Bar bar = new Bar();
        // Simulate the behavior intended for the method, highlighting design mismatch
        assertEquals(1, bar.sub(1)); // Should show compile issue in static analysis
    }
}
