
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.BrentOptimizer;
import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;
import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;
import org.apache.commons.math3.optim.univariate.ConvergenceChecker;
import org.apache.commons.math3.optim.univariate.MaxEval;
import org.apache.commons.math3.optim.univariate.SearchInterval;
import org.junit.Test;

import static org.junit.Assert.*;

public class BrentOptimizerTest {

    @Test(expected = NullPointerException.class)
    public void testBrentOptimizerWithoutConvergenceChecker() {
        BrentOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);

        UnivariateObjectiveFunction function = new UnivariateObjectiveFunction(x -> (x - 2) * (x - 2));
        SearchInterval interval = new SearchInterval(-10.0, 10.0);

        // This should result in a NullPointerException as there's no default convergence checker.
        UnivariatePointValuePair result = optimizer.optimize(new MaxEval(1000), function, interval);
    }

    @Test
    public void testBrentOptimizerProvidesIncorrectResultWithoutSpecificConvergenceChecker() {
        BrentOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);

        UnivariateObjectiveFunction function = new UnivariateObjectiveFunction(x -> (x - 2) * (x - 2));
        SearchInterval interval = new SearchInterval(-10.0, 10.0);
        ConvergenceChecker<UnivariatePointValuePair> checker = new ConvergenceChecker<UnivariatePointValuePair>() {
            public boolean converged(int iteration, UnivariatePointValuePair previous, UnivariatePointValuePair current) {
                // Custom convergence logic.
                return Math.abs(previous.getValue() - current.getValue()) < 1e-12;
            }
        };

        // Setting a manual convergence checker to illustrate the necessity
        optimizer.setConvergenceChecker(checker);

        UnivariatePointValuePair result = optimizer.optimize(new MaxEval(1000), function, interval);

        // Since we're using a correct convergence checker, the optimization should center around the minimum.
        assertEquals(2.0, result.getPoint(), 1e-10);
    }
}
