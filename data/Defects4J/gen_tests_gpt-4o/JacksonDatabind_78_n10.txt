
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.DefaultBaseTypeLimitingValidator;
import org.junit.Test;

public class JacksonSecurityVulnerabilityTest {

    @Test
    public void testJacksonDeserializationVulnerability() throws Exception {
        // This represents a serialized object with malicious intent (for demonstration purposes)
        String maliciousJson = "[\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", {\n"
                + "  \"_bytecodes\": [\"\"],\n"
                + "  \"_name\": \"a.b\",\n"
                + "  \"_tfactory\": {},\n"
                + "  \"_outputProperties\": {}\n"
                + "}]";

        // ObjectMapper with the default typing enabled (vulnerable configuration)
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping(); // This is the insecure part

        try {
            // Attempt to deserialize the malicious JSON
            Object obj = mapper.readValue(maliciousJson, Object.class);
            System.out.println("Unexpected successful deserialization: " + obj);
        } catch (Exception e) {
            // It's expected to throw an exception when deserialization fails or is attempted maliciously
            System.out.println("Deserialization failed, as expected: " + e.getMessage());
        }

        // Secure the ObjectMapper by using base type validator (since v2.10, Jackson provides this)
        ObjectMapper secureMapper = new ObjectMapper();
        secureMapper.setBaseTypeLimitingValidator(new DefaultBaseTypeLimitingValidator());

        try {
            // Attempt deserialization with secured ObjectMapper should fail safely
            Object obj = secureMapper.readValue(maliciousJson, Object.class);
            System.out.println("Should not print: " + obj);
        } catch (Exception e) {
            System.out.println("Secure deserialization properly prevented: " + e.getMessage());
        }
    }
}
