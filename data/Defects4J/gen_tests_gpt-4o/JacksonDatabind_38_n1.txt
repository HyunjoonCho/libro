
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.SimpleType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class SimpleTypeHandlingTest {

    static class ExampleClass {
        public int id;
        public String name;
    }

    @Test
    public void testSimpleTypeConstruct() throws Exception {
        // Intended possible misuse of directly creating SimpleType without TypeFactory
        SimpleType simpleType = (SimpleType) SimpleType.construct(ExampleClass.class);

        // Expected behavior: Introspection might not find fields/methods properly
        TypeFactory typeFactory = TypeFactory.defaultInstance();
        JavaType correctType = typeFactory.constructType(ExampleClass.class);

        // For demonstration purposes, check if the resolved types differ
        ObjectMapper mapper = new ObjectMapper();

        ExampleClass example = new ExampleClass();
        example.id = 1;
        example.name = "Test";

        // Serializing the example object
        String json = mapper.writeValueAsString(example);

        // Attempting to deserialize using improperly constructed type
        ExampleClass resultUsingSimpleType = (ExampleClass) mapper.readValue(json, simpleType);
        ExampleClass resultUsingCorrectType = (ExampleClass) mapper.readValue(json, correctType);

        // Validate that both methods yield the expected behavior
        assertEquals(example.id, resultUsingCorrectType.id);
        assertEquals(example.name, resultUsingCorrectType.name);

        // Compare to show resolution issue
        assertEquals(resultUsingSimpleType.id, resultUsingCorrectType.id);
        assertEquals(resultUsingSimpleType.name, resultUsingCorrectType.name);
    }
}
