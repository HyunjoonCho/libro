
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.archivers.tar.TarConstants;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class TarArchiveTest {

    @Test
    public void testPaxHeaderWithTrailingSlash() throws IOException {
        // Construct a basic TAR header for a PAX global header entry with trailing slash.
        String headerName = "PaxHeader/";
        byte[] header = createTarHeader(headerName, TarConstants.LF_PAX_GLOBAL_EXTENDED_HEADER, 0);

        try (TarArchiveInputStream tis = new TarArchiveInputStream(new ByteArrayInputStream(header))) {
            TarArchiveEntry entry = tis.getNextTarEntry();
            if (entry != null) {
                // The issue: Directory check is true because of trailing slash.
                // Validate assumption
                assertTrue("Entry should not be treated as a directory when it's a PAX header", entry.isPaxHeader());
                assertFalse("Entry is incorrectly identified as a directory", entry.isDirectory());
            }
        }
    }

    private byte[] createTarHeader(String name, byte linkFlag, int size) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] nameBytes = new byte[100];
        System.arraycopy(name.getBytes(StandardCharsets.US_ASCII), 0, nameBytes, 0, name.length());
        baos.write(nameBytes);
        baos.write(new byte[24]); // Some empty space before the link flag
        baos.write(linkFlag);
        baos.write(new byte[355]); // Rest of the header (after the link flag)
        return baos.toByteArray();
    }
}
