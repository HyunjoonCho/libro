public void testMapDeserializationWithSubtypeAnnotation() throws JsonProcessingException {
    ObjectMapper objectMapper = new ObjectMapper();
    
    String json = "{ \"something\": [{ \"id\": \"123e4567-e89b-12d3-a456-426614174000\", \"property\": \"value\" }] }";
    
    objectMapper.registerModule(new SimpleModule().addAbstractTypeMapping(MyCustomIdInterface.class, Foo.class));
    
    objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

    TestClass result = objectMapper.readValue(json, TestClass.class);
    
    MyHashMap<UUID, Foo> expectedMap = new MyHashMap<>();
    Foo expectedFoo = new Foo(UUID.fromString("123e4567-e89b-12d3-a456-426614174000"), "value");
    expectedMap.put(expectedFoo.getId(), expectedFoo);
    
    assertEquals(expectedMap, result.getSomething());
}

public class TestClass {
    @JsonDeserialize(as = MyHashMap.class)
    private Map<UUID, Foo> something;

    public Map<UUID, Foo> getSomething() {
        return something;
    }

    public void setSomething(Map<UUID, Foo> something) {
        this.something = something;
    }
}

interface MyCustomIdInterface {
    UUID getId();
}

class Foo implements MyCustomIdInterface {
    private UUID id;
    private String property;
    
    // Constructors, getters, setters omitted for brevity
    
    public Foo(UUID id, String property) {
        this.id = id;
        this.property = property;
    }
    
    @Override
    public UUID getId() {
        return id;
    }
}

class MyHashMap<K, V> extends HashMap<K, V> {
    // Custom logic using generics to enforce type constraints
}