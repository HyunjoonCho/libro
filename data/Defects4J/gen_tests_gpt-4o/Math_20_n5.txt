
import org.apache.commons.math3.optimization.GoalType;
import org.apache.commons.math3.optimization.SimpleBounds;
import org.apache.commons.math3.optimization.direct.CMAESOptimizer;
import org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter;
import org.junit.Test;
import static org.junit.Assert.*;

public class CMAESOptimizerTest {

    @Test
    public void testCMAESOptimizerRespectsBounds() {
        // Objective function: a simple quadratic function
        MultivariateFunctionMappingAdapter function = new MultivariateFunctionMappingAdapter(
                point -> Math.pow(point[0], 2) + Math.pow(point[1], 2),
                new double[]{-5, -5},
                new double[]{5, 5}
        );

        // Set the bounds
        double[] lowerBounds = {0.0, 0.0}; // Enforcing bounds > 0
        double[] upperBounds = {1.0, 1.0}; // Enforcing bounds < 1

        // Create the optimizer
        CMAESOptimizer optimizer = new CMAESOptimizer();

        // Optimize
        CMAESOptimizer.Result result = optimizer.optimize(1000,
                function,
                GoalType.MINIMIZE,
                SimpleBounds.unbounded(2),
                new org.apache.commons.math3.optimization.initializationInitialGuess(new double[] {0.5, 0.5}),
                new SimpleBounds(lowerBounds, upperBounds));

        // Check that the result respects the specified bounds
        double[] optimalPoint = result.getPoint();
        assertTrue("Solution should respect lower bounds.", optimalPoint[0] >= lowerBounds[0] && optimalPoint[1] >= lowerBounds[1]);
        assertTrue("Solution should respect upper bounds.", optimalPoint[0] <= upperBounds[0] && optimalPoint[1] <= upperBounds[1]);
    }
}
