
import org.joda.time.DateTime;
import org.joda.time.MutableDateTime;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormatterBuilder;
import org.junit.Test;
import static org.junit.Assert.*;

public class DateTimeFormatterTest {

    @Test
    public void testParseIntoWithoutYear() {
        // Create a formatter without a year in the format
        DateTimeFormatter formatter = new DateTimeFormatterBuilder().appendMonthOfYear(2).appendDayOfMonth(2).toFormatter();
        
        // Start with a date in a non-leap year
        MutableDateTime mdt = new MutableDateTime(2011, 1, 1, 0, 0, 0, 0);

        // Parse "February 28" into mdt which initially starts in 2011
        formatter.parseInto(mdt, "0228", 0);
        
        // Expect the date to remain in 2011
        assertEquals(2011, mdt.getYear());
        assertEquals(2, mdt.getMonthOfYear());
        assertEquals(28, mdt.getDayOfMonth());
        
        // Parse "February 29" into mdt which should yield an error or remain unchanged in a non-leap year
        int errorPos = formatter.parseInto(mdt, "0229", 0);
        
        // Check if the date has not changed (should be invalid to parse Feb 29 in 2011)
        assertEquals(2011, mdt.getYear());
        assertEquals(2, mdt.getMonthOfYear());
        assertEquals(28, mdt.getDayOfMonth());
        
        // The error position should indicate a failure to parse as Feb 29 can't exist in 2011
        assertTrue(errorPos < 0);
    }
}
