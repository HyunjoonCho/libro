
import org.junit.Test;
import com.google.javascript.jscomp.*;

import static org.junit.Assert.*;

public class FunctionCastingTest {
    
    @Test
    public void testFunctionCastingProducesBadCode() {
        // JavaScript code snippet with casting function
        String sourceCodeWithCast = "console.log( /** @type {function(!string):!string} */ " +
                                    "((new window.ActiveXObject( 'ShockwaveFlash.ShockwaveFlash' ))['GetVariable'])" +
                                    "( '$version' ) );";

        // JavaScript code snippet without casting function
        String sourceCodeWithoutCast = "console.log( /** @type {!string} */ " +
                                       "((new window.ActiveXObject( 'ShockwaveFlash.ShockwaveFlash' ))['GetVariable']" +
                                       "( '$version' )) );";

        // Expected output format without (0, ...) wrapping
        String expectedOutputWithoutCast = "'use strict';console.log((new window.ActiveXObject(\"ShockwaveFlash.ShockwaveFlash\")).GetVariable(\"$version\"));\n";

        // Compile with Advanced Optimizations
        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
        options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.WARNING);
        
        // Compile code with casting
        Result resultWithCast = compiler.compile(SourceFile.fromCode("externs", "externs"), SourceFile.fromCode("input", sourceCodeWithCast), options);
        String compiledCodeWithCast = compiler.toSource();

        // Compile code without casting
        compiler = new Compiler();  // Reset compiler for a clean state
        Result resultWithoutCast = compiler.compile(SourceFile.fromCode("externs", "externs"), SourceFile.fromCode("input", sourceCodeWithoutCast), options);
        String compiledCodeWithoutCast = compiler.toSource();

        // Check if the compiled output without casting matches expected output
        assertTrue("Compiled code without casting should match expected output", compiledCodeWithoutCast.equals(expectedOutputWithoutCast));

        // Assert that the casted function introduces (0, ...) wrapping 
        assertFalse("Compiled code with casting should not match without casting code", compiledCodeWithCast.equals(compiledCodeWithoutCast));
        assertTrue("Casted function introduces (0, ...) wrapping", compiledCodeWithCast.contains("(0,(new window.ActiveXObject"));

        // Ensure there are no compile errors
        assertTrue("Compilation with casting should result in zero errors", resultWithCast.success);
        assertTrue("Compilation without casting should result in zero errors", resultWithoutCast.success);
    }
}
