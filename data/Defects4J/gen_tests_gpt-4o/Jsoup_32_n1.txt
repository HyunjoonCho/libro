
import org.junit.Test;
import java.util.Set;
import static org.junit.Assert.*;
import java.util.HashSet;

public class ElementCloneTest {

    private static class Element implements Cloneable {
        private Set<String> classNames = new HashSet<>();

        public void addClassName(String className) {
            classNames.add(className);
        }

        public Set<String> getClassNames() {
            return classNames;
        }

        @Override
        protected Object clone() throws CloneNotSupportedException {
            Element cloned = (Element) super.clone();
            // Normally, you'd want to deep copy the set here to fix the issue
            // But since the bug exists, we're showing the failure due to shared set
            return cloned;
        }
    }

    @Test
    public void testElementCloneSharesClassNamesSet() throws CloneNotSupportedException {
        Element originalElement = new Element();
        originalElement.addClassName("original");

        // Clone the original element
        Element clonedElement = (Element) originalElement.clone();

        // Modify clone
        clonedElement.addClassName("clone");

        // Check if original element is affected by modifications to the clone
        assertTrue("The classNames set should have been cloned, but changes to the clone affected the original.",
                   !originalElement.getClassNames().equals(clonedElement.getClassNames()));

        // This statement should show they both share same set and have both class names
        assertEquals("original, clone", originalElement.getClassNames());
    }
}
