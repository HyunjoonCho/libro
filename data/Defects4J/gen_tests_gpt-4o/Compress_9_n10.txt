
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.archivers.ArchiveStreamFactory;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

import static org.junit.Assert.assertTrue;

public class TarArchiveOutputStreamTest {

    @Test
    public void testGetBytesWrittenReturnsInvalidValue() throws Exception {
        // Use ByteArrayOutputStream instead of FileOutputStream to avoid file I/O in test
        ByteArrayOutputStream myOutputStream = new ByteArrayOutputStream();

        ArchiveOutputStream sTarOut = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.TAR, myOutputStream);

        byte[] fileContent = new byte[10000]; // Simulating a file of size 10000 bytes
        ByteArrayInputStream sInput = new ByteArrayInputStream(fileContent);

        TarArchiveEntry sEntry = new TarArchiveEntry("mockfile.txt");
        sEntry.setSize(fileContent.length);
        sTarOut.putArchiveEntry(sEntry);

        byte[] cpRead = new byte[8192];

        int iRead;
        while ((iRead = sInput.read(cpRead)) > 0) {
            sTarOut.write(cpRead, 0, iRead);
        }

        // Check the bytes written before closing
        long bytesBeforeClose = ((TarArchiveOutputStream) sTarOut).getBytesWritten();
        assertTrue("Bytes written should not be zero before closing", bytesBeforeClose > 0);

        sInput.close();
        sTarOut.closeArchiveEntry();
        sTarOut.close();

        // Check the bytes written after closing
        long bytesAfterClose = ((TarArchiveOutputStream) sTarOut).getBytesWritten();
        assertTrue("Bytes written should not be zero after closing", bytesAfterClose > 0);
        assertTrue("Bytes written should include header sizes", bytesAfterClose > fileContent.length);
    }
}
