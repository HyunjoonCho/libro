script
/**
 * This test case demonstrates the incorrect 'this' type checking.
 * It will show how a warning is not emitted when it should be.
 */
// Define the first constructor
/** @constructor */
function F() {}

// Define a method on F's prototype
F.prototype.bar = function() { this.baz(); };

// Define another method on F's prototype
F.prototype.baz = function() { console.log("F's baz called"); };

// Define the second constructor
/** @constructor */
function G() {}

// Assign F's bar method to G's prototype, without a proper this context
G.prototype.bar = F.prototype.bar;

// Create instances of both constructors
var fInstance = new F();
var gInstance = new G();

// This should pass as F has a baz method
try {
    fInstance.bar(); // Calls fInstance.baz()
} catch (e) {
    console.error("Error calling fInstance.bar(): ", e);
}

// This will fail silently or incorrectly, as G does not have a baz method
try {
    gInstance.bar(); // Expected to throw an error or behave unexpectedly
} catch (e) {
    console.error("Error calling gInstance.bar(): ", e);
}
