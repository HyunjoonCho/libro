
import com.google.javascript.jscomp.CommandLineRunner;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JSModule;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;
import org.junit.Test;

import static org.junit.Assert.assertTrue;

import java.util.List;

public class ClosureCompilerTest {

    @Test
    public void testAdvancedOptimizationsBug() throws Exception {
        String inputJs = "window['anchor'] = function (obj, modifiesProp) {" +
                " return (function (saved) {" +
                " return modifiesProp(obj) + saved;" +
                " })(obj['prop']);" +
                "};";

        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        options.setCompilationLevel(CompilerOptions.CompilationLevel.ADVANCED_OPTIMIZATIONS);

        // Need to pass an externs file for the window object if necessary
        SourceFile input = SourceFile.fromCode("input.js", inputJs);
        SourceFile extern = SourceFile.fromCode("externs.js", "var window;");

        List<SourceFile> externs = CommandLineRunner.getDefaultExterns();
        externs.add(extern);

        Result result = compiler.compile(externs, List.of(input), options);

        // Check if compiled code contains the expected pattern
        String compiledCode = compiler.toSource();
        System.out.println(compiledCode);

        // Verify that the compiled code does not reorder operations, preserving side-effects
        assertTrue("The compiled output should maintain the correct order of operations.",
                compiledCode.contains("var HOLD") && compiledCode.contains("b(a)+HOLD"));
    }

   // Include this main to simply run the test for displaying or standalone execution
    public static void main(String[] args) throws Exception {
        ClosureCompilerTest test = new ClosureCompilerTest();
        test.testAdvancedOptimizationsBug();
    }
}
