
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;
import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

// Custom type resolver
class CustomTypeIdResolver extends TypeIdResolverBase {
    @Override
    public String idFromValue(Object value) {
        return value.getClass().getSimpleName();
    }

    @Override
    public String idFromValueAndType(Object value, Class<?> suggestedType) {
        return value.getClass().getSimpleName();
    }

    @Override
    public JavaType typeFromId(DatabindContext context, String id) {
        if (id.equals("ConcreteBase")) {
            return context.constructType(ConcreteBase.class);
        }
        if (id.equals("SubType")) {
            return context.constructType(SubType.class);
        }
        return null;
    }

    @Override
    public Id getMechanism() {
        return Id.CUSTOM;
    }
}

// Base class
@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, property = "type", visible = true)
@JsonTypeIdResolver(CustomTypeIdResolver.class)
abstract class BaseType {
    public String type;
}

// Concrete implementation of BaseType
class ConcreteBase extends BaseType {
    public String baseProperty;

    public ConcreteBase() {}
    public ConcreteBase(String baseProperty) { this.baseProperty = baseProperty; }
}

// Subclass of ConcreteBase
class SubType extends ConcreteBase {
    public String subProperty;

    public SubType() {}
    public SubType(String baseProperty, String subProperty) {
        super(baseProperty);
        this.subProperty = subProperty;
    }
}

public class TypeIdMappingTest {

    @Test
    public void testTypeIdMappingWithConcreteBase() throws Exception {
        ObjectMapper mapper = new ObjectMapper();

        // Serialize SubType
        SubType subType = new SubType("baseValue", "subValue");
        String json = mapper.writeValueAsString(subType);

        // Deserialize as BaseType
        BaseType deserializedInstance = mapper.readValue(json, BaseType.class);

        // Assert the type and properties
        assertEquals(SubType.class, deserializedInstance.getClass());
        assertEquals("baseValue", ((SubType) deserializedInstance).baseProperty);
        assertEquals("subValue", ((SubType) deserializedInstance).subProperty);

        // Check if the issue with extraneous type id mapping occurs
        assertEquals("SubType", deserializedInstance.type);
    }
}
