
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer.Optimum;
import org.apache.commons.math3.fitting.leastsquares.LevenbergMarquardtOptimizer;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresBuilder;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.SimpleValueChecker;
import org.apache.commons.math3.util.FastMath;
import org.junit.Test;
import static org.junit.Assert.*;

public class LevenbergMarquardtOptimizerTest {

    @Test
    public void testGetIterations() {
        // setup
        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer()
                .withMaxIterations(100)
                .withMaxEvaluations(100)
                .withConvergenceChecker(new SimpleValueChecker(1e-10, 1e-10));

        // Constructing the problem
        Optimum optimum = optimizer.optimize(new LeastSquaresBuilder()
                .maxEvaluations(100)
                .maxIterations(100)
                .target(new double[] {1})
                .weight(new double[] {1})
                .start(new double[] {3})
                .model(new ModelFunction(
                        point -> new double[] {FastMath.pow(point[0], 4)}), 
                    new ModelFunctionJacobian(
                        point -> new double[][] { { 0.25 * FastMath.pow(point[0], 3) } })));

        // Verify the evaluations are greater than 1
        assertTrue(optimum.getEvaluations() > 1);

        // Verify the iterations are greater than 1, which currently fails due to the bug
        assertTrue("Iterations should be greater than 1", optimum.getIterations() > 1);
    }
}
