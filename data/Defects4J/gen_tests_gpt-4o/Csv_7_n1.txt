
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.junit.Test;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

import static org.junit.Assert.*;

public class CSVHeaderTest {

    @Test
    public void testDuplicateHeaderNames() throws IOException {
        // Define CSV content with duplicate header names.
        String csvContent = "Col1,Col2,Col2,Col3,Col4\n"
                          + "1,2,3,4,5\n"
                          + "4,5,6,7,8\n";

        // Create a Reader from the CSV string.
        Reader in = new StringReader(csvContent);

        // Set up CSVFormat with header.
        CSVFormat myFormat = CSVFormat.RFC4180
            .withDelimiter(',')
            .withQuote('"')
            .withQuotePolicy(CSVFormat.Quote.MINIMAL)
            .withIgnoreSurroundingSpaces(true)
            .withHeader()
            .withSkipHeaderRecord();

        // Parse the CSV content.
        CSVParser parser = new CSVParser(in, myFormat);

        // Retrieve the header map.
        Map<String, Integer> headerMap = parser.getHeaderMap();

        // Assert that the second "Col2" is not ignored, expecting a size of 5, not 4.
        // In this case, headerMap should not just have three keys {"Col1", "Col2", "Col3", "Col4"}.
        // But due to the bug it might just have three, which this test is checking for.
        assertNotNull(headerMap);
        assertEquals("Header map should handle duplicate entries properly.", 4, headerMap.size());

        // Optionally, you can go through records if needed
        for (CSVRecord record : parser) {
            // You can access record using header names
            assertEquals("2", record.get("Col2"));
        }
    }
}
