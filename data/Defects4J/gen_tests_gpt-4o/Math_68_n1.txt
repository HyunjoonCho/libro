public void testLevenbergMarquardtOptimizerIgnoresConvergenceChecker() {
    // Mock or create a custom VectorialConvergenceChecker
    VectorialConvergenceChecker convergenceChecker = new VectorialConvergenceChecker() {
        @Override
        public boolean converged(int iteration, VectorialPointValuePair previous, VectorialPointValuePair current) {
            // Custom convergence logic, which should ideally always return true for testing,
            // signifying forced early convergence
            return true;
        }
    };

    // Set up dummy data for the optimizer
    MultivariateVectorialFunction function = new MultivariateVectorialFunction() {
        @Override
        public double[] value(double[] variables) throws IllegalArgumentException {
            return new double[]{1.0};  // Simple constant function
        }
    };

    double[] target = new double[]{1.0};
    double[] weights = new double[]{1.0};
    double[] startPoint = new double[]{0.0};

    // Create the optimizer with the custom convergence checker
    LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(1000, 1e-10, 1e-10, 1e-10, convergenceChecker);

    // Optimize the function and check if the convergenceChecker was respected (by not iterating further)
    VectorialPointValuePair result = optimizer.optimize(function, target, weights, startPoint);

    // Assert to ensure that the optimizer respects convergenceChecker and stops immediately
    // Here we ensure that the number of iterations is minimal as convergenceChecker always returns true
    assertTrue("Optimizer should respect custom convergence checker.", optimizer.getEvaluations() <= 1);
}