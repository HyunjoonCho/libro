
import org.apache.commons.math3.optim.SimplePointChecker;
import org.apache.commons.math3.analysis.MultivariateFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectional;

import org.junit.Test;
import static org.junit.Assert.assertArrayEquals;

public class MultiDirectionalOptimizerTest {

    @Test(timeout = 1000) // Prevents test from hanging forever
    public void testMultiDirectionalCorrectStart() {
        // Define the objective function: f(x) = (x[0] - 1)^2
        MultivariateFunction objectiveFunction = new MultivariateFunction() {
            @Override
            public double value(double[] point) {
                double x = point[0];
                return (x - 1) * (x - 1);
            }
        };

        // Known correct solution to the objective function
        double[] correctSolution = new double[] { 1.0 };

        // Create the optimization instance with the correct starting point
        MultiDirectional optimizer = new MultiDirectional(
                new SimplePointChecker<>(1e-6, 1e-6),
                2.0, 0.5); // Default expansion and contraction coefficients

        // Define the simplex around the starting point
        MultiDirectionalSimplex simplex = new MultiDirectionalSimplex(correctSolution.length);

        // Perform the optimization
        org.apache.commons.math3.optim.PointValuePair result = optimizer.optimize(
                new org.apache.commons.math3.optim.MaxEval(100),
                org.apache.commons.math3.optim.PointValuePair.valuePointValuePair(objectiveFunction, new double[]{0.0}),
                GoalType.MINIMIZE,
                simplex);

        // Assert that the optimizer returns the correct solution
        assertArrayEquals(correctSolution, result.getPoint(), 1e-6);
    }
}
