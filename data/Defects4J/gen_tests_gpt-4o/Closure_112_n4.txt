
import static com.google.javascript.jscomp.testing.JSCompCorrespondences.diagnosticsOfType;
import static com.google.javascript.rhino.testing.BaseJSTypeTestCase.lines;

import com.google.javascript.jscomp.*;  // Import the Closure Compiler's class
import org.junit.Assert;
import org.junit.Test;

public class TemplateTypeInferenceTest {

    @Test
    public void testTemplateTypeInference() {
        String jsCode = lines(
            "/**",
            " * @constructor",
            " * @template CLASS",
            " */",
            "var Class = function() {};",
            "/**",
            " * @param {function(CLASS):CLASS} a",
            " * @template T",
            " */",
            "Class.prototype.foo = function(a) {",
            "   return 'string';",
            "};",
            "/** @param {number} a",
            "  * @return {string} */",
            "var a = function(a) { return ''; };",
            "new Class().foo(a);"
        );

        // Set up the compiler options
        CompilerOptions options = new CompilerOptions();
        options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.ERROR);
        
        // Create a new instance of the compiler
        Compiler compiler = new Compiler();

        // Compile the JavaScript code
        Result result = compiler.compile(SourceFile.fromCode("externs.js", ""), 
                                         SourceFile.fromCode("input.js", jsCode), 
                                         options);

        // Check if the error related to template type inference occurs
        Assert.assertTrue("Expected a type inference error", 
            result.errors.stream().anyMatch(diagnosticsOfType(DiagnosticGroups.CHECK_TYPES)));
    }
}
