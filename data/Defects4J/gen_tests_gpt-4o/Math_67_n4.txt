
import org.apache.commons.math3.analysis.function.Sin;
import org.apache.commons.math3.optimization.GoalType;
import org.apache.commons.math3.optimization.univariate.BracketFinder;
import org.apache.commons.math3.optimization.univariate.MultiStartUnivariateRealOptimizer;
import org.apache.commons.math3.optimization.univariate.SearchInterval;
import org.apache.commons.math3.optimization.univariate.SimpleUnivariateValueChecker;
import org.apache.commons.math3.optimization.univariate.UnivariateObjectiveFunction;
import org.apache.commons.math3.optimization.univariate.UnivariateRealOptimizer;
import org.apache.commons.math3.optimization.univariate.UnivariateRealPointValuePair;

import org.junit.Test;

import java.util.Random;

import static org.junit.Assert.assertEquals;

public class MultiStartOptimizerTest {

    @Test
    public void testGetResultReturnsBestResult() {
        // Assume some implementation of UnivariateRealOptimizer
        UnivariateRealOptimizer underlyingOptimizer = new UnivariateRealOptimizer() {
            // Implementation details would be filled in here
            public UnivariateRealPointValuePair optimize(UnivariateObjectiveFunction f, GoalType goalType, SearchInterval searchInterval) {
                // Fake optimizer that returns a random value
                Random rand = new Random();
                double point = searchInterval.getMin() + rand.nextDouble() * (searchInterval.getMax() - searchInterval.getMin());
                return new UnivariateRealPointValuePair(point, f.value(point));
            }

            public void setMaxEvaluations(int maxEvaluations) { }
            public int getMaxEvaluations() { return 0; }
            public void setConvergenceChecker(SimpleUnivariateValueChecker checker) { }
            public SimpleUnivariateValueChecker getConvergenceChecker() { return null; }
            public int getEvaluations() { return 0; }
        };

        MultiStartUnivariateRealOptimizer optimizer = new MultiStartUnivariateRealOptimizer(underlyingOptimizer, 10, new Random());

        // Define a test function (sine in this case)
        UnivariateObjectiveFunction function = new UnivariateObjectiveFunction(new Sin());

        // Optimize
        optimizer.optimize(function, GoalType.MAXIMIZE, new SearchInterval(3, 4, 3.5));

        // The expected best result is the one with the smallest function value,
        // but getResult should return what the assumed fix suggests, which would be the first result.
        double expectedBestResult = optimizer.getOptima()[0].getPoint();

        // Check if getResult actually returns the best result
        assertEquals(expectedBestResult, optimizer.getResult(), 1e-6);
    }
}
