
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class PolymorphicDeserializationTest {

    // Base class
    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type", defaultImpl = BaseType.class)
    @JsonSubTypes({
            @JsonSubTypes.Type(value = SubType.class, name = "subtype")
    })
    public static class BaseType {
        public String baseProperty;

        public String getBaseProperty() {
            return baseProperty;
        }
    }

    // Subclass with additional property
    public static class SubType extends BaseType {
        public String subProperty;

        public String getSubProperty() {
            return subProperty;
        }
    }

    @Test
    public void testPolymorphicDeserialization() throws Exception {
        ObjectMapper mapper = new ObjectMapper();

        // JSON String representing the subtype
        String jsonInput = "{ \"type\": \"subtype\", \"baseProperty\": \"baseValue\", \"subProperty\": \"subValue\" }";

        BaseType result = mapper.readValue(jsonInput, BaseType.class);

        // The failure scenario: Properties from superclass should not be lost
        assertEquals("baseValue", result.getBaseProperty());

        // Cast to SubType to check if subProperty is present (this should work due to type resolution)
        if (result instanceof SubType) {
            SubType subResult = (SubType) result;
            assertEquals("subValue", subResult.getSubProperty());
        } else {
            throw new AssertionError("Deserialized result is not of type SubType");
        }
    }
}
