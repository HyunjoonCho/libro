
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

// Define the base class with polymorphic type handling
@JsonTypeInfo(
    use = JsonTypeInfo.Id.NAME,
    include = JsonTypeInfo.As.PROPERTY,
    property = "type",
    defaultImpl = BaseTypeImpl.class)
@JsonSubTypes({
    @JsonSubTypes.Type(value = SubType.class, name = "subtype")
})
abstract class BaseType {
    public String baseProperty;

    public String getBaseProperty() {
        return baseProperty;
    }

    public void setBaseProperty(String baseProperty) {
        this.baseProperty = baseProperty;
    }
}

// Define a subtype
class SubType extends BaseType {
    public String subProperty;

    public String getSubProperty() {
        return subProperty;
    }

    public void setSubProperty(String subProperty) {
        this.subProperty = subProperty;
    }
}

// Default implementation for handling unknown subtypes
class BaseTypeImpl extends BaseType {
}

// Test demonstrating the problem with defaultImpl and super-type property resolution
public class PolymorphicTypeTest {

    @Test
    public void testPolymorphicTypeDeserialization() throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        String json = "{\"type\":\"subtype\", \"baseProperty\":\"base value\", \"subProperty\":\"sub value\"}";

        BaseType deserialized = objectMapper.readValue(json, BaseType.class);

        // Verify that properties from the super-type are correctly resolved
        assertEquals("base value", deserialized.getBaseProperty());

        // Verify that properties from the subtype are correctly resolved
        assertEquals("sub value", ((SubType) deserialized).getSubProperty());
    }
}
