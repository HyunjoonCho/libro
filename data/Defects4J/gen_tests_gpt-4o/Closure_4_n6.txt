
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.Result;
import org.junit.Test;

import static org.junit.Assert.assertFalse;

public class CompilerTest {
    
    @Test
    public void testInfiniteRecursionInSubtypeCheck() {
        // Preparing the JavaScript code that will trigger the issue
        String code =
                "/**\n" +
                " * @interface\n" +
                " */\n" +
                "var OtherType = function() {}\n" +
                "\n" +
                "/**\n" +
                " * @implements {MyType}\n" +
                " * @constructor\n" +
                " */\n" +
                "var MyType = function() {}\n" +
                "\n" +
                "/**\n" +
                " * @type {MyType}\n" +
                " */\n" +
                "var x = /** @type {!OtherType} */ (new Object());";
        
        // Set up the compiler and options
        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        
        // Add warning to check types
        options.setWarningLevel(com.google.javascript.jscomp.DiagnosticGroups.CHECK_TYPES, com.google.javascript.jscomp.CheckLevel.WARNING);
        
        // Compile the JavaScript code
        Result result = compiler.compile(
                JSSourceFile.fromCode("externs.js", ""), // We're not using any externs in this test
                JSSourceFile.fromCode("t.js", code),
                options
        );
        
        // Assert that there are no errors or warnings
        assertFalse("Compilation resulted in errors or warnings", result.success);
    }
}
