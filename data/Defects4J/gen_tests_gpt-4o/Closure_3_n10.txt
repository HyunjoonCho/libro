
import static org.junit.Assert.*;

import java.util.regex.Pattern;

import com.google.javascript.jscomp.*;
import org.junit.Test;

public class ClosureCompilerTest {
    
    @Test
    public void testOptimizationFailsWithVariableInCatchClause() {
        // The input JavaScript code
        String originalJs = 
              "function getStack() {\n"
            + "  var getErrorObject = function() {\n"
            + "    try {\n"
            + "      throw Error(\"\");\n"
            + "    } catch(err) {\n"
            + "      return err;\n"
            + "    }\n"
            + "  };\n"
            + "  return getErrorObject().stack;\n"
            + "}\n"
            + "window['getStackTrace'] = getStack;";
        
        // Expected JavaScript code after optimization
        // This is expected to be broken due to the bug: 
        // The 'a' variable will be incorrectly hoisted out of the try-catch block as per the description.
        String expectedJsPattern = 
              "function getStack\\(\\) \\{\n"
            + "\\s*try \\{\n"
            + "\\s*throw Error\\(\"\"\\);\\n"
            + "\\s*\\} catch\\(a\\) \\{\\n"
            + "\\s*\\} \\n"
            + "\\s*return a.stack\\n"
            + "\\} \\n"
            + "window.getStackTrace = getStack;";
        
        // Set up the closure compiler
        CompilerOptions options = new CompilerOptions();
        CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);

        Compiler compiler = new Compiler();
        SourceFile extern = SourceFile.fromCode("externs.js", "");
        SourceFile input = SourceFile.fromCode("input.js", originalJs);

        // Perform the compilation
        Result result = compiler.compile(extern, input, options);

        // The actual optimized JS
        String compiledJs = compiler.toSource();
        
        // Check if the output matches the expected broken pattern due to the problem described.
        assertTrue("Compiled JS should incorrectly reference 'a' out of scope", 
                   Pattern.compile(expectedJsPattern).matcher(compiledJs).find());
    }
}
