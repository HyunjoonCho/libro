
import org.apache.commons.math3.linear.OpenMapRealVector;
import org.apache.commons.math3.linear.RealVector;
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class OpenMapRealVectorTest {

    @Test
    public void testEbeMultiplyWithNaNAndInfinity() {
        double[] data1 = {1.0, Double.NaN, 3.0, 4.0};
        double[] data2 = {Double.POSITIVE_INFINITY, 2.0, 0.0, Double.NEGATIVE_INFINITY};
        
        RealVector v1 = new OpenMapRealVector(data1);
        RealVector v2 = new OpenMapRealVector(data2);
        
        RealVector result = ((OpenMapRealVector) v1).ebeMultiply(v2);
        
        // Manual calculation considering NaN and infinities
        // 1.0 * Infinity = Infinity
        // NaN * 2.0 = NaN
        // 3.0 * 0.0 = 0.0 (should be 0.0)
        // 4.0 * (-Infinity) = -Infinity
        assertEquals(Double.POSITIVE_INFINITY, result.getEntry(0), 0.0);
        assertEquals(Double.NaN, result.getEntry(1), 0.0);
        assertEquals(0.0, result.getEntry(2), 0.0);
        assertEquals(Double.NEGATIVE_INFINITY, result.getEntry(3), 0.0);
    }

    @Test
    public void testEbeDivideWithNaNAndInfinity() {
        double[] data1 = {Double.NaN, 8.0, 0.0, Double.NEGATIVE_INFINITY};
        double[] data2 = {2.0, Double.POSITIVE_INFINITY, 3.0, 4.0};
        
        RealVector v1 = new OpenMapRealVector(data1);
        RealVector v2 = new OpenMapRealVector(data2);
        
        RealVector result = ((OpenMapRealVector) v1).ebeDivide(v2);
        
        // Manual calculation considering NaN and infinities
        // NaN / 2.0 = NaN
        // 8.0 / Infinity = 0.0
        // 0.0 / 3.0 = 0.0
        // (-Infinity) / 4.0 = -Infinity
        assertEquals(Double.NaN, result.getEntry(0), 0.0);
        assertEquals(0.0, result.getEntry(1), 0.0);
        assertEquals(0.0, result.getEntry(2), 0.0);
        assertEquals(Double.NEGATIVE_INFINITY, result.getEntry(3), 0.0);
    }
}
