
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem;
import org.apache.commons.math3.fitting.leastsquares.LevenbergMarquardtOptimizer;
import org.apache.commons.math3.fitting.leastsquares.EvaluationRmsChecker;
import org.apache.commons.math3.linear.RealVector;
import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresFactory;
import org.apache.commons.math3.optim.Optimum;
import org.junit.Test;
import static org.junit.Assert.*;

public class LevenbergMarquardtTest {

    @Test
    public void testInconsistentResultInLevenbergMarquardt() {
        // Define the observed points
        double[][] observedPoints = {
            {0, 1.0},
            {1, 4.0},
            {2, 9.0}, 
            {3, 16.0}, 
            {4, 25.0}
        };

        // Initial guess
        double[] initialGuess = {0.0, 0.0, 0.0};

        // Create the optimization problem
        LeastSquaresProblem problem = LeastSquaresFactory.create(
            points -> {
                double a = points.getEntry(0);
                double b = points.getEntry(1);
                double c = points.getEntry(2);
                double[] result = new double[observedPoints.length];
                for (int i = 0; i < observedPoints.length; i++) {
                    double x = observedPoints[i][0];
                    double target = observedPoints[i][1];
                    result[i] = a * x * x + b * x + c - target;
                }
                return new ArrayRealVector(result);
            },
            new ArrayRealVector(observedPoints.length),
            new ArrayRealVector(initialGuess),
            new EvaluationRmsChecker(1e-10, 1e-10)
        );

        // Optimize using LevenbergMarquardtOptimizer
        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();
        Optimum optimum = optimizer.optimize(problem);

        // Extract results
        RealVector optimalPoint = optimum.getPoint();

        // Perform assertions to check for consistency
        RealVector residuals = optimum.getResiduals();
        double cost = optimum.getRMS();

        // Check that the calculated optimalPoint is consistent with residuals and cost
        double[] expectedResults = new double[observedPoints.length];
        for (int i = 0; i < observedPoints.length; i++) {
            double x = observedPoints[i][0];
            double target = observedPoints[i][1];
            expectedResults[i] = optimalPoint.getEntry(0) * x * x + optimalPoint.getEntry(1) * x + optimalPoint.getEntry(2) - target;
        }
        
        assertArrayEquals(expectedResults, residuals.toArray(), 1e-8);
        assertEquals(cost, optimum.getRMS(), 1e-8);
    }
}
