
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.util.StdDateFormat;
import org.junit.Test;

import java.text.ParseException;
import java.util.Date;

import static org.junit.Assert.fail;

public class StdDateFormatTest {

    @Test
    public void testStdDateFormatLenientParsing() {
        ObjectMapper objectMapper = new ObjectMapper();

        // Attempt to set the date format to non-lenient mode (which isn't actually supported)
        StdDateFormat dateFormat = new StdDateFormat();
        // Assuming StdDateFormat supports setting lenient, but in reality, it does not.
        // This is to reproduce the expected setup if leniency could be changed:
        // dateFormat.setLenient(false); // This method does not exist.

        objectMapper.setDateFormat(dateFormat);
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

        String invalidDate = "2015-01-32";
        
        try {
            // Attempt to parse an invalid date
            Date parsedDate = objectMapper.getDateFormat().parse(invalidDate);
            fail("Expected a ParseException to be thrown, but got date: " + parsedDate);
        } catch (ParseException e) {
            // Expected behavior: a ParseException should occur due to invalid date.
            // However, due to the lenient default behavior, this is not happening.
            System.out.println("ParseException was thrown as expected: " + e.getMessage());
        } catch (Exception e) {
            // If any other exception other than ParseException occurs, the test should fail
            fail("An unexpected exception was thrown: " + e.getMessage());
        }
    }
}
