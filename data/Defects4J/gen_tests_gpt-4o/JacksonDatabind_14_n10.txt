
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.module.SimpleModule;
import org.junit.Assert;
import org.junit.Test;

import java.io.IOException;

public class CustomDeserializerTest {
    
    static class DataA {
        public int i = 1;
        public int j = 2;
    }

    static class DataB {
        public DataA da = new DataA();
        public int k = 3;
    }

    static class DataADeserializer extends StdDeserializer<DataA> {
        private static final long serialVersionUID = 1L;

        DataADeserializer() {
            super(DataA.class);
        }

        @Override
        public DataA deserialize(JsonParser jp, DeserializationContext ctxt)
                throws IOException, JsonProcessingException {
            if (jp.getCurrentToken() == JsonToken.START_OBJECT) {
                JsonNode node = jp.getCodec().readTree(jp);

                DataA da = new DataA();
                da.i = 5;
                return da;
            }
            throw new IOException("Expected START_OBJECT token");
        }
    }

    @Test
    public void testCustomDeserializer() throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // Create new instances from JSON representation
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        Assert.assertEquals(5, dbNewViaString.da.i);
        Assert.assertEquals(13, dbNewViaString.k);

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        Assert.assertEquals(5, dbNewViaNode.da.i);
        Assert.assertEquals(13, dbNewViaNode.k);

        // Update existing instances
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        Assert.assertEquals(1, dbUpdViaString.da.i);
        Assert.assertEquals(3, dbUpdViaString.k);
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        Assert.assertEquals(5, dbUpdViaString.da.i);
        Assert.assertEquals(13, dbUpdViaString.k);

        Assert.assertEquals(1, dbUpdViaNode.da.i);
        Assert.assertEquals(3, dbUpdViaNode.k);
        // This is expected to fail as mentioned in the bug report
        try {
            mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
            // If it succeeds, this assertion is expected to fail
            Assert.assertEquals(5, dbUpdViaNode.da.i);
            Assert.assertEquals(13, dbUpdViaNode.k);
        } catch (Exception e) {
            System.out.println("Expected failure: " + e.getMessage());
        }
    }
}
