script
// Import the necessary classes for the test
import com.google.javascript.jscomp.*;
import com.google.javascript.rhino.Node;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class ClosureCompilerTest {

    @Test
    public void testBadTypeInferenceForUndefined() {
        // JavaScript code with type annotations
        String jsCode =
                "/** @param {string} x */\n" +
                "function g(x) {}\n" +
                "\n" +
                "/** @param {undefined} x */\n" +
                "function f(x) {\n" +
                "  if (x != undefined) { g(x); }\n" +
                "}";

        // Initialize the compiler
        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);

        // Create an input for the compiler
        CompilerInput input = new CompilerInput(SourceFile.fromCode("test.js", jsCode));
        CompilerInputs inputs = new CompilerInputs();
        inputs.add(input);

        // Compile the code
        Result result = compiler.compile(inputs, null, options);

        // Check if there are any warnings
        assertEquals("Expected one type mismatch warning", 1, result.warnings.length);

        // Validate that the warning is about the type mismatch for g(x)
        JSError warning = result.warnings[0];
        assertEquals("JSC_TYPE_MISMATCH", warning.getType().key);
        assertEquals("actual parameter 1 of g does not match formal parameter\n" +
                     "found   : undefined\n" +
                     "required: string", warning.description);
    }
}
