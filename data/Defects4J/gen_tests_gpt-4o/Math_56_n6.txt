
import java.util.Arrays;
import java.util.Iterator;
import org.junit.Assert;
import org.junit.Test;

public class MultidimensionalCounterTest {

    @Test
    public void testMultidimensionalCounterGetCounts() {
        MultidimensionalCounter counter = new MultidimensionalCounter(2, 4);
        int[][] expectedCounts = {
            {0, 0},
            {0, 1},
            {0, 2},
            {0, 3}, // Expected correct count instead of duplicate [0, 2]
            {1, 0},
            {1, 1},
            {1, 2},
            {1, 3}  // Expected correct count instead of duplicate [1, 2]
        };

        Iterator<Integer> iterator = counter.iterator();
        int idx = 0;
        while (iterator.hasNext()) {
            int i = iterator.next();
            int[] counts = counter.getCounts(i);
            Assert.assertArrayEquals("Mismatch at index " + i, expectedCounts[idx], counts);
            idx++;
        }
    }
}

// Assume this is a placeholder class since we don't have the actual implementation of MultidimensionalCounter
class MultidimensionalCounter implements Iterable<Integer> {
    private final int[] sizes;
    private final int totalSize;

    public MultidimensionalCounter(int... sizes) {
        this.sizes = sizes;
        this.totalSize = Arrays.stream(sizes).reduce(1, (a, b) -> a * b);
    }

    public int[] getCounts(int index) {
        int[] counts = new int[sizes.length];
        for (int i = sizes.length - 1; i >= 0; i--) {
            counts[i] = index % sizes[i];
            index /= sizes[i];
        }
        return counts;
    }

    @Override
    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            private int current = 0;

            @Override
            public boolean hasNext() {
                return current < totalSize;
            }

            @Override
            public Integer next() {
                return current++;
            }
        };
    }
}
