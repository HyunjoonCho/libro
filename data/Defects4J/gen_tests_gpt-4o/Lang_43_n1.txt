
import java.text.FieldPosition;
import java.text.Format;
import java.text.ParsePosition;
import java.util.HashMap;
import java.util.Map;

public class ExtendedMessageFormatTest {
    private static Map<String, FormatFactory> formatRegistry = new HashMap<>();
    
    static {
        formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());
    }

    public static void main(String[] args) {
        try {
            ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);
            String formattedPattern = mf.format(new Object[] {"great"});
            System.out.println(formattedPattern);
        } catch (OutOfMemoryError e) {
            System.err.println("OutOfMemoryError occurred as expected");
        }
    }
}

interface FormatFactory {
    Format getFormat(String name, String args, Map<String, Object> registry);
}

class DummyFormatFactory implements FormatFactory {
    public static final String DUMMY_FORMAT = "dummy";

    @Override
    public Format getFormat(String name, String args, Map<String, Object> registry) {
        return new DummyFormat();
    }
}

class DummyFormat extends Format {
    @Override
    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
        return toAppendTo.append((String) obj);
    }

    @Override
    public Object parseObject(String source, ParsePosition pos) {
        return null;
    }
}

class ExtendedMessageFormat extends java.text.MessageFormat {
    public ExtendedMessageFormat(String pattern, Map<String, FormatFactory> registry) {
        super(pattern);
        // For simplicity, internalize registry usage here. Acting as if the registry affects the format.
    }
}
