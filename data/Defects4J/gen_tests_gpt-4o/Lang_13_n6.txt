
import org.apache.commons.lang3.SerializationUtils;
import org.junit.Test;
import java.io.ObjectStreamClass;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.HashMap;
import static org.junit.Assert.assertEquals;

public class SerializationUtilsTest {

    @Test
    public void testPrimitiveTypeClassSerialization() {
        Class<?> primitiveType = int.class;

        Class<?> clone = SerializationUtils.clone(primitiveType);
        assertEquals(primitiveType, clone);
    }

    // Mockup of the problematic ClassLoaderAwareObjectInputStream for demonstration
    private static class CustomClassLoaderAwareObjectInputStream extends ObjectInputStream {
        private static final HashMap<String, Class<?>> primClasses = new HashMap<>();

        static {
            primClasses.put("int", int.class);
            primClasses.put("byte", byte.class);
            primClasses.put("long", long.class);
            primClasses.put("short", short.class);
            primClasses.put("float", float.class);
            primClasses.put("double", double.class);
            primClasses.put("boolean", boolean.class);
            primClasses.put("char", char.class);
            primClasses.put("void", void.class);
        }

        @Override
        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
            String name = desc.getName();
            try {
                return Class.forName(name, false, ClassLoader.getSystemClassLoader());
            } catch (ClassNotFoundException ex) {
                Class<?> cl = primClasses.get(name);
                if (cl != null) {
                    return cl;
                } else {
                    return super.resolveClass(desc);
                }
            }
        }
    }

}
