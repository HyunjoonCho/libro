
import org.joda.time.DateTimeFieldType;
import org.joda.time.Partial;
import org.junit.Test;
import static org.junit.Assert.*;

public class PartialTest {

    @Test(expected = IllegalArgumentException.class)
    public void testDuplicateTypeInPartialConstructor() {
        // This should throw an IllegalArgumentException due to duplicate date time field types.
        new Partial(
            new DateTimeFieldType[] { DateTimeFieldType.clockhourOfDay(), DateTimeFieldType.hourOfDay() }, 
            new int[] { 1, 1 }
        );
    }

    @Test
    public void testMergingPartialsWithDuplicateTypes() {
        Partial partial = new Partial(DateTimeFieldType.clockhourOfDay(), 1).with(DateTimeFieldType.hourOfDay(), 1);
        
        // Check if the partial was created with both fields as this appears to be invalid behavior
        assertEquals(1, partial.get(DateTimeFieldType.clockhourOfDay()));
        assertEquals(1, partial.get(DateTimeFieldType.hourOfDay()));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testInconsistentFieldOrderThrows() {
        Partial partial1 = new Partial(DateTimeFieldType.clockhourOfDay(), 1).with(DateTimeFieldType.hourOfDay(), 1);
        Partial partial2 = new Partial(DateTimeFieldType.hourOfDay(), 1).with(DateTimeFieldType.clockhourOfDay(), 1);
        
        // This should throw an IllegalArgumentException because matching fields are expected
        partial1.isEqual(partial2);
    }
}
