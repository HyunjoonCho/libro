
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonStreamContext;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class JsonContextTest {

    private static class TestData {
        public String key = "value";
    }

    @Test
    public void testDifferentContextForWriteAndConvert() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        TestData data = new TestData();

        // Using writeValue
        String jsonOutput = mapper.writeValueAsString(data);
        System.out.println("Serialized JSON using writeValue: " + jsonOutput);

        JsonGenerator generator1 = mapper.getFactory().createGenerator(System.out);
        generator1.writeObject(data);
        JsonStreamContext contextAfterWrite = generator1.getOutputContext();
        generator1.close();

        // Using convert
        Object intermediateObject = mapper.convertValue(data, Object.class);
        JsonGenerator generator2 = mapper.getFactory().createGenerator(System.out);
        generator2.writeObject(intermediateObject);
        JsonStreamContext contextAfterConvert = generator2.getOutputContext();
        generator2.close();

        // Comparing contexts
        System.out.println("Context after writeValue: " + contextAfterWrite);
        System.out.println("Context after convert: " + contextAfterConvert);

        // The test is mostly about observing the differences in the above output,
        // so assertions are not comparing the contexts directly since the bug report
        // indicates a structural issue rather than a simple value comparison.
        assertEquals(contextAfterWrite.getCurrentName(), contextAfterConvert.getCurrentName(),
                "Expected context names to be equal when writing and converting.");
    }
}
