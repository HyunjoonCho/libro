
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.util.Set;

import org.junit.Test;
import static org.junit.Assert.*;

public class JodaDateTimeZoneTest {

    private static DateTimeFormatter formatter = DateTimeFormat.forPattern("MM/dd/yyyy HH:mm:ss.SSS ZZZ");

    private static String convertDateTimeToFormattedString(DateTime dateTime) {
        return formatter.print(dateTime);
    }

    private static DateTime parseStringToDateTime(String formattedDateTime) {
        return formatter.parseDateTime(formattedDateTime);
    }

    private void testDateTimeFormatter(DateTime dateTime, String timeZone) {
        final String dateTimeZoneId = dateTime.getZone().getID();

        if (!timeZone.equals(dateTimeZoneId)) {
            fail(timeZone + " failed to construct into the proper date time zone - constructed time zone = " + dateTimeZoneId);
        }
        
        try {
            DateTime convertedDateTime = parseStringToDateTime(convertDateTimeToFormattedString(dateTime));

            assertEquals("Formatter failed for time zone ID: " + dateTimeZoneId, dateTime, convertedDateTime);
        } catch (IllegalArgumentException iae) {
            fail("Formatter threw exception for time zone id: " + dateTimeZoneId);
        }
    }

    @Test
    public void testAllTimeZones() {
        Set<String> timeZones = DateTimeZone.getAvailableIDs();
        boolean passed = true;

        for (String timeZone : timeZones) {
            try {
                testDateTimeFormatter(DateTime.now().withZone(DateTimeZone.forID(timeZone)), timeZone);
            } catch (AssertionError e) {
                System.out.println(e.getMessage());
                passed = false;
            }
        }

        assertTrue("There were failures or exceptions while testing time zones. Check console output for more details.", passed);
    }
}
