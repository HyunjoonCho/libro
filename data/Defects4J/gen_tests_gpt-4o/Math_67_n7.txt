
import org.apache.commons.math3.analysis.UnivariateFunction;
import org.apache.commons.math3.analysis.function.Sin;
import org.apache.commons.math3.optim.univariate.BracketFinder;
import org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker;
import org.apache.commons.math3.optim.univariate.UnivariateOptimizer;
import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;
import org.apache.commons.math3.optim.univariate.MultiStartUnivariateOptimizer;
import org.apache.commons.math3.random.JDKRandomGenerator;
import org.apache.commons.math3.random.RandomGenerator;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class MultiStartUnivariateRealOptimizerTest {

    @Test
    public void testGetResultReturnsBestOptimization() {
        // Define a simple function to optimize
        UnivariateFunction function = new Sin();

        // Underlying optimizer
        UnivariateOptimizer optimizer = new BracketFinder(new SimpleUnivariateValueChecker(1e-10, 1e-10));

        // Multistart optimizer with random generator
        RandomGenerator rng = new JDKRandomGenerator();
        MultiStartUnivariateOptimizer multiOptimizer = new MultiStartUnivariateOptimizer(optimizer, 10, rng);

        // Optimize within a range
        multiOptimizer.optimize(function, org.apache.commons.math3.optim.univariate.GoalType.MINIMIZE, new double[]{3, 4});

        // Get results
        double result = multiOptimizer.getResult();
        double bestValue = multiOptimizer.getFunctionValue();

        // Since getResult() and getFunctionValue() fix issues, they should match the best results
        assertEquals(multiOptimizer.getOptima()[0], result, 1e-10);
        assertEquals(multiOptimizer.getOptimaValues()[0], bestValue, 1e-10);
    }
}
