
import static org.junit.Assert.assertEquals;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.Result;

import org.junit.Test;

public class ClosureCompilerTest {

    @Test
    public void testClosureCompilerRegex() {
        // Original JavaScript code
        String originalJS = 
            "function urlEncodeIfNecessary(s) {" +
            "  var regex = /[\\\\\"<>.;]/; " +
            "  var hasBadChars = regex.exec(s) != null; " +
            "  return hasBadChars && typeof encodeURIComponent != 'undefined' ? encodeURIComponent(s) : s; " +
            "}";

        // Set up Compiler and CompilerOptions
        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        options.setCompilationLevel(CompilerOptions.CompilationLevel.SIMPLE_OPTIMIZATIONS);

        // Compile the code
        Result result = compiler.compile(JSSourceFile.fromCode("externs.js", ""), 
                                         JSSourceFile.fromCode("input.js", originalJS),
                                         options);

        // Get the compiled code
        String compiledJS = compiler.toSource();
       
        // Here we are checking to ensure that the regex is preserved correctly without causing a JS error
        boolean hasError = result.errors.length > 0;

        // Assert the compiled code doesn't have errors
        // Since we're trying to understand transformation issues with regex, 
        // it's valuable to ensure it's not producing errors upon compilation
        assertEquals(false, hasError);

        // You could assert the correctness more robustly by evaluating or manually inspecting the compiled JS
    }
}
