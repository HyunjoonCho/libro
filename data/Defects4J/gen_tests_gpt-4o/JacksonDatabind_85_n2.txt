
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import jdk.nashorn.internal.ir.annotations.Ignore;
import org.junit.jupiter.api.Test;

import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class DateTimeSerializerIssueTest {

    // Custom class with a date field to demonstrate the serialization issue
    public static class Event {
        @JsonFormat(pattern = "yyyy-MM-dd")
        public LocalDate date;

        public Event(LocalDate date) {
            this.date = date;
        }
    }

    @Test
    public void testCustomDateFormat() throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        
        Event event = new Event(LocalDate.of(2023, 10, 15));
        
        // Serializing the object using the ObjectMapper
        String jsonString = mapper.writeValueAsString(event);
        
        // Deserialize to check if the date follows "yyyy-MM-dd" pattern
        Event deserializedEvent = mapper.readValue(jsonString, Event.class);
        
        // Assert that the deserialized date matches the expected date
        assertEquals("2023-10-15", deserializedEvent.date.format(DateTimeFormatter.ofPattern("yyyy-MM-dd")));
    }
}
