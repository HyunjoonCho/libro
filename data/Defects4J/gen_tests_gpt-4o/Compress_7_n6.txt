
import org.junit.Test;
import static org.junit.Assert.*;

public class TarUtilsTest {

    @Test
    public void testParseNameWithSpecialCharacters() {
        byte[] buffer = new byte[] {
            '0', '3', '0', '2', '-', '0', '6', '0', '1', '-', '3', (byte)0xB1, (byte)0xB1, (byte)0xB1,
            'F', '0', '6', (byte)0xB1, 'W', '2', '2', '0', (byte)0xB1, 'Z', 'B', (byte)0xB1, 'L', 'A', 'L', 'A', 'L', 'A',
            (byte)0xB1, (byte)0xB1, (byte)0xB1, (byte)0xB1, (byte)0xB1, (byte)0xB1, (byte)0xB1, (byte)0xB1, (byte)0xB1,
            'C', 'A', 'N', (byte)0xB1, (byte)0xB1, 'D', 'C', (byte)0xB1, (byte)0xB1, (byte)0x04, (byte)0xB1, '0', '6',
            '0', '3', '0', '2', (byte)0xB1, 'M', 'O', 'E', '.', 'm', 'o', 'd', 'e', 'l'
        };

        // Mock test output assuming parseName simply converts bytes to characters
        // Modify this placeholder method according to your platform's TarUtils implementation
        String parsedName = parseName(buffer);

        // Expected name properly handling special characters (this will depend on the encoding and interpretation)
        String expectedName = "0302-0601-3±±±F06±W220±ZB±LALALA±±±±±±±±±±CAN±±DC±±04±060302±MOE.model";

        assertEquals(expectedName, parsedName);
    }

    // A mock implementation for demonstration purposes
    // Ideally, this would be the actual TarUtils.parseName implementation
    private String parseName(byte[] buffer) {
        StringBuilder result = new StringBuilder();
        for (byte b : buffer) {
            // It should decode 'b' as a UTF-8 or other encoding, not just cast to char
            result.append(new String(new byte[]{b})); // Replace this with actual decoder
        }
        return result.toString();
    }
}
