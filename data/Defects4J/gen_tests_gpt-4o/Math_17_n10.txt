
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import org.apache.commons.math3.dfp.Dfp;
import org.apache.commons.math3.dfp.DfpField;
import org.junit.Test;

public class DfpMultiplyTest {

    @Test
    public void testMultiplyWithLargeInteger() {
        DfpField field = new DfpField(25); // Precision of 25 digits
        Dfp dfpValue = new Dfp(field, 2); // Dfp instance representing the number 2
        
        try {
            Dfp result = dfpValue.multiply(10000);
            // According to the FieldElement contract, this should not throw an exception, 
            // so we proceed to check the expected result.
            Dfp expectedValue = new Dfp(field, 20000); // Expecting 2 * 10000 = 20000
            assertEquals(expectedValue, result);
        } catch (Exception e) {
            fail("multiply(int) should accept integers larger than 9999 without throwing an exception.");
        }
    }

    @Test
    public void testMultiplyWithNegativeInteger() {
        DfpField field = new DfpField(25); // Precision of 25 digits
        Dfp dfpValue = new Dfp(field, 3); // Dfp instance representing the number 3
        
        try {
            Dfp result = dfpValue.multiply(-2);
            // According to the FieldElement contract, this should not throw an exception,
            // so we proceed to check the expected result.
            Dfp expectedValue = new Dfp(field, -6); // Expecting 3 * -2 = -6
            assertEquals(expectedValue, result);
        } catch (Exception e) {
            fail("multiply(int) should accept negative integers without throwing an exception.");
        }
    }
}
