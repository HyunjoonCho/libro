
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresBuilder;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer;
import org.apache.commons.math3.fitting.leastsquares.LevenbergMarquardtOptimizer;
import org.apache.commons.math3.linear.DiagonalMatrix;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.linear.RealVector;
import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.optim.ConvergenceChecker;
import org.apache.commons.math3.optim.SimpleVectorValueChecker;
import org.apache.commons.math3.optim.PointVectorValuePair;
import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class LevenbergMarquardtOptimizerTest {

    @Test
    public void testConvergenceCheckerIsRespected() {
        // Custom checker with stringent criteria
        ConvergenceChecker<PointVectorValuePair> checker = new ConvergenceChecker<PointVectorValuePair>() {
            @Override
            public boolean converged(int iteration, PointVectorValuePair previous, PointVectorValuePair current) {
                double[] prev = previous.getValue();
                double[] curr = current.getValue();
                
                // Arbitrary condition likely never to be met for this test
                for (int i = 0; i < prev.length; i++) {
                    if (Math.abs(curr[i] - prev[i]) > 1e-12) {
                        return false;
                    }
                }
                return true;
            }
        };

        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();
        // Using the custom checker
        LeastSquaresProblem problem = new LeastSquaresBuilder()
                .checker(checker)
                .model((point) -> {
                    double[] values = new double[]{10, 9};
                    RealMatrix jacobian = new DiagonalMatrix(new double[]{1, 1});
                    return new LeastSquaresProblem.Evaluation() {
                        @Override
                        public RealMatrix getJacobian() {
                            return jacobian;
                        }

                        @Override
                        public RealVector getResiduals() {
                            return new ArrayRealVector(values);
                        }

                        @Override
                        public PointVectorValuePair getPoint() {
                            return new PointVectorValuePair(point, new ArrayRealVector(values));
                        }
                    };
                })
                .target(new double[]{0, 0})
                .lazyEvaluation(false)
                .maxEvaluations(100)
                .maxIterations(1000)
                .start(new double[]{1, 1})
                .build();

        // Run optimization and assert the convergence checker's influence
        LeastSquaresOptimizer.Optimum optimum = optimizer.optimize(problem);
        
        // If convergence checker was respected, it should terminate early
        assertTrue("Optimum was not reached respecting the convergence criteria", optimum.getIterations() < 1000);
    }
}
