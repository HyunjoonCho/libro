
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

// Step 1: Define the base class with JsonTypeInfo for polymorphism
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type", defaultImpl = SubTypeA.class)
@JsonSubTypes({
    @JsonSubTypes.Type(value = SubTypeA.class, name = "A"),
    @JsonSubTypes.Type(value = SubTypeB.class, name = "B")
})
abstract class BaseType {
    private String baseProperty;

    public String getBaseProperty() {
        return baseProperty;
    }

    public void setBaseProperty(String baseProperty) {
        this.baseProperty = baseProperty;
    }
}

// Step 2: Define a subtype with specific properties
@JsonTypeName("A")
class SubTypeA extends BaseType {
    private String subPropertyA;

    public String getSubPropertyA() {
        return subPropertyA;
    }

    public void setSubPropertyA(String subPropertyA) {
        this.subPropertyA = subPropertyA;
    }
}

// Step 3: Define another subtype
@JsonTypeName("B")
class SubTypeB extends BaseType {
    private String subPropertyB;

    public String getSubPropertyB() {
        return subPropertyB;
    }

    public void setSubPropertyB(String subPropertyB) {
        this.subPropertyB = subPropertyB;
    }
}

public class PolymorphicTypeTest {
    // Step 4: Create a test case to demonstrate the issue
    @Test
    public void testDefaultImplSubTypeResolution() throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();

        // JSON without type information, to rely on defaultImpl
        String json = "{\"baseProperty\":\"baseValue\", \"subPropertyA\":\"subValueA\"}";

        BaseType result = objectMapper.readValue(json, BaseType.class);

        // The base type properties should be available
        assertNotNull(result);
        assertEquals("baseValue", result.getBaseProperty());

        // The result should be of type SubTypeA due to defaultImpl
        assertEquals(SubTypeA.class, result.getClass());

        // Specific property of SubTypeA should be available too
        SubTypeA subResult = (SubTypeA) result;
        assertEquals("subValueA", subResult.getSubPropertyA());
    }
}
