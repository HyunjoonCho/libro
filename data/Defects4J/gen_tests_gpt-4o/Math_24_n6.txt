
import org.apache.commons.math3.analysis.UnivariateFunction;
import org.apache.commons.math3.analysis.function.Sin;
import org.apache.commons.math3.optim.univariate.BrentOptimizer;
import org.apache.commons.math3.optim.univariate.GoalType;
import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;
import org.apache.commons.math3.optim.univariate.SearchInterval;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class BrentOptimizerTest {

    @Test
    public void testBrentOptimizerNotReturningBestPoint() {
        // Define a simple sinusoidal function
        UnivariateFunction function = new Sin();

        // Create a BrentOptimizer instance with very low tolerance to force precision issues
        BrentOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);

        // Define the search interval [3, 4], with expectation of maximum near Ï€/2 radians (approximately 3.142)
        SearchInterval searchInterval = new SearchInterval(3, 4);

        // Perform the optimization searching for maximum
        UnivariatePointValuePair result = optimizer.optimize(
                new org.apache.commons.math3.optim.MaxEval(1000),
                new org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction(function),
                GoalType.MAXIMIZE,
                searchInterval
        );

        // Check if the returned point is indeed the maximum in the interval [3, 4]
        double expectedMax = Math.PI / 2;
        assertEquals(expectedMax, result.getPoint(), 1e-2);

        // Verify if the result was not as expected, which would confirm the issue
        // Note: This assertion highlights the bug by checking for discrepancies with known mathematical values
    }
}
