
import static org.junit.Assert.*;

import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.WarningLevel;
import org.junit.Test;

public class PrototypeTypeInferenceTest {

    @Test
    public void testPrototypePropertyTypeInference() {
        // JavaScript code that triggers the bug
        String jsCode = "/** @param {Object} a */\n" +
                        "function f(a) {\n" +
                        "   a.prototype = '__proto';\n" +
                        "}\n" +
                        "\n" +
                        "/** @param {Object} a */\n" +
                        "function g(a) {\n" +
                        "   a.prototype = function(){};\n" +
                        "}\n";

        // Create a new Compiler instance
        Compiler compiler = new Compiler();

        // Set compiler options
        CompilerOptions options = new CompilerOptions();
        WarningLevel.VERBOSE.setOptionsForWarningLevel(options);

        // Compile the JavaScript code
        Result result = compiler.compile(SourceFile.fromCode("externs.js", ""), SourceFile.fromCode("test.js", jsCode), options);

        // Check for warnings or errors indicating the incorrect type inference
        boolean hasTypeIssue = result.warnings.stream()
                .anyMatch(warning -> warning.description.contains("assignment to property prototype of Object")
                        && warning.description.contains("required: string"));

        // Assert that there should not be any type inference issue
        assertFalse("Type inference incorrectly inferred to string for prototype property", hasTypeIssue);
    }
}
