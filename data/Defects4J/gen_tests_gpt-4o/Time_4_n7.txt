
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.joda.time.DateTimeFieldType.clockhourOfDay;
import static org.joda.time.DateTimeFieldType.hourOfDay;
import static org.joda.time.DateTimeFieldType.year;

import org.joda.time.Partial;
import org.junit.Test;

public class PartialTest {

    @Test(expected = IllegalArgumentException.class)
    public void testInvalidPartialConstructionWithDuplicateTypes() {
        // This should throw an IllegalArgumentException due to duplicate types
        new Partial(new DateTimeFieldType[] { clockhourOfDay(), hourOfDay() }, new int[] { 1, 1});
    }
    
    @Test
    public void testInvalidPartialConstructionWithWithMethod() {
        Partial a = new Partial(clockhourOfDay(), 1).with(hourOfDay(), 1);
        
        // This should not construct a valid partial with duplicate field types
        // The implementation should ensure that this does not produce a meaningful partial

        // Since they have different field types order, they should not be considered equal
        Partial b = new Partial(hourOfDay(), 1).with(clockhourOfDay(), 1);
        assertFalse(a.isEqual(b));

        // Objects should have matching field types needs to be appropriately handled
        try {
            a.isEqual(b);
            assertFalse("Objects should not have matching field types", a.isEqual(b));
        } catch (IllegalArgumentException e) {
            // Expected since fields are in different order
        }
    }
    
    @Test
    public void testConsistentPartialConstruction() {
        Partial a = new Partial(new DateTimeFieldType[] { year(), hourOfDay() }, new int[] { 1, 1 });
        Partial b = new Partial(year(), 1).with(hourOfDay(), 1);

        // Assert that both constructions result in equal Partials
        assertTrue(a.isEqual(b));
    }
}
