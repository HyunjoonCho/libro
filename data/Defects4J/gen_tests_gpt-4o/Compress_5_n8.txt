
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import static org.junit.Assert.fail;

public class TruncatedZipArchiveTest {

    @Test
    public void testTruncatedZipArchive() {
        // Simulating a truncated ZIP archive bytes
        byte[] truncatedZipBytes = new byte[]{
            0x50, 0x4B, 0x03, 0x04, // Local file header signature
            0x14, 0x00, // Version needed to extract
            0x08, 0x00, // General purpose bit flag
            0x08, 0x00, // Compression method
            0x00, 0x00, 0x00, 0x00, // Last mod file time & date
            0x00, 0x00, 0x00, 0x00, // CRC-32
            0x00, 0x00, 0x00, 0x00, // Compressed size
            0x00, 0x00, 0x00, 0x00, // Uncompressed size
            0x05, 0x00, // Filename length
            0x00, 0x00, // Extra field length
            // Filename (5 bytes, but could be anything)
            0x74, 0x65, 0x73, 0x74, 0x74,
            // Missing file data and end of file headers to simulate truncation
        };

        ByteArrayInputStream bais = new ByteArrayInputStream(truncatedZipBytes);
        try (ZipArchiveInputStream zipInputStream = new ZipArchiveInputStream(bais)) {
            byte[] buffer = new byte[1024];
            while (zipInputStream.read(buffer) != -1) {
                // Continues attempting to read, should eventually throw IOException
            }
            fail("Expected an IOException due to truncated ZIP file");
        } catch (IOException e) {
            // If an IOException is thrown, the test has succeeded
            System.out.println("Test passed. Caught expected IOException: " + e.getMessage());
        }
    }
}
