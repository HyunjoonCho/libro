
import org.apache.commons.math3.exception.OutOfRangeException;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.junit.Test;
import static org.junit.Assert.assertTrue;

public class CMAESOptimizerTest {

    @Test
    public void testCMAESOptimizerEnforcesBounds() {
        double[] lowerBounds = {-5.0, -5.0};
        double[] upperBounds = {5.0, 5.0};

        CMAESOptimizer optimizer = new CMAESOptimizer(10000, 0, true, 0, 0, null, false, null);

        MultivariateFunctionMappingAdapter fitnessFunction = new MultivariateFunctionMappingAdapter(
            point -> {
                double x = point[0];
                double y = point[1];

                return (x - 2) * (x - 2) + (y - 3) * (y - 3);
            }, lowerBounds, upperBounds
        );

        PointValuePair result = optimizer.optimize(
            new MaxEval(1000),
            new org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction(fitnessFunction),
            GoalType.MINIMIZE,
            new org.apache.commons.math3.optim.InitialGuess(new double[] {0, 0}),
            new org.apache.commons.math3.optim.SimpleBounds(lowerBounds, upperBounds)
        );

        double[] solution = fitnessFunction.unboundedToBounded(result.getPoint());

        for (int i = 0; i < solution.length; i++) {
            assertTrue("Solution violates bounds for index " + i, solution[i] >= lowerBounds[i] && solution[i] <= upperBounds[i]);
        }
    }
}
