
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.filter.FilteringParserDelegate;
import com.fasterxml.jackson.core.filter.TokenFilter;
import org.junit.Test;

import java.io.IOException;
import static org.junit.Assert.assertEquals;

public class FilteringParserDelegateTest {

    @Test
    public void testAllowMultipleMatches() throws IOException {
        // Sample JSON data
        String json = "{ \"name\": \"John\", \"age\": 30, \"children\": [\"Jack\", \"Anna\"] }";

        // Create a JsonFactory and JsonParser
        JsonFactory factory = new JsonFactory();
        JsonParser parser = factory.createParser(json);

        // Create a TokenFilter that should potentially allow for multiple matches
        TokenFilter filter = new TokenFilter() {
            @Override
            public TokenFilter includeProperty(String name) {
                // Allow 'children' property to be processed multiple times
                return "children".equals(name) ? TokenFilter.INCLUDE_ALL : null;
            }
        };

        // Create FilteringParserDelegate with _allowMultipleMatches condition expected to be true
        FilteringParserDelegate delegate = new FilteringParserDelegate(parser, filter, true, true);

        int count = 0;
        while (delegate.nextToken() != null) {
            if (delegate.currentToken() == JsonToken.VALUE_STRING) {
                count++;
            }
        }

        // Expected matches count based on the assumption of _allowMultipleMatches functioning
        // In this case, we expect both "Jack" and "Anna" to be counted if _allowMultipleMatches works
        assertEquals(2, count);
    }
}
