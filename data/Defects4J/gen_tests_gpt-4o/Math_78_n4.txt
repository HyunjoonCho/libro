public void testVeryCloseEventsDetection() {
    // Define the ODE with a switching function that exhibits the issue
    FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {
        public int getDimension() {
            return 1;
        }

        public void computeDerivatives(double t, double[] y, double[] yDot) {
            yDot[0] = 1.0;
        }
    };

    // Implement a switching function representing the events
    EventHandler eventHandler = new EventHandler() {
        public int eventOccurred(double t, double[] y, boolean increasing) {
            return EventHandler.STOP;
        }

        public double g(double t, double[] y) {
            if (t < 135.0) {
                return Math.sin(t) - 0.1; // Handle first event
            } else {
                return 0.2 - Math.sin(t); // Handle second event
            }
        }

        public void resetState(double t, double[] y) {}
    };

    // Set up the integrator and add the event handler
    double minStep = 1.0e-8;
    double maxStep = 10.0;
    double absoluteTolerance = 1.0e-10;
    double relativeTolerance = 1.0e-10;
    double t0 = 0.0;
    double[] y0 = new double[]{0.0};
    double t = 200.0;

    GraggBulirschStoerIntegrator integrator = new GraggBulirschStoerIntegrator(
            minStep, maxStep, absoluteTolerance, relativeTolerance);

    integrator.addEventHandler(eventHandler, 1.0e-1, 1.0e-3, 100);

    // Attempt integration and check if both events are detected
    integrator.integrate(ode, t0, y0, t, y0);
    assertEquals(135.0, integrator.getCurrentStepStart(), 1.0e-3);
}