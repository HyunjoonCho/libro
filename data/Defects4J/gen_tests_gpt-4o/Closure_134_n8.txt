
import com.google.javascript.jscomp.*;
import com.google.javascript.jscomp.Compiler;
import org.junit.Test;
import static org.junit.Assert.*;

public class InheritDocInterfaceTest {

    @Test
    public void testInheritDocWithInterface() {
        String code = "/**\n" +
                " * Interface\n" +
                " * @interface\n" +
                " */\n" +
                "A = function() {};\n" +
                "\n" +
                "/**\n" +
                " * @param {string} a\n" +
                " */\n" +
                "A.prototype.foo = function(a) {};\n" +
                "\n" +
                "/**\n" +
                " * @constructor\n" +
                " * @implements {A}\n" +
                " */\n" +
                "B = function() {};\n" +
                "\n" +
                "/**\n" +
                " * @inheritDoc\n" +
                " */\n" +
                "B.prototype.foo = function(a) {\n" +
                "  alert(a.substring(0));\n" +
                "};";

        // Create a new compiler instance
        Compiler compiler = new Compiler();

        // Set the options for the compilation
        CompilerOptions options = new CompilerOptions();
        CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);

        // Run the compilation
        Result result = compiler.compile(
                AbstractCommandLineRunner.getDefaultExterns(), // Default externs
                SourceFile.fromCode("test.js", code),          // Source code
                options);

        // Assert that there should be no errors
        assertTrue("Expected no errors", result.success);
        
        // Check for the expected warning about unsupported @inheritDoc
        assertEquals(1, compiler.getWarnings().length);
        assertEquals(DiagnosticGroups.JSDOC_MISSING_TYPE.getDiagnosticType(), 
                     compiler.getWarnings()[0].getType());
    }
}
