public void testInvalidPropertyInForLoop() {
    String externs = "/**\n" +
            " * @const\n" +
            " */\n" +
            "var ns = {};\n" +
            "/**\n" +
            " * @typedef {{subthing: {prop: number}}}\n" +
            " */\n" +
            "ns.Thing;\n";

    String code = "/**\n" +
            " * @param {ns.Thing} thing\n" +
            " * @constructor\n" +
            " */\n" +
            "ns.MyClass = function(thing) {\n" +
            "  /** @type {ns.Thing} */ this.thing_ = thing;\n" +
            "};\n" +
            "ns.MyClass.prototype.doIt = function() {\n" +
            "  var subthing = this.thing_.subthing;\n" +
            "  for (var i = 0; i < subthing.noprop; i++) {\n" +
            "    window.console.log(i);\n" +
            "  }\n" +
            "};\n" +
            "var thing = /** @type {ns.Thing} */({subthing: {prop: 3}});\n" +
            "var c = new ns.MyClass(thing);\n" +
            "c.doIt();\n";

    // This example assumes we have tools in place to run the Closure Compiler.
    // Ideally, the following would trigger an error about 'noprop' not existing.
    try {
        // Compiler simulating methods, not real API
        runClosureCompilerWithErrors(externs, code);
        fail("Expected a type error due to 'noprop' not existing on subthing.");
    } catch (ClosureCompilerAssertionError e) {
        assertTrue(e.getMessage().contains("Property noprop never defined on any object"));
    }
}

// Placeholder methods used to simulate the interaction with Closure Compiler.
private void runClosureCompilerWithErrors(String externs, String code) throws ClosureCompilerAssertionError {
    // Simulated method to throw an error when invalid property access is not caught
    throw new ClosureCompilerAssertionError("Property noprop never defined on any object");
}

private class ClosureCompilerAssertionError extends Exception {
    public ClosureCompilerAssertionError(String message) {
        super(message);
    }
}