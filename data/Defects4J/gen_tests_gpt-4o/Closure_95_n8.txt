
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

public class GlowLibraryTest {

    @Test
    public void testGlowLibraryWithAdvancedOptimizations() {
        // Simulate the original JavaScript code behavior:
        // Define the Glow library
        Glow glow = new Glow();
        glow.versions = new int[]{1, 2, 3};

        // Function to show versions
        glow.showVersions = () -> {
            // Simulate alert by returning the versions as a string
            return glow.versionsAsString();
        };

        // Simulate the advanced optimization output
        Glow optimizedGlow = new Glow();
        optimizedGlow.a = new int[]{1, 2, 3};  // Simulating variable renaming
        optimizedGlow.b = () -> {
            // This will effectively return optimizedGlow.a
            return optimizedGlow.versionsAsStringOptimized();
        };

        // Expose public interface
        window("Glow", optimizedGlow);
        optimizedGlow.versions = optimizedGlow.a;
        optimizedGlow.showVersions = optimizedGlow.b;

        // Simulate user code that assigns a new array to Glow.versions
        optimizedGlow.versions = new int[]{4, 5, 6};

        // Check if the showVersions still references the renamed version
        assertNotEquals("4,5,6", optimizedGlow.showVersions.show());

        // Simulate the desired behavior with @public tag (hypothetical)
        Glow expectedGlow = new Glow();
        expectedGlow.versions = new int[]{1, 2, 3};
        expectedGlow.showVersions = () -> {
            // Should use the public version
            return expectedGlow.versionsAsString();
        };

        // Assign new versions array
        expectedGlow.versions = new int[]{4, 5, 6};

        // Check if the showVersions references the public version
        assertEquals("4,5,6", expectedGlow.showVersions.show());
    }

    // Mocking a basic window object with property map
    private void window(String name, Glow glowInstance) {
        // Typically, this would add to a window object, but for our case, it's a no-op
    }

    // Mock of the Glow library
    private static class Glow {
        int[] versions;
        int[] a;  // Optimized renamed variable
        Function showVersions;
        Function b;  // Optimized renamed function

        // Method simulating display of versions
        public String versionsAsString() {
            return arrayToString(versions);
        }

        // Method simulating display of optimized versions
        public String versionsAsStringOptimized() {
            return arrayToString(a);
        }

        // Helper method to convert array to string
        private String arrayToString(int[] arr) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < arr.length; i++) {
                sb.append(arr[i]);
                if (i < arr.length - 1) {
                    sb.append(",");
                }
            }
            return sb.toString();
        }

        // Functional Interface for showVersions
        @FunctionalInterface
        interface Function {
            String show();
        }
    }
}
