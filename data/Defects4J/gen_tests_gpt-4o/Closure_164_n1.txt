typescript
import { expect } from 'chai';

describe('Function Type Assignment Test', () => {
    /**
     * Represents a function type with a string and number parameter 
     * returning a boolean.
     */
    type FuncType = (param1: string, param2: number) => boolean;

    /**
     * A function that requires a FuncType parameter.
     * @param param - A function matching FuncType.
     */
    function func(param: FuncType) {
        // Function body is not relevant to the test case
    }

    /**
     * A function matching the required parameter type.
     * @type {function(string,number,boolean):boolean}
     */
    function paramFunc1(param1: string, param2: number, param3: boolean): boolean {
        return true;
    }

    /**
     * A mismatched function, with only a single string parameter.
     * @type {function(string):boolean}
     */
    function paramFunc2(param1: string): boolean {
        return true;
    }

    it('should correctly handle function type assignments', () => {
        // The first call should compile if we consider subtyping rules,
        // but it might provide a warning or error based on strict mode.
        func(paramFunc1 as unknown as FuncType);

        // The second call should not compile due to parameter mismatch.
        // In regular TypeScript, we simulate an expected error using a try-catch.
        
        // Type safety test: This line should be commented out in strict checking
        // but can be used to verify TypeScript behavior.
        // expect(() => func(paramFunc2 as unknown as FuncType)).to.throw();

        // Assert that there would be a compilation error here in strict semantics.
        try {
            func(paramFunc2 as unknown as FuncType);
        } catch (e) {
            expect(e).to.exist;
        }
    });
});
