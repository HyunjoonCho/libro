
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.databind.type.ReferenceType;
import org.apache.commons.collections4.map.LRUMap;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class ReferenceTypeTest {

    @Test
    public void testReferenceTypeCanonicalString() {
        TypeFactory typeFactory = new TypeFactory(new LRUMap<>(0, 10000));
        JavaType objectType = typeFactory.constructType(Object.class);

        // Assume PlaceholderForType is a class that handles generic type placeholding
        // Here we're using a mock as we don't have the implementation details
        class PlaceholderForType extends JavaType {
            private final int index;

            protected PlaceholderForType(int index) {
                super(null, null, false, null, null);
                this.index = index;
            }

            @Override
            public StringBuilder getGenericSignature(StringBuilder sb) {
                return sb.append("$").append(index);
            }

            @Override
            public StringBuilder getErasedSignature(StringBuilder sb) {
                return sb.append("$").append(index);
            }

            @Override
            public String toCanonical() {
                return "$" + index;
            }
        }

        PlaceholderForType placeholder = new PlaceholderForType(1);

        ReferenceType referenceType = new ReferenceType(objectType, placeholder);
        String canonical = referenceType.toCanonical();
        
        assertEquals("java.lang.Object<$1>", canonical);
    }
}
