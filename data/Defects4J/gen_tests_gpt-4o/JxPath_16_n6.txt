
import org.junit.Test;
import static org.junit.Assert.assertTrue;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

public class NodePointerTest {
    
    @Test
    public void testNodeFunctionInDOMNodePointer() throws Exception {
        // Setting up a DOM Document and Nodes
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.newDocument();
        
        Element element = document.createElement("TestElement");
        Text textNode = document.createTextNode("TextNode");
        
        document.appendChild(element);
        element.appendChild(textNode);

        DOMNodePointer elementPointer = new DOMNodePointer(element);
        DOMNodePointer textNodePointer = new DOMNodePointer(textNode);

        // Modify this test based on the actual role of DOMNodePointer in your framework/library
        assertTrue("Element node should match node()", elementPointer.matchesNodeType(Node.ELEMENT_NODE));
        assertTrue("Text node should match node() but doesn't in current implementation", 
                   textNodePointer.matchesNodeType(Node.TEXT_NODE));
    }
}

// Mock class to demonstrate the test scenario, will be replaced by actual DOMNodePointer in real implementation
class DOMNodePointer {
    private final Node node;

    public DOMNodePointer(Node node) {
        this.node = node;
    }

    public boolean matchesNodeType(short nodeType) {
        // This is a placeholder to mimic the incorrect behavior described in the bug.
        // The "buggy" implementation for context
        if (nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE) {
            return true;
        }
        return false; // Text nodes or other types of nodes would incorrectly return false
    }
}
