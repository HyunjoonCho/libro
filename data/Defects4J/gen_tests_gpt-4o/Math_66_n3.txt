
import org.apache.commons.math3.optim.univariate.BrentOptimizer;
import org.apache.commons.math3.analysis.function.Sin;
import org.apache.commons.math3.optim.univariate.SearchInterval;
import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;
import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;
import org.apache.commons.math3.optim.MaxEval;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class BrentOptimizerTest {

    // Tolerance for floating-point comparisons
    private static final double TOLERANCE = 1e-9;

    @Test
    public void testOptimize() {
        // Create a BrentOptimizer instance
        BrentOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);

        // Define the function to optimize: f(x) = -sin(x), which maxima should be at x = π/2
        UnivariateObjectiveFunction objectiveFunction = new UnivariateObjectiveFunction(new Sin().negate());

        // Create a search interval around the expected maximum of sin(x) within [0, π]
        SearchInterval searchInterval = new SearchInterval(0, Math.PI, Math.PI / 2);

        // Perform the optimization
        UnivariatePointValuePair result = optimizer.optimize(
            new MaxEval(1000),
            objectiveFunction,
            searchInterval
        );

        // Validate the result
        // The maximum of -sin(x) should be at x = π/2, with the maximum value being approx. -1
        assertEquals(Math.PI / 2, result.getPoint(), TOLERANCE);
        assertEquals(-1.0, result.getValue(), TOLERANCE);
    }
}
