script
public class ClosureCompilerBugTest {

    @Test
    public void testSwitchedOrderBug() {
        // Original input code
        Map<String, String> customData = new HashMap<>();
        customData.put("key", "value");

        String result = testRemoveKey(customData, "key");
        assertEquals("value", result);
        assertFalse(customData.containsKey("key"));
        
        // Simulates the closure compiled code effect
        customData.put("key", "value");
        
        String resultAfterCompilation = testRemoveKeyCompiled(customData, "key");
        assertNull(resultAfterCompilation);
        assertFalse(customData.containsKey("key"));
    }

    private String testRemoveKey(Map<String, String> data, String key) {
        String value = data.getOrDefault(key, null);
        boolean hadKey = data.containsKey(key);

        data.remove(key);

        return hadKey ? value : null;
    }
    
    private String testRemoveKeyCompiled(Map<String, String> data, String key) {
        String value = data.getOrDefault(key, null);
        
        data.remove(key);
        
        // This simulates (key in data) being checked after deletion,
        // which is the behavior observed in the incorrect compilation
        return data.containsKey(key) ? value : null;
    }
}
