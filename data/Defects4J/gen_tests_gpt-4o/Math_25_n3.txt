
import org.apache.commons.math3.analysis.function.*;
import org.apache.commons.math3.optim.nonlinear.vector.*;
import org.apache.commons.math3.optim.*;
import org.apache.commons.math3.fitting.*;
import org.junit.Test;
import static org.junit.Assert.*;

public class HarmonicFitterTest {

    @Test
    public void testAmplitudeGuessing() {
        // Sample data that might cause the amplitude estimation to be incorrect
        double[][] data = new double[][] {
            {0.0, 0.0},
            {1.0, 0.5},
            {2.0, 0.0},
            {3.0, -0.5},
            {4.0, 0.0},
            {5.0, 0.6},  // An outlier that might affect amplitude calculation
            {6.0, 0.1},
            {7.0, -0.8},
            {8.0, 0.3}
        };

        // Create an instance of HarmonicFitter
        HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer());

        // Add points to the fitter
        for (double[] point : data) {
            fitter.addObservedPoint(point[0], point[1]);
        }

        // Attempt to guess parameters
        try {
            // Create the parameter guesser
            HarmonicFitter.ParameterGuesser guesser = new HarmonicFitter.ParameterGuesser(fitter.getObservations());
            double[] guessedParameters = guesser.guess();
            
            // Extract the amplitude from guessed parameters
            double amplitudeGuess = guessedParameters[0];

            // Check if the amplitude guess is within a reasonable range
            assertTrue("The amplitude guess should be positive", amplitudeGuess > 0);
            assertTrue("The amplitude guess should be within expected range", amplitudeGuess < 2.0);

        } catch (Exception e) {
            fail("Parameter guessing threw an exception: " + e.getMessage());
        }
    }
}
