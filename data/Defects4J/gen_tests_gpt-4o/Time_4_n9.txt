
import org.junit.Test;
import static org.junit.Assert.*;

import org.joda.time.Partial;
import org.joda.time.DateTimeFieldType;

public class PartialTest {

    @Test(expected = IllegalArgumentException.class)
    public void testInvalidPartialConstructionWithDuplicateTypes() {
        // This should throw an exception due to duplicate field types
        new Partial(new DateTimeFieldType[]{DateTimeFieldType.clockhourOfDay(), DateTimeFieldType.hourOfDay()}, new int[]{1, 1});
    }

    @Test
    public void testValidPartialConstruction() {
        // Here, both approaches should create equivalent Partial objects
        Partial a = new Partial(DateTimeFieldType.year(), 1).with(DateTimeFieldType.hourOfDay(), 1);
        Partial b = new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.hourOfDay()}, new int[]{1, 1});
        assertEquals(a, b);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testInvalidPartialEqualityWithNonMatchingFieldTypes() {
        Partial partial1 = new Partial(DateTimeFieldType.clockhourOfDay(), 1).with(DateTimeFieldType.hourOfDay(), 1);
        Partial partial2 = new Partial(DateTimeFieldType.hourOfDay(), 1).with(DateTimeFieldType.clockhourOfDay(), 1);
        
        // This should throw an exception since the field types should not match for isEqual comparison
        partial1.isEqual(partial2);
    }
}
