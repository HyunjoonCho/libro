
import static org.junit.Assert.fail;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.junit.Test;

public class TarArchiveInputStreamTest {

    @Test
    public void testParsePaxHeadersWithEmptyLine() {
        // Example PAX headers with an empty line at the end
        // Normally, PAX headers contain key-value pairs in the format of length key=value\n
        String paxHeaders = "21 path=some/file/path.txt\n\n";
        
        byte[] data = createTarEntryWithPaxHeaders(paxHeaders);
        
        try (TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(data))) {
            // Read the first entry, which should trigger parsing of PAX headers
            tais.getNextTarEntry();
        } catch (NegativeArraySizeException e) {
            fail("NegativeArraySizeException should not occur in parsePaxHeaders when an empty line is present");
        } catch (IOException e) {
            fail("IOException should not occur: " + e.getMessage());
        }
    }

    private byte[] createTarEntryWithPaxHeaders(String paxHeaders) {
        // This method is simplified for demonstration and likely differers from how actual tar entries are created
        // with PAX headers. This mimics the ability to set headers and could be adjusted to integrate with a real
        // tar creation library if needed.
        
        // Simulate tar header followed by PAX headers
        byte[] headerBytes = new byte[512]; // Standard TAR block size for headers
        // Convert the PAX headers to bytes
        byte[] paxHeaderBytes = paxHeaders.getBytes();
        byte[] data = new byte[headerBytes.length + paxHeaderBytes.length];

        System.arraycopy(headerBytes, 0, data, 0, headerBytes.length);
        System.arraycopy(paxHeaderBytes, 0, data, headerBytes.length, paxHeaderBytes.length);

        return data;
    }
}
