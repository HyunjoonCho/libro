
import static org.junit.Assert.*;

import org.junit.Test;

public class ClosureCompilerTest {

    @Test
    public void testFunctionPropertyPreservation() {
        String originalCode = 
            "var lastMsg;\n" +
            "var map = {};\n" +
            "\n" +
            "var addToMap = function(key, func) {\n" +
            "    map[key] = func;\n" +
            "};\n" +
            "\n" +
            "var f1 = function() { alert('f1'); };\n" +
            "f1.alwaysCall = true;\n" +
            "var f2 = function() { alert('f2'); };\n" +
            "\n" +
            "addToMap('f1', f1);\n" +
            "addToMap('f2', f2);\n" +
            "\n" +
            "var callFunctionByKey = function(key) {\n" +
            "    var f = map[key];\n" +
            "    if (f.alwaysCall) f();\n" +
            "};\n" +
            "\n" +
            "callFunctionByKey(Math.random() > 0.5 ? 'f1' : 'f2');";

        // Use Closure Compiler to compile the original code with advanced optimizations
        com.google.javascript.jscomp.Compiler compiler = new com.google.javascript.jscomp.Compiler();
        com.google.javascript.jscomp.CompilerOptions options = new com.google.javascript.jscomp.CompilerOptions();
        com.google.javascript.jscomp.CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
        
        com.google.javascript.jscomp.SourceFile extern = com.google.javascript.jscomp.SourceFile.fromCode("externs.js", "");
        com.google.javascript.jscomp.SourceFile input = com.google.javascript.jscomp.SourceFile.fromCode("input.js", originalCode);
        
        compiler.compile(extern, input, options);
        
        String optimizedCode = compiler.toSource();

        // Check that optimized code still retains the 'alwaysCall' property
        assertTrue(optimizedCode.contains("b.a && b()"));
        assertTrue(optimizedCode.contains("a.f1.a = true"));  // The optimizer should preserve this assignment
    }
}
