
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.junit.Test;

import java.util.Set;

import static org.junit.Assert.assertEquals;

public class JodaDateTimeZoneTest {

    private static final DateTimeFormatter formatter = DateTimeFormat.forPattern("MM/dd/yyyy HH:mm:ss.SSS ZZZ");

    @Test
    public void testDateTimeZoneConsistency() {
        Set<String> timeZones = DateTimeZone.getAvailableIDs();

        for (String timeZone : timeZones) {
            testDateTimeFormatter(DateTime.now().withZone(DateTimeZone.forID(timeZone)), timeZone);
        }
    }

    private void testDateTimeFormatter(DateTime dateTime, String expectedTimeZone) {
        final String originalZone = dateTime.getZone().getID();

        if (!expectedTimeZone.equals(originalZone)) {
            System.out.println(expectedTimeZone + " failed to construct into the proper date time zone - constructed time zone = " + originalZone);
            return;
        }

        try {
            DateTime convertedDateTime = parseStringToDateTime(convertDateTimeToFormattedString(dateTime));

            assertEquals("Mismatch in time zone ID after conversion for: " + originalZone,
                    dateTime.getZone().getID(), convertedDateTime.getZone().getID());

        } catch (IllegalArgumentException iae) {
            System.out.println("Formatter threw exception for time zone id: " + originalZone);
        }
    }

    private String convertDateTimeToFormattedString(DateTime dateTime) {
        return formatter.print(dateTime);
    }

    private DateTime parseStringToDateTime(String formattedDateTime) {
        return formatter.parseDateTime(formattedDateTime);
    }
}
