
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.apache.commons.compress.utils.IOUtils;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.zip.ZipInputStream;

import static org.junit.Assert.assertTrue;

public class ZipFileCorruptionTest {

    @Test
    public void testZipFileCorruptionWithManyEntries() throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zipOutputStream = new ZipArchiveOutputStream(byteArrayOutputStream)) {
            // Create 10,000 entries with similar names to force potential hash collisions
            for (int i = 0; i < 10000; i++) {
                String fileName = "file" + (i % 100) + ".txt";
                ZipArchiveEntry entry = new ZipArchiveEntry(fileName);
                
                // It's crucial to test setting the name in different ways since that's part of the bug report
                if (i % 2 == 0) {
                    entry.setName(fileName);
                }
                
                zipOutputStream.putArchiveEntry(entry);
                // Writing a small content to each file
                zipOutputStream.write("Content".getBytes());
                zipOutputStream.closeArchiveEntry();
            }
        }

        // Validate the output zip file can be read successfully
        byte[] zipBytes = byteArrayOutputStream.toByteArray();
        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(zipBytes);
             ZipInputStream zipInputStream = new ZipInputStream(byteArrayInputStream)) {
            
            // Try extracting every file to see if there's any issue
            int count = 0;
            while (zipInputStream.getNextEntry() != null) {
                count++;
                IOUtils.copy(zipInputStream, new ByteArrayOutputStream());  // Just to test extraction
            }
            // Ensure we read 10,000 entries successfully
            assertTrue("Not all entries were read correctly", count == 10000);
        }
    }
}
