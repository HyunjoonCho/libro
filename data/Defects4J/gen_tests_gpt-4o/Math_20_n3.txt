
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.PopulationSize;
import org.junit.Test;

import static org.junit.Assert.*;

public class CMAESOptimizerBoundsTest {

    @Test
    public void testCMAESOptimizerExceedingBounds() {
        // Define the optimization problem
        CMAESOptimizer optimizer = new CMAESOptimizer(10000, Double.MIN_VALUE, true, 0, 0, null, false, null);

        double[] lowerBounds = new double[]{0.0, 0.0};
        double[] upperBounds = new double[]{1.0, 1.0};

        // Define a simple quadratic function
        ObjectiveFunction objectiveFunction = new ObjectiveFunction(point -> {
            double x = point[0];
            double y = point[1];
            return x * x + y * y;
        });

        // Run optimization
        double[] startPoint = new double[]{0.5, 0.5};
        double[] result = optimizer.optimize(new MaxEval(10000),
                                             objectiveFunction,
                                             GoalType.MINIMIZE,
                                             new CMAESOptimizer.InitialGuess(startPoint),
                                             new PopulationSize(10),
                                             new CMAESOptimizer.SimpleBounds(lowerBounds, upperBounds))
                                   .getPoint();

        // Check if the result violates bounds
        for (int i = 0; i < result.length; i++) {
            assertTrue("Result exceeded lower bounds", result[i] >= lowerBounds[i]);
            assertTrue("Result exceeded upper bounds", result[i] <= upperBounds[i]);
        }
    }
}
