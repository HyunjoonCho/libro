
import org.junit.Test;

import static org.junit.Assert.assertNotNull;

public class ClosureCompilerTest {

    @Test
    public void testPrototypeMethodPreserved() throws Exception {
        // This is a pseudo-code representation as running Closure Compiler usually happens at build time or using CLI.

        // Source JavaScript code to be tested
        String sourceCode = """
            /** @const */
            var foo = {};
            foo.bar = {
             'bar1': function() { console.log('bar1'); }
            }

            /** @constructor */
            function foobar() {}
            foobar.prototype = foo.bar;

            foo.foobar = new foobar;

            console.log(foo.foobar['bar1']);
            """;

        // Pseudo-method to compile and return compiled code. This typically involves running Closure Compiler
        String compiledCode = runClosureCompilerWithAdvancedOptimizations(sourceCode);

        // Check that 'bar1' function still exists in the compiled code
        assertNotNull(compiledCode);
        assert compiledCode.contains("bar1");
    }

    private String runClosureCompilerWithAdvancedOptimizations(String sourceCode) {
        // This method is a placeholder for invoking Closure Compiler.
        // In practice, you may need to execute Closure Compiler from the command line or integrate it as a Maven/Gradle build step.
        return sourceCode; // Should return the result of the Closure Compilation process
    }
}
