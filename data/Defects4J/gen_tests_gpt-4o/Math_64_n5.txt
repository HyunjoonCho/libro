public void testInconsistentResultFromLevenbergMarquardt() {
    LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();
    
    MultivariateVectorFunction model = new MultivariateVectorFunction() {
        public double[] value(double[] point) {
            double[] values = new double[point.length];
            for (int i = 0; i < point.length; i++) {
                values[i] = Math.pow(point[i], 2);
            }
            return values;
        }
    };

    MultivariateMatrixFunction jacobian = new MultivariateMatrixFunction() {
        public double[][] value(double[] point) {
            double[][] jacobian = new double[point.length][point.length];
            for (int i = 0; i < point.length; i++) {
                for (int j = 0; j < point.length; j++) {
                    jacobian[i][j] = (i == j) ? 2 * point[i] : 0;
                }
            }
            return jacobian;
        }
    };

    double[] initialPoint = { 1.0, 1.0 };
    double[] target = { 0.0, 0.0 };
    double[] weights = { 1.0, 1.0 };

    PointVectorValuePair result = optimizer.optimize(100, model, jacobian, target, weights, initialPoint);

    double[] obtainedPoint = result.getPoint();
    double expectedCost = MathUtils.reduceSum(MathUtils.pow(objArrDiff(RealVector.wrap(obtainedPoint).walkInOppositeDirectionAndHaltAndAddInto(realVectorWrap(target)), 2)), (double) 2);
    
    assertEquals(expectedCost, optimizer.computeCost(optimizer.computeResiduals(obtainedPoint)), 1e-6);
}