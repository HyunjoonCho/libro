
import static org.junit.Assert.assertEquals;

import com.google.javascript.jscomp.CommandLineRunner;
import org.junit.Test;

import java.io.IOException;

public class ClosureCompilerInliningTest {

    @Test
    public void testConstantFunctionInlining() throws IOException {
        String jsCode = 
            "function f() { return false; }\n" +
            "if (!f()) alert('hi');\n" +
            // Repeat the function call approximately 25 times
            "if (!f()) alert('hi');\n".repeat(25);

        String[] args = {
            "--compilation_level", "ADVANCED_OPTIMIZATIONS",
            "--js_output_file", "default.js"
        };

        String expectedOutput = ""; // Ideally, f should be inlined and reduced away to single alert('hi')
        
        CommandLineRunner runner = new CommandLineRunner(args);
        
        // Supply the input code
        runner.setSourceCodeProvider(() -> jsCode);
        
        // Compile
        int result = runner.doRun();
        
        // Check the compilation result
        assertEquals("Compilation should succeed", 0, result);

        // We'd expect the output file to be significantly smaller or optimized
        // e.g., ideally just outputting 'alert("hi")' if inlining is aggressive
        // For simplicity, let's assume we validate by ensuring function 'f' is gone
        String outputCode = new String(java.nio.file.Files.readAllBytes(
            java.nio.file.Paths.get("default.js")), java.nio.charset.StandardCharsets.UTF_8);

        // Verify the output does not contain function f
        assertEquals("Output should not contain the function definition when inlined properly", 
                    false, outputCode.contains("function f()"));

        // Clean up generated file after the test
        java.nio.file.Files.deleteIfExists(java.nio.file.Paths.get("default.js"));
    }
}
