
import com.google.javascript.jscomp.CommandLineRunner;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.Result;
import org.junit.Assert;
import org.junit.Test;

public class ClosureCompilerTest {

    @Test
    public void testCatchClauseOptimization() {
        String inputJs = "function getStack() { " +
                "var getErrorObject = function() { " +
                "  try { " +
                "    throw Error(''); " +
                "  } catch(err) { " +
                "    return err; " +
                "  } " +
                "}; " +
                "return getErrorObject().stack; " +
                "} " +
                "window['getStackTrace'] = getStack;";

        CompilerOptions options = new CompilerOptions();
        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT6); 
        options.setLanguageOut(CompilerOptions.LanguageMode.ECMASCRIPT5);
        options.setOptimizationLevel(CompilerOptions.OptimizationLevel.SIMPLE_OPTIMIZATIONS);
        
        com.google.javascript.jscomp.Compiler compiler = new com.google.javascript.jscomp.Compiler();
        Result result = compiler.compile(CommandLineRunner.getDefaultExterns(), CommandLineRunner.getDefaultInputs(inputJs), options);

        String optimizedJs = compiler.toSource();

        // Check if the optimization incorrectly moves the variable out of the scope
        Assert.assertFalse("Incorrect optimization moving catch variable out of scope", 
                           optimizedJs.contains("return a.stack"));
    }
}
