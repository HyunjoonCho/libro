
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;
import org.junit.Test;
import java.util.List;

public class AbstractClassSpyingTest {

    // Example 1: Fake with trivial logic
    public static abstract class UserAccount {
        public abstract List<String> getEmails();
        public abstract void addEmail(String email);
    }

    @Test
    public void testSpyingOnAbstractClass() {
        // Using Mockito to spy on an abstract class
        UserAccount userAccountSpy = spy(UserAccount.class);

        // Trying to stub abstract methods via Mockito
        doNothing().when(userAccountSpy).addEmail(anyString());
        
        // Asserting that method calls work
        userAccountSpy.addEmail("test@example.com");
        
        // Verify the interaction
        verify(userAccountSpy).addEmail("test@example.com");

        // Since abstract classes aren't directly instantiated in Mockito,
        // the logic of combining fields like emails and retrieving them
        // needs to be done manually unless the abstract class provides that logic.
        
        // In this example, without support for abstract classes, 
        // we can't automatically handle calls like getEmails() correctly
        // unless we manually implement the method logic.
    }
}
