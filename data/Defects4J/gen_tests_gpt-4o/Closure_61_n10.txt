
import static org.junit.Assert.*;

import com.google.javascript.jscomp.CompilationLevel;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.Result;
import org.junit.Test;

public class ClosureCompilerTest {

    @Test
    public void testClosureDoesNotRemoveInvocation() {
        Compiler compiler = new Compiler();

        // Set up compiler options for SIMPLE_OPTIMIZATIONS
        CompilerOptions options = new CompilerOptions();
        CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);

        // JavaScript code to test
        String originalCode = 
            "Math.blah = function(test) { test.a = 5; };\n" +
            "var test = new Object();\n" +
            "Math.blah(test);";

        // Compile the code
        Result result = compiler.compile(
            JSSourceFile.fromCode("externs.js", ""),  // Empty external references
            JSSourceFile.fromCode("test.js", originalCode),
            options
        );

        // Check if the expected output still contains the function invocation
        String compiledCode = compiler.toSource();
        assertTrue("Math.blah(test) invocation should not be removed", compiledCode.contains("Math.blah(test);"));

        // Additionally, ensure there are no errors or warnings in the compilation result
        assertTrue("Compilation should be successful", result.success);
        assertEquals("There should be no warnings", 0, result.warnings.length);
    }
}
