
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JSError;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;
import org.junit.Test;

import java.util.List;

import static org.junit.Assert.fail;

public class TypeCheckBugTest {

    @Test
    public void testInterfaceConversionCausesStackOverflow() {
        // Prepare the JS source simulating the erroneous code
        String jsSource = ""
                + "/**\n"
                + " * @interface\n"
                + " */\n"
                + "var OtherType = function() {};\n"
                + "\n"
                + "/**\n"
                + " * @implements {MyType}\n"
                + " * @constructor\n"
                + " */\n"
                + "var MyType = function() {};\n"
                + "\n"
                + "/**\n"
                + " * @type {MyType}\n"
                + " */\n"
                + "var x = /** @type {!OtherType} */ (new Object());\n";

        // Create a new Compiler, which runs type checking
        Compiler compiler = new Compiler();

        // Set compiler options to simulate environment from the bug report
        CompilerOptions options = new CompilerOptions();
        options.setWarningLevel(com.google.javascript.jscomp.DiagnosticGroups.CHECK_TYPES, com.google.javascript.jscomp.CheckLevel.WARNING);

        // Run the compiler with the erroneous JS source
        SourceFile input = SourceFile.fromCode("t.js", jsSource);
        Result result = compiler.compile(SourceFile.fromCode("externs.js", ""), input, options);

        // Check for stack overflow (type checking errors are expected)
        List<JSError> errors = result.errors;
        for (JSError error : errors) {
            if (error.description.contains("isSubtype")) {
                fail("Compilation should fail with type checking errors, not stack overflow.");
            }
        }
    }
}
