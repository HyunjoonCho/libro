
import org.junit.Test;
import static org.junit.Assert.assertArrayEquals;

// Mocking the IOContext class for the sake of the example
class IOContext {

    private byte[] currentBuffer;

    public IOContext(int initialSize) {
        this.currentBuffer = new byte[initialSize];
    }

    public byte[] allocateBuffer(int size) {
        // Simulate allocation strategy which may return a new buffer of the same size
        return new byte[size];
    }

    public void releaseBuffer(byte[] buffer) {
        // Check if the buffer is the same or a newly allocated one
        if (buffer != currentBuffer && buffer.length != currentBuffer.length) {
            throw new IllegalArgumentException("Buffer size mismatch.");
        }
    }
}

public class IOContextTest {

    @Test
    public void testBufferReleaseWithSameSizeAllowed() {
        IOContext ioContext = new IOContext(1024);

        // Allocate buffer of the same size and pretend it's a separate allocation call
        byte[] buffer = ioContext.allocateBuffer(1024);

        try {
            // Should not throw exception even if buffer is a new array with the same size
            ioContext.releaseBuffer(buffer);
        } catch (IllegalArgumentException e) {
            // If there's an exception, the test should fail
            assert false : "Buffer of same size should be allowed even if it's a different instance.";
        }

        // Additional check to ensure the buffer was indeed a separate instance but same size
        assertArrayEquals(new byte[1024], buffer);
    }
}
