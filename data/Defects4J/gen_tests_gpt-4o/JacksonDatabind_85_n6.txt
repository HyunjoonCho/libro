
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;

import java.text.SimpleDateFormat;
import java.util.Date;

import static org.junit.jupiter.api.Assertions.assertEquals;

// Define a class with a date field and a JsonFormat annotation without a custom pattern.
class Event {
    // Apply JsonFormat without a custom pattern. The bug should reset to the ISO standard, ignoring anything set on ObjectMapper by default.
    @JsonFormat
    private Date eventDate;

    public Event(Date eventDate) {
        this.eventDate = eventDate;
    }

    public Date getEventDate() {
        return eventDate;
    }

    public void setEventDate(Date eventDate) {
        this.eventDate = eventDate;
    }
}

public class DateTimeSerializerTest {

    @Test
    public void testDateSerializationRespectsConfiguredFormat() throws JsonProcessingException {
        // Arrange
        ObjectMapper objectMapper = new ObjectMapper();
        // Set a custom date format that we expect to also be used for serialization in absence of a special @JsonFormat pattern.
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        objectMapper.setDateFormat(dateFormat);

        Date date = new Date(0); // Sun, 01 Jan 1970 00:00:00 GMT
        Event event = new Event(date);

        // Act
        String json = objectMapper.writeValueAsString(event);

        // Assert
        String expectedDateString = dateFormat.format(date);
        String expectedJson = String.format("{\"eventDate\":\"%s\"}", expectedDateString);

        assertEquals(expectedJson, json, "Serialized JSON should respect the custom date format.");
    }
}
