
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class TypeIdMappingTest {

    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.WRAPPER_OBJECT, property = "type")
    @JsonSubTypes({
        @JsonSubTypes.Type(value = DerivedClass.class, name = "derived")
    })
    static class BaseClass {
        public String getType() {
            return "base";
        }
    }

    static class DerivedClass extends BaseClass {
        @Override
        public String getType() {
            return "derived";
        }
    }
    
    @Test
    public void testBaseTypeIdResolution() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        
        // Assume we're serializing a BaseClass instance
        BaseClass baseInstance = new BaseClass();
        String baseJson = mapper.writeValueAsString(baseInstance);

        // Deserialize back to BaseClass
        BaseClass deserializedBase = mapper.readValue(baseJson, BaseClass.class);

        // Check if the type id name for base instance leak caused incorrect resolution;
        // In this case, the type should remain consistent
        assertEquals("base", deserializedBase.getType());
    }
}
