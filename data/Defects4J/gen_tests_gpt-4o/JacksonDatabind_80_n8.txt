
import static org.junit.jupiter.api.Assertions.assertThrows;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;
import org.junit.jupiter.api.Test;

public class TypeIdMappingTest {

    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
    static abstract class BaseType {
    }

    static class ConcreteType extends BaseType {
        public int value;

        ConcreteType() {
        }

        ConcreteType(int value) {
            this.value = value;
        }
    }

    static class AnotherConcreteType extends BaseType {
        public String description;

        AnotherConcreteType() {
        }

        AnotherConcreteType(String description) {
            this.description = description;
        }
    }

    @Test
    public void testExtraneousTypeIdMapping() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        
        // Register subtypes with explicit names
        mapper.registerSubtypes(
            new com.fasterxml.jackson.databind.jsontype.NamedType(ConcreteType.class, "Concrete"),
            new com.fasterxml.jackson.databind.jsontype.NamedType(AnotherConcreteType.class, "AnotherConcrete")
        );

        String json = "{ \"type\": \"BaseType\", \"value\": 10 }";

        // Expect an exception since parsing with the base type name should not work if base is not concrete
        assertThrows(InvalidTypeIdException.class, () -> {
            mapper.readValue(json, BaseType.class);
        });
    }
}
