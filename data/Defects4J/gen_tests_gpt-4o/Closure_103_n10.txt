
import com.google.javascript.jscomp.CompilationLevel;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.Result;
import org.junit.Test;
import static org.junit.Assert.*;

public class ClosureCompilerTest {

    @Test
    public void testUnreachableCodeWarning() {
        // Create a new Compiler instance
        Compiler compiler = new Compiler();

        // Set the compiler options
        CompilerOptions options = new CompilerOptions();
        CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);

        // JavaScript input file
        String jsCode = ""
            + "function instanceOf(value, type) {"
            + "    try {"
            + "        // first try built-in test -- if it succeeds, we're golden."
            + "        if (value instanceof type) {"
            + "            return true;"
            + "        }"
            + "    } catch (exception) {"
            + "        if (exception instanceof TypeError) {"
            + "            throw exception;" // indicates that "type" is not a type
            + "        }"
            + "        // Otherwise, assume the exception was caused by "
            + "        // the Firefox 1.0.3 bug. Work around it."
            + "        return (type === Object);"
            + "    }"
            + "}";

        // Compile the JS code
        Result result = compiler.compile(JSSourceFile.fromCode("externs.js", ""), 
                                         JSSourceFile.fromCode("test.js", jsCode), options);

        // Assert that there is a warning for unreachable code
        boolean unreachableCodeWarningPresent = result.warnings.stream()
                .anyMatch(warning -> warning.getType().key.equals("JSC_UNREACHABLE_CODE"));

        assertTrue("Expected a warning for unreachable code", unreachableCodeWarningPresent);
    }
}
