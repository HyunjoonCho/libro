
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.assertEquals;

public class ObjectReaderErrorRecoveryTest {

    private static final String MALFORMED_JSON = "[{\"key\": \"value1\"}, {\"key\": value2\"}, {\"key\": \"value3\"}]";

    @Test
    public void testErrorRecoveryWithReadValues() throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        ObjectReader reader = mapper.readerFor(new TypeReference<List<TestObject>>() {
        });

        try (MappingIterator<TestObject> iterator = reader.readValues(MALFORMED_JSON)) {
            // The first object is correctly parsed
            if (iterator.hasNext()) {
                TestObject obj1 = iterator.next();
                assertEquals("value1", obj1.getKey());
            }

            // The second object parsing will fail due to JsonProcessingException
            if (iterator.hasNext()) {
                try {
                    iterator.next();
                } catch (JsonProcessingException e) {
                    System.out.println("Caught expected JsonProcessingException: " + e.getMessage());
                }
            }

            // Depending on error recovery, the third object might still be parsed or not
            if (iterator.hasNext()) {
                TestObject obj3 = iterator.next();
                assertEquals("value3", obj3.getKey());
            }
        }
    }

    static class TestObject {
        private String key;

        public String getKey() {
            return key;
        }

        public void setKey(String key) {
            this.key = key;
        }
    }
}
