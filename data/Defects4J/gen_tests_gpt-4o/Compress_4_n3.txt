
import java.io.ByteArrayOutputStream;
import java.io.IOException;

import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.junit.Test;

import static org.junit.Assert.*;

public class ArchiveOutputStreamTest {

    @Test
    public void testCallingFinishDirectlyCorruptsOutput() {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutput = new TarArchiveOutputStream(byteArrayOutputStream);

        try {
            // Create a tar entry
            TarArchiveEntry entry = new TarArchiveEntry("test.txt");
            entry.setSize(4);
            tarOutput.putArchiveEntry(entry);
            tarOutput.write("Test".getBytes());
            tarOutput.closeArchiveEntry();

            // Manually call finish before close
            tarOutput.finish();

            // Try to continue writing after finishing
            TarArchiveEntry entry2 = new TarArchiveEntry("test2.txt");
            entry2.setSize(4);

            Exception exception = null;
            try {
                tarOutput.putArchiveEntry(entry2);
                tarOutput.write("Data".getBytes());
                tarOutput.closeArchiveEntry();
            } catch (Exception e) {
                exception = e;
            }
            assertNotNull("Expected exception after finishing the stream prematurely", exception);
        } catch (IOException e) {
            fail("IOException should not occur: " + e.getMessage());
        } finally {
            // Ensure the stream is properly closed in any case
            try {
                tarOutput.close();
            } catch (IOException e) {
                fail("Failed to close tar output stream: " + e.getMessage());
            }
        }
    }
    
}
