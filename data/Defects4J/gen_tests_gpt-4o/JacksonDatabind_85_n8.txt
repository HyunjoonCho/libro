
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.json.JsonMapper;
import org.junit.jupiter.api.Test;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

import static org.junit.jupiter.api.Assertions.assertEquals;

class DateTimeSerializerBaseTest {

    // Sample Bean to be serialized
    static class Event {
        @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ", timezone = "UTC")
        private Date eventDate;

        public Event(Date eventDate) {
            this.eventDate = eventDate;
        }

        public Date getEventDate() {
            return eventDate;
        }

        public void setEventDate(Date eventDate) {
            this.eventDate = eventDate;
        }
    }

    @Test
    public void testCustomDateFormatPreservation() throws Exception {
        // Custom Date
        Date date = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").parse("2023-10-01T12:00:00.000+0000");

        // Custom Date Format
        SimpleDateFormat customDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        customDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));

        // Mapper Setup
        ObjectMapper mapper = JsonMapper.builder()
                .defaultDateFormat(customDateFormat)
                .enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
                .build();

        Event event = new Event(date);

        // Serialize Event
        String json = mapper.writeValueAsString(event);

        // Expected eventDate string
        String expectedDateStr = "2023-10-01T12:00:00.000+0000"; // Format from @JsonFormat

        assertEquals("{\"eventDate\":\"" + expectedDateStr + "\"}", json, "Date format should match the format specified in @JsonFormat");
    }
}
