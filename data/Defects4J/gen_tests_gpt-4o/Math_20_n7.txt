
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.math3.analysis.MultivariateFunction;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.SimpleBounds;
import org.apache.commons.math3.optim.InitialGuess;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.junit.Test;
import static org.junit.Assert.*;

public class CMAESOptimizerBoundsTest {

    @Test
    public void testCMAESOptimizerRespectsBounds() {
        // Define a simple quadratic objective function
        MultivariateFunction objectiveFunction = point -> {
            double sum = 0.0;
            for (double x : point) {
                sum += x * x;
            }
            return sum;
        };

        // Set bounds for the parameters, e.g., [0, 10] for each dimension
        double[] lowerBounds = {0, 0};
        double[] upperBounds = {10, 10};

        // Initial guess within the bounds
        double[] startPoint = {5, 5};

        // Instantiate the optimizer
        CMAESOptimizer optimizer = new CMAESOptimizer(
                10000, // max number of function evaluations
                1e-9,  // stopping criterion for optimization precision
                true,  // allow early stop in case of precision issues
                0,     // checkFeasableCount set to zero as stated in the bug report
                0,     // an arbitrary random seed
                null,  // no custom random generator
                false, // does not output statistics
                new CMAESOptimizer.Sigma(new double[]{0.5, 0.5})
        );

        // Perform the optimization
        PointValuePair result = optimizer.optimize(
                new MaxEval(10000),
                new CMAESOptimizer.PopulationSize(5),
                new InitialGuess(startPoint),
                new org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction(objectiveFunction),
                GoalType.MINIMIZE,
                new SimpleBounds(lowerBounds, upperBounds)
        );

        // Check that the optimized point is within bounds
        double[] optimizedPoint = result.getPoint();
        for (int i = 0; i < optimizedPoint.length; i++) {
            assertTrue("Parameter " + i + " is out of bounds", 
                        optimizedPoint[i] >= lowerBounds[i] && optimizedPoint[i] <= upperBounds[i]);
        }
    }
}
