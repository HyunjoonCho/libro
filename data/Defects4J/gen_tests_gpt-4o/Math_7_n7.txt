
import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;
import org.apache.commons.math3.ode.FirstOrderIntegrator;
import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;
import org.apache.commons.math3.ode.events.EventHandler;
import org.junit.Test;
import static org.junit.Assert.*;

public class ODEEventTest {

    @Test
    public void testResetStateEvent() {
        FirstOrderIntegrator integrator = new DormandPrince853Integrator(1.0e-8, 1.0, 1.0e-10, 1.0e-10);
        double[] yStart = {-0.5};

        TestEquation equations = new TestEquation();
        ResetEvent eventWithReset = new ResetEvent();
        InactiveEvent unrelatedEvent = new InactiveEvent();

        integrator.addEventHandler(eventWithReset, 1.0, 1.0e-6, 100);
        integrator.addEventHandler(unrelatedEvent, 1.0, 1.0e-6, 100);

        integrator.integrate(equations, 0.0, yStart, 5.0, yStart);

        // Ensure the unrelated event state is correctly updated even when a reset state event is triggered
        assertTrue("The unrelated event state should have been updated correctly.", unrelatedEvent.wasCalled());
        assertTrue("The event with reset should have been triggered.", eventWithReset.wasResetCalled());
    }

    private static class TestEquation implements FirstOrderDifferentialEquations {

        @Override
        public int getDimension() {
            return 1;
        }

        @Override
        public void computeDerivatives(double t, double[] y, double[] yDot) {
            yDot[0] = y[0] * (1 - y[0] * y[0]); // Simple logistic-like equation
        }
    }

    private static class ResetEvent implements EventHandler {
        private boolean resetCalled = false;

        @Override
        public double g(double t, double[] y) {
            return y[0] + 0.75; // Triggers reset when y[0] is -0.75
        }

        @Override
        public EventHandler.Action eventOccurred(double t, double[] y, boolean increasing) {
            resetCalled = true;
            return EventHandler.Action.RESET_STATE;
        }

        @Override
        public void resetState(double t, double[] y) {
            y[0] = 0.0;
        }

        public boolean wasResetCalled() {
            return resetCalled;
        }
    }

    private static class InactiveEvent implements EventHandler {
        private boolean called = false;

        @Override
        public double g(double t, double[] y) {
            called = true;
            return y[0] - 1.0; // Would typically trigger when reaching y[0] == 1.0, but that shouldn't happen here.
        }

        @Override
        public EventHandler.Action eventOccurred(double t, double[] y, boolean increasing) {
            return EventHandler.Action.CONTINUE;
        }

        @Override
        public void resetState(double t, double[] y) {
            // No operation needed for this example
        }

        public boolean wasCalled() {
            return called;
        }
    }
}
