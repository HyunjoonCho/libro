
import org.joda.time.DateTimeFieldType;
import org.joda.time.Partial;
import org.junit.Test;

import static org.junit.Assert.*;

public class PartialTest {

    @Test
    public void testDuplicateFieldTypesException() {
        try {
            // This should throw an exception due to duplicate field types
            new Partial(new DateTimeFieldType[] { DateTimeFieldType.clockhourOfDay(), DateTimeFieldType.hourOfDay() }, new int[] { 1, 1 });
            fail("Expected IllegalArgumentException due to duplicate field types");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("Types array must not contain duplicate"));
        }
    }

    @Test
    public void testConstructingInvalidPartialWithMethod() {
        // Constructing partials using with method should not be allowed if it results in duplicate field types
        Partial partial = new Partial(DateTimeFieldType.clockhourOfDay(), 1).with(DateTimeFieldType.hourOfDay(), 1);
        
        // Verifying the constructed partial
        assertEquals(1, partial.get(DateTimeFieldType.clockhourOfDay()));
        assertEquals(1, partial.get(DateTimeFieldType.hourOfDay()));
    }

    @Test
    public void testIsEqualMethodThrowsException() {
        try {
            Partial partial1 = new Partial(DateTimeFieldType.clockhourOfDay(), 1).with(DateTimeFieldType.hourOfDay(), 1);
            Partial partial2 = new Partial(DateTimeFieldType.hourOfDay(), 1).with(DateTimeFieldType.clockhourOfDay(), 1);

            // This should throw an exception because the field types do not match
            partial1.isEqual(partial2);
            fail("Expected IllegalArgumentException due to non-matching field types");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("Objects must have matching field types"));
        }
    }
}
