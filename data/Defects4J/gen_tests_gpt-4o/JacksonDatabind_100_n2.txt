
import com.fasterxml.jackson.core.Base64Variants;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.TextNode;
import com.fasterxml.jackson.databind.node.TreeTraversingParser;
import org.junit.Test;

import static org.junit.Assert.assertArrayEquals;

public class TreeTraversingParserTest {

    @Test
    public void testBase64VariantHandling() throws Exception {
        // Use the URL safe variant for test
        com.fasterxml.jackson.core.Base64Variant urlSafeBase64Variant = Base64Variants.MODIFIED_FOR_URL;

        // Example base64 encoding using URL safe variant
        // Byte array: {1, 2, 3, 4}
        String encodedUrlSafeBase64 = "AQIDBA==";

        // Create a TextNode with URL safe encoding
        TextNode textNode = new TextNode(encodedUrlSafeBase64);
        
        // Embed it within a JSON structure if needed
        ObjectMapper mapper = new ObjectMapper();
        JsonNode jsonNode = mapper.createObjectNode().set("binary", textNode);

        // Use TreeTraversingParser to parse the TextNode
        TreeTraversingParser parser = new TreeTraversingParser(jsonNode);

        // Move to the "binary" field
        parser.nextToken();
        parser.nextToken();

        // Parse binary data using specified Base64 variant
        byte[] expectedBinaryData = new byte[]{1, 2, 3, 4};
        byte[] actualBinaryData = parser.getBinaryValue(urlSafeBase64Variant);

        // Verify that the result matches the expected byte array when using the custom Base64 variant
        assertArrayEquals("The parser should honor the specified Base64Variant and decode as expected.",
                expectedBinaryData, actualBinaryData);
    }
}
