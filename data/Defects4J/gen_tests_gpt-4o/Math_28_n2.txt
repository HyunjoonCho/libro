public void testSimplexSolverUnboundedSolutionException() {
    // Configuration A: Fewer variables
    final int ENTITIES_COUNT_FEW = 2;
    testSimplexSolver(ENTITIES_COUNT_FEW, false);

    // Configuration B: More variables
    final int ENTITIES_COUNT_MANY = 15;
    testSimplexSolver(ENTITIES_COUNT_MANY, true);
}

private void testSimplexSolver(int entitiesCount, boolean expectException) {
    SimplexSolver solver = new SimplexSolver();
    
    // Objective function: min(1*t + 0*L)
    LinearObjectiveFunction objectiveFunction = new LinearObjectiveFunction(
            new double[entitiesCount + 1], 0);
    objectiveFunction.getCoefficients()[0] = 1.0; // 1*t
    for (int i = 1; i <= entitiesCount; i++) {
        objectiveFunction.getCoefficients()[i] = 0.0; // 0*L
    }
    
    List<LinearConstraint> constraints = new ArrayList<>();
    
    for (int r = 0; r < entitiesCount; r++) {
        // Constraint: -q(r) + QL >= 0
        double[] qL = new double[entitiesCount + 1];
        qL[0] = -q(r);
        for (int i = 1; i <= entitiesCount; i++) {
            qL[i] = Q(r, i);
        }
        constraints.add(new LinearConstraint(qL, Relationship.GEQ, 0.0));
        
        // Constraint: x(r)t - XL >= 0
        double[] xLK = new double[entitiesCount + 1];
        xLK[0] = x(r);
        for (int i = 1; i <= entitiesCount; i++) {
            xLK[i] = -X(r, i);
        }
        constraints.add(new LinearConstraint(xLK, Relationship.GEQ, 0.0));
    }
    
    // Constraint: L >= 0
    for (int i = 1; i <= entitiesCount; i++) {
        double[] lPositive = new double[entitiesCount + 1];
        lPositive[i] = 1.0;
        constraints.add(new LinearConstraint(lPositive, Relationship.GEQ, 0.0));
    }
    
    try {
        solver.optimize(objectiveFunction, new LinearConstraintSet(constraints), GoalType.MINIMIZE, false);
        if (expectException) {
            fail("Expected UnboundedSolutionException for " + entitiesCount + " entities, but none was thrown.");
        }
    } catch (UnboundedSolutionException e) {
        if (!expectException) {
            fail("Did not expect UnboundedSolutionException for " + entitiesCount + " entities, but one was thrown.");
        }
    }
}

private double q(int r) {
    // Replace with actual logic for q
    return 0.0;
}

private double Q(int r, int i) {
    // Replace with actual logic for Q
    return 0.0;
}

private double x(int r) {
    // Replace with actual logic for x
    return 0.0;
}

private double X(int r, int i) {
    // Replace with actual logic for X
    return 0.0;
}