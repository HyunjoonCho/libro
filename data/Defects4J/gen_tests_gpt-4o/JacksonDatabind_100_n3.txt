
import com.fasterxml.jackson.core.Base64Variant;
import com.fasterxml.jackson.core.Base64Variants;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.TextNode;
import com.fasterxml.jackson.databind.node.TreeTraversingParser;
import org.junit.Test;

import java.util.Base64;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.fail;

public class TreeTraversingParserTest {

    @Test
    public void testBase64VariantSupportInTreeTraversingParser() throws Exception {
        // Custom Base64 variant that uses URL-safe characters
        Base64Variant customVariant = Base64Variants.MODIFIED_FOR_URL;

        // Original data
        byte[] originalData = "test-data".getBytes("UTF-8");
        // Encode to Base64 using the custom variant
        String encodedData = customVariant.encode(originalData);

        // Create a TextNode with Base64 encoded data
        TextNode textNode = new TextNode(encodedData);

        // Parse through TreeTraversingParser
        TreeTraversingParser parser = new TreeTraversingParser(textNode);
        
        // Move to the value, assuming the node parser correctly points to the value
        parser.nextToken();

        // Expected: should decode the data correctly using the custom variant
        try {
            byte[] parsedData = parser.getBinaryValue(customVariant);
            assertArrayEquals("Decoded byte array should match original data", originalData, parsedData);
        } catch (Exception e) {
            fail("Failed to decode Base64 using the specified variant: " + e.getMessage());
        }
    }
}
