
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;

import com.google.javascript.jscomp.CompilationLevel;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;
import org.junit.Test;

public class SuperRenamingTest {

    @Test
    public void testSuperNotRenamed() {
        // JavaScript code with $super usage
        String jsCode = 
            "var MyObject = Class.create({\n" +
            "  initialize: function($super, name) {\n" +
            "    $super();\n" +
            "    this.name = name;\n" +
            "  },\n" +
            "  sayHello: function() {\n" +
            "    alert('Hello ' + this.name);\n" +
            "  }\n" +
            "});";

        // Expected output pattern where $super is not renamed during the compilation
        String expectedOutputPattern = "\\$super";

        // Set up the compiler
        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        
        // Set optimization level to advanced
        CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);

        // Compile the code
        SourceFile input = SourceFile.fromCode("test.js", jsCode);
        SourceFile externs = SourceFile.fromCode("externs.js", "");
        Result result = compiler.compile(externs, input, options);

        // Ensure compilation was successful
        assertTrue(result.success);

        // Get compiled code
        String compiledCode = compiler.toSource();

        // Verify that $super is not renamed
        assertTrue("The $super identifier should not be renamed", compiledCode.contains("$super"));
        assertFalse("Compiled code must not rename $super to $super$$", compiledCode.matches(".*\\$super\\$\\$.*"));
    }
}
