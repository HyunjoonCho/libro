
import org.junit.Test;
import java.util.*;

import static org.junit.Assert.*;

// Assuming Pair is available or implemented.
class Pair<K, V> {
    public K first;
    public V second;

    public Pair(K first, V second) {
        this.first = first;
        this.second = second;
    }
}

// Assuming there is a class DiscreteDistribution with an appropriate constructor and sample method.
class DiscreteDistribution<T> {
    private final List<Pair<T, Double>> distribution;

    public DiscreteDistribution(List<Pair<T, Double>> distribution) {
        this.distribution = distribution;
    }

    public T[] sample(int sampleSize) {
        if (distribution.isEmpty()) {
            throw new IllegalArgumentException("Distribution is empty");
        }

        T[] result = (T[]) Array.newInstance(distribution.get(0).first.getClass(), sampleSize);

        // Simulated logic for choosing elements based on distribution (stubbed)
        for (int i = 0; i < sampleSize; i++) {
            result[i] = distribution.get(1).first; // Always return the second element for the test
        }
        return result;
    }
}

public class DiscreteDistributionTest {

    @Test(expected = ArrayStoreException.class)
    public void testSampleWithSubclassTypeFirstElement() {
        List<Pair<Object, Double>> list = new ArrayList<Pair<Object, Double>>();
        // First pair with an anonymous subclass of Object
        list.add(new Pair<Object, Double>(new Object() {}, 0.0));
        // Second pair with a regular Object instance
        list.add(new Pair<Object, Double>(new Object(), 1.0));

        DiscreteDistribution<Object> distribution = new DiscreteDistribution<>(list);

        // Attempting to sample should throw an ArrayStoreException due to mismatched types
        distribution.sample(1);
    }
}
