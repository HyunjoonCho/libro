public void testMockitoSpyingOnAbstractClasses() {
    abstract class FakeUserAccount implements UserAccount {
        private final List<String> emails = new ArrayList<>();

        @Override public void addEmail(String email) {
            emails.add(email);
        }
        @Override public List<String> getEmails() {
            return Collections.unmodifiableList(emails);
        }
    }

    abstract class MockAccountService implements AccountService {
        @Override public void getAccount(String id, AsyncCallback<UserAccount> callback) {
            callback.onSuccess(getAccount(id));
        }
        abstract UserAccount getAccount(String id);
    }

    FakeUserAccount userAccount = Mockito.mock(FakeUserAccount.class, Mockito.CALLS_REAL_METHODS);
    MockAccountService service = Mockito.mock(MockAccountService.class, Mockito.CALLS_REAL_METHODS);

    UserAccount dummyAccount = Mockito.mock(UserAccount.class);
    Mockito.when(service.getAccount("id")).thenReturn(dummyAccount);

    userAccount.addEmail("test@example.com");
    assertEquals(1, userAccount.getEmails().size());
    assertEquals("test@example.com", userAccount.getEmails().get(0));

    service.getAccount("id", new AsyncCallback<UserAccount>() {
        @Override 
        public void onSuccess(UserAccount account) {
            assertEquals(dummyAccount, account);
        }
        
        @Override 
        public void onFailure(Throwable caught) {
            fail("Callback should not fail");
        }
    });
}