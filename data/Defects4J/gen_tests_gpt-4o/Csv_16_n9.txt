
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.junit.Test;

import java.io.BufferedReader;
import java.io.StringReader;
import java.util.Iterator;

import static org.junit.Assert.assertEquals;

public class CSVParserTest {

    @Test
    public void testMultiIteratorWithPeekIssue() throws Exception {
        String fiveRows = "1\n2\n3\n4\n5\n";

        CSVParser parser = new CSVParser(new BufferedReader(new StringReader(fiveRows)), CSVFormat.DEFAULT);

        // Part 1: First iteration with breaking after two records
        Iterator<CSVRecord> iter1 = parser.iterator();
        iter1.next(); // Consume 1
        iter1.next(); // Consume 2

        // Part 2: Create a new iterator, peek with hasNext and verify consumption issue
        Iterator<CSVRecord> iter2 = parser.iterator();
        boolean hasNext = iter2.hasNext();
        assertEquals(true, hasNext); // Ensure hasNext() is true

        if (hasNext) {
            CSVRecord record = iter2.next(); 
            String value = record.get(0);
            assertEquals("3", value); // Expecting "3", but it should be "4" if issue exists
        }

        // Ensure the inconsistency in element consumption
        int recordNumber = 3;
        while (iter2.hasNext()) {
            CSVRecord record = iter2.next();
            recordNumber++;
            String value = record.get(0);
            assertEquals(Integer.toString(recordNumber), value); // Expecting sequential numbers, but it skips if issue exists
        }
    }
}
