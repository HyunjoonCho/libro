
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.util.StdDateFormat;
import org.junit.Test;

import java.text.ParseException;
import java.util.Date;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

public class StdDateFormatLenientTest {

    @Test
    public void testLenientDateParsing() {
        ObjectMapper objectMapper = new ObjectMapper();

        // This is the date string with an invalid day (January 32)
        String dateString = "2015-01-32";

        // Parse date using ObjectMapper with default behavior
        try {
            Date date = objectMapper.readValue("\"" + dateString + "\"", Date.class);
            // Expecting the parsed date to roll over to 2015-02-01 due to lenient parsing
            assertEquals(new StdDateFormat().parse("2015-02-01"), date);
        } catch (Exception e) {
            fail("Parsing failed: " + e.getMessage());
        }
    }

    @Test
    public void testNonLenientDateParsing() {
        ObjectMapper objectMapper = new ObjectMapper();

        // Attempt to use StdDateFormat with lenient set to false
        StdDateFormat dateFormat = (StdDateFormat) StdDateFormat.instance.clone();
        dateFormat.setLenient(false);

        objectMapper.setDateFormat(dateFormat);

        String dateString = "2015-01-32";

        try {
            // This should throw an exception since the date is invalid in non-lenient mode
            objectMapper.readValue("\"" + dateString + "\"", Date.class);
            fail("Expected ParseException due to non-lenient parsing");
        } catch (ParseException e) {
            // Expected exception
        } catch (Exception e) {
            fail("Expected ParseException, but got " + e.getClass().getSimpleName());
        }
    }
}
