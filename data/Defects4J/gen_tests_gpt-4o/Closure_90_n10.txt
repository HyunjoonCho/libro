
import com.google.javascript.jscomp.CompilationLevel;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;

import java.util.Arrays;

public class BugReproducingTest {

    public static void main(String[] args) {
        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);

        // Java source code to compile
        String jsCode = "/**\n" +
                " * @this {bug.Thing}\n" +
                " */\n" +
                "bug.sharedMethod = function() {};\n" +
                "\n" +
                "/**\n" +
                " * @constructor\n" +
                " */\n" +
                "bug.A = function() {};\n" +
                "\n" +
                "/**\n" +
                " * @constructor\n" +
                " */\n" +
                "bug.B = function() {};\n" +
                "\n" +
                "/**\n" +
                " * @type {bug.A|bug.B}\n" +
                " */\n" +
                "bug.Thing = goog.typedef;";

        // Compile the code
        Result result = compiler.compile(
                Arrays.asList(SourceFile.fromCode("externs.js", "")),
                Arrays.asList(SourceFile.fromCode("input.js", jsCode)),
                options
        );

        // Output the warnings
        Arrays.stream(result.warnings).forEach(System.out::println);

        // Here we assert that there should not be any warnings for @this with typedef.
        assert result.warnings.length == 0 : "Test failed due to unexpected warning.";
    }
}
