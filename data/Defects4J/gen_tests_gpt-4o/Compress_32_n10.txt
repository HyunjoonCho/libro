
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.utils.IOUtils;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;

import static org.junit.Assert.assertEquals;

public class LargeUIDTarTest {

    @Test
    public void testLargeUIDParsing() throws IOException {
        byte[] tarFileContent = createTarWithLargeUID();
        ByteArrayInputStream bais = new ByteArrayInputStream(tarFileContent);
        TarArchiveInputStream tais = new TarArchiveInputStream(bais);

        TarArchiveEntry entry = tais.getNextTarEntry();
        assertEquals("expected-filename", entry.getName());
        assertEquals(429496729L, entry.getLongUserId());
    }

    private byte[] createTarWithLargeUID() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try (OutputStream out = baos) {
            writeEntry(out, "expected-filename", 429496729L);
        }
        return baos.toByteArray();
    }

    private void writeEntry(OutputStream out, String name, long uid) throws IOException {
        // Manually crafting a header for tar entry with the large UID/PAX headers
        String header = "30 uid=" + uid + "\n";
        out.write(header.getBytes(StandardCharsets.US_ASCII));

        // Add content of the tar entry, if any (e.g., an empty one)
        byte[] content = new byte[0];
        out.write(content);

        // Properly pad the entry to 512 bytes - typical tar block size
        int padding = 512 - (header.length() % 512);
        if (padding > 0) {
            out.write(new byte[padding]);
        }
    }
}
