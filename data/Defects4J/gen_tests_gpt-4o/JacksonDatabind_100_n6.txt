
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.Base64Variant;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.TextNode;
import com.fasterxml.jackson.databind.node.TreeTraversingParser;
import org.junit.Test;
import static org.junit.Assert.assertArrayEquals;

public class TreeTraversingParserTest {

    @Test
    public void testTreeTraversingParserBase64Variant() throws Exception {
        // Define a custom Base64Variant for testing
        final Base64Variant customBase64Variant = new Base64Variant(Base64Variant.MIME, "01", false, '=', 76);

        // Base64 encoded data with custom variant (1 and 0 instead of standard A-Z, a-z, 0-9, +, /)
        String customEncodedText = "010010"; // This would correspond to some specific binary data

        // The expected decoded byte array
        byte[] expectedData = new byte[]{...}; // This should be the actual bytes corresponding to the customEncodedText

        // Create a JSON node with the base64 encoded text
        TextNode textNode = new TextNode(customEncodedText);

        // Use TreeTraversingParser to parse the node
        JsonFactory jsonFactory = new JsonFactory();
        TreeTraversingParser parser = new TreeTraversingParser(textNode, jsonFactory);

        // Move parser to parse Binary value
        parser.setCodec(new ObjectMapper());
        parser.nextToken();

        // Retrieve the binary value using the non-default Base64Variant; expecting this to consider customBase64Variant.
        byte[] resultData = parser.getBinaryValue(customBase64Variant);

        // Assert that the parsed binary data matches the expected data
        // This should fail currently due to the bug as it will use the default Base64 variant,
        // not matching the custom Base64 variant-decoded result we expect
        assertArrayEquals(expectedData, resultData);
    }
}
