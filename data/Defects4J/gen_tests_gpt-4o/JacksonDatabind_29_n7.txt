
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;
import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;
import org.junit.Test;

import static org.junit.Assert.fail;

public class ExternalTypeIdWithNullTest {

    @JsonTypeInfo(use = JsonTypeInfo.Id.NONE, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = "type")
    static class BaseEntity {
        public String data;

        public BaseEntity() { }

        public BaseEntity(String data) {
            this.data = data;
        }
    }

    static class SubEntity extends BaseEntity {
        public SubEntity() { }

        public SubEntity(String data) {
            super(data);
        }
    }

    @Test
    public void testNullTypeIdWithExternalTypeInfo() {
        ObjectMapper mapper = new ObjectMapper();
        StdTypeResolverBuilder typeResolverBuilder = new StdTypeResolverBuilder(JsonTypeInfo.Id.CLASS, JsonTypeInfo.As.EXTERNAL_PROPERTY);
        typeResolverBuilder.init(JsonTypeInfo.Id.CLASS, null);
        typeResolverBuilder.inclusion(JsonTypeInfo.As.EXTERNAL_PROPERTY);

        mapper.setDefaultTyping(typeResolverBuilder);

        // JSON input with a missing type id
        String json = "{ \"data\": \"some data\" }";

        try {
            // Attempting to deserialize with missing type id
            BaseEntity entity = mapper.readValue(json, BaseEntity.class);
            fail("Expected an InvalidTypeIdException due to missing type id");
        } catch (InvalidTypeIdException e) {
            // Test passes as the exception is expected
            System.out.println("Caught expected exception: " + e.getMessage());
        }
    }
}
