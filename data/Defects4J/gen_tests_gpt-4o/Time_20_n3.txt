
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.junit.Test;

import java.util.Set;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

public class JodaDateTimeZoneTesterTest {

    private static final DateTimeFormatter formatter = DateTimeFormat.forPattern("MM/dd/yyyy HH:mm:ss.SSS ZZZ");

    private static String convertDateTimeToFormattedString(DateTime dateTime) {
        return formatter.print(dateTime);
    }

    private static DateTime parseStringToDateTime(String formattedDateTime) {
        return formatter.parseDateTime(formattedDateTime);
    }

    private static void testDateTimeFormatter(DateTime dateTime, String timeZone) {
        final String dateTimeZoneId = dateTime.getZone().getID();

        try {
            DateTime convertedDateTime = parseStringToDateTime(convertDateTimeToFormattedString(dateTime));

            if (!dateTime.equals(convertedDateTime)) {
                System.out.println("Formatter failed for time zone ID: " + dateTimeZoneId +
                        " converted it to: " + convertedDateTime.getZone().getID());
                fail("DateTime conversion failed for time zone: " + dateTimeZoneId);
            }
        } catch (IllegalArgumentException iae) {
            System.out.println("Formatter threw exception for time zone id: " + dateTimeZoneId);
            fail("Formatter threw an exception for time zone: " + dateTimeZoneId);
        }
    }

    @Test
    public void testJodaTimeZones() {
        Set<String> timeZones = DateTimeZone.getAvailableIDs();

        for (String timeZone : timeZones) {
            DateTime dateTime = DateTime.now().withZone(DateTimeZone.forID(timeZone));
            testDateTimeFormatter(dateTime, timeZone);
        }

        System.out.println("Completed testing time zones.");
    }
}
