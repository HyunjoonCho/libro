
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
import com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer;
import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;
import com.fasterxml.jackson.databind.type.TypeFactory;
import org.junit.jupiter.api.Test;

import java.io.IOException;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class GenericTypeDeserializationTest {

    static class Container<T> {
        public T value;
    }

    static class StringContainer extends Container<String> {}

    public static class CustomTypeIdResolver extends TypeIdResolverBase {

        @Override
        public JavaType typeFromId(DatabindContext context, String id) {
            if ("stringContainer".equals(id)) {
                // Intentionally return a specific JavaType with generics
                return TypeFactory.defaultInstance().constructParametricType(Container.class, String.class);
            }
            return null;
        }

        @Override
        public String idFromValue(Object value) {
            return null; // Not used in this test
        }

        @Override
        public String idFromValueAndType(Object value, Class<?> suggestedType) {
            return null;
        }

        @Override
        public Id getMechanism() {
            return Id.CUSTOM;
        }
    }

    @Test
    public void testGenericTypeDeserialization() throws IOException {
        ObjectMapper mapper = new ObjectMapper();

        // Register custom type id resolver
        SimpleModule module = new SimpleModule();
        module.addDeserializer(Container.class, new ContainerDeserializer());
        mapper.registerModule(module);

        // Deserialize JSON
        String json = "{\"@type\": \"stringContainer\", \"value\": \"Hello, World!\"}";
        Container<?> container = mapper.readValue(json, Container.class);

        // Check the type and content of the 'value' field
        assertEquals(String.class, container.value.getClass(), "Expected value to be of type String");
        assertEquals("Hello, World!", container.value, "Expected the deserialized value to be 'Hello, World!'");
    }

    // Custom deserializer to handle type based on the @type property
    public static class ContainerDeserializer extends TypeDeserializer {
        public ContainerDeserializer() {
            super(null);
        }

        @Override
        public JsonTypeInfo.As getTypeInclusion() {
            return JsonTypeInfo.As.PROPERTY;
        }

        @Override
        public TypeDeserializer forProperty(BeanProperty prop) {
            return this;
        }

        @Override
        public Object deserializeTypedFromObject(JsonParser p, DeserializationContext ctxt) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public Object deserializeTypedFromArray(JsonParser p, DeserializationContext ctxt) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public Object deserializeTypedFromScalar(JsonParser p, DeserializationContext ctxt) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public Object deserializeTypedFromAny(JsonParser p, DeserializationContext ctxt) throws IOException {
            throw new UnsupportedOperationException();
        }
    }
}
