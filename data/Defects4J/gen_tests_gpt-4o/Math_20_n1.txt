
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.InitialGuess;
import org.apache.commons.math3.optim.SimpleBounds;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.random.JDKRandomGenerator;
import org.apache.commons.math3.analysis.MultivariateFunction;

import static org.junit.Assert.assertTrue;

import org.junit.Test;

public class CMAESOptimizerTest {

    @Test
    public void testCMAESOptimizerRespectsBounds() {
        final MultivariateFunction objectiveFunction = point -> {
            // A simple quadratic objective function
            double sum = 0;
            for (double x : point) {
                sum += x * x;
            }
            return sum;
        };

        CMAESOptimizer optimizer = new CMAESOptimizer(
                1000, // maxIterations
                1e-9, // stopFitness
                true, // isActiveCMA
                0, // diagonalOnly
                0, // checkFeasableCount
                0, // randomGenerator seed
                false, // generateStatistics
                new JDKRandomGenerator());

        double[] initGuess = {5, 5};
        double[] lowerBounds = {0, 0};
        double[] upperBounds = {1, 1};

        CMAESOptimizer.PopulationSize popSize = new CMAESOptimizer.PopulationSize(5);

        double[] result = optimizer.optimize(
                new MaxEval(10000),
                popSize,
                GoalType.MINIMIZE,
                new InitialGuess(initGuess),
                new ObjectiveFunction(objectiveFunction),
                SimpleBounds.unbounded(2),
                new SimpleBounds(lowerBounds, upperBounds)
        ).getPoint();

        assertTrue("Result should respect lower bounds",
                result[0] >= lowerBounds[0] && result[1] >= lowerBounds[1]);
        assertTrue("Result should respect upper bounds",
                result[0] <= upperBounds[0] && result[1] <= upperBounds[1]);
    }
}
