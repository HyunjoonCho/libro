
import org.apache.commons.compress.archivers.zip.*;
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.zip.ZipException;

import static org.junit.Assert.fail;

public class ZipFileTest {

    @Test
    public void testZipFileCreationWithManyEntries() throws IOException {
        // The number of entries to test
        int numberOfEntries = 1000;

        // Create a byte array output stream to store the generated zip file
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

        try (ArchiveOutputStream zipOutputStream = new ZipArchiveOutputStream(byteArrayOutputStream)) {
            for (int i = 0; i < numberOfEntries; i++) {
                // Create similarly-named entries to increase chance of hash collision
                String entryName = "file" + (i % 10) + ".txt";
                ArchiveEntry entry = new ZipArchiveEntry(entryName);
                zipOutputStream.putArchiveEntry(entry);
                byte[] content = ("Content for " + entryName).getBytes();
                zipOutputStream.write(content);
                zipOutputStream.closeArchiveEntry();
            }
        }

        // Attempt to read back the zip to see if unzipping is successful or not
        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
             ZipArchiveInputStream zipInputStream = new ZipArchiveInputStream(byteArrayInputStream)) {
            while (zipInputStream.getNextZipEntry() != null) {
                // Simply read through the entries
            }
        } catch (ZipException e) {
            // If there's a ZipException, it confirms the corruption issue described
            fail("Zip file was corrupted and could not be read: " + e.getMessage());
        }
    }
}
