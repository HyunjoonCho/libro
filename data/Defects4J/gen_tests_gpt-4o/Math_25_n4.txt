
import org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer;
import org.apache.commons.math3.fitting.HarmonicFitter;
import org.apache.commons.math3.fitting.WeightedObservedPoint;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.fail;

public class HarmonicFitterTest {

    @Test
    public void testParameterGuesserFailsForAmplitude() {
        // Initialize optimizer and fitter
        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();
        HarmonicFitter fitter = new HarmonicFitter(optimizer);

        // Set up points that are expected to cause amplitude calculation failure
        List<WeightedObservedPoint> points = new ArrayList<>();
        points.add(new WeightedObservedPoint(1.0, 0.0, 0.0)); 
        points.add(new WeightedObservedPoint(1.0, Math.PI / 2, 0.0));
        points.add(new WeightedObservedPoint(1.0, Math.PI, 0.0));
        points.add(new WeightedObservedPoint(1.0, 3 * Math.PI / 2, 0.0));
        points.add(new WeightedObservedPoint(1.0, 2 * Math.PI, 0.0));
        
        // Input points into fitter
        for (WeightedObservedPoint point : points) {
            fitter.addObservedPoint(point);
        }
        
        // Create the ParameterGuesser and attempt to compute initial guess
        try {
            HarmonicFitter.ParameterGuesser guesser = new HarmonicFitter.ParameterGuesser(points);
            double[] guessedParameters = guesser.guess();

            // Check amplitude is positive, otherwise failed
            if (guessedParameters[0] <= 0) {
                fail("Failed to compute a sensible amplitude, got: " + guessedParameters[0]);
            }

        } catch (Exception e) {
            fail("Exception occurred during parameter guessing: " + e.getMessage());
        }
    }
}
