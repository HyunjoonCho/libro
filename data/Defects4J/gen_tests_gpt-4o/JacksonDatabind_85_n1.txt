
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.junit.jupiter.api.Test;

import java.text.SimpleDateFormat;
import java.util.Date;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class DateTimeSerializerTest {

    static class Event {
        @JsonFormat
        // Not specifying any pattern to make it default to the configuration
        private Date timestamp;

        public Event(Date timestamp) {
            this.timestamp = timestamp;
        }

        public Date getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(Date timestamp) {
            this.timestamp = timestamp;
        }
    }

    @Test
    public void testDateTimeSerializerBaseUsesConfiguredDateFormat() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        // Disable default timestamps as nanoseconds since epoch
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        // Set up custom date format for testing
        SimpleDateFormat customDateFormat = new SimpleDateFormat("yyyy/MM/dd");
        mapper.setDateFormat(customDateFormat);

        // Test event with a specific date
        Date testDate = customDateFormat.parse("2023/10/01");
        Event event = new Event(testDate);

        // Serialize the event to JSON
        String json = mapper.writeValueAsString(event);

        // Expected JSON output should maintain the custom "yyyy/MM/dd" format
        String expectedJson = "{\"timestamp\":\"2023/10/01\"}";

        assertEquals(expectedJson, json);
    }
}
