
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathException;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.junit.Test;

import java.util.Arrays;
import java.util.Collections;

import static org.junit.Assert.fail;

public class XPathPointerComparisonTest {

    @Test
    public void testComparisonOfPointersFromDifferentTrees() {
        try {
            // Setting up a simple XML context
            String xmlInput = "<MAIN><A>value</A></MAIN>";
            JXPathContext context = JXPathContext.newContext(new org.xml.sax.InputSource(new java.io.StringReader(xmlInput)));

            // Defining a variable in the JXPathContext
            context.getVariables().declareVariable("var", "value");

            // This XPath expression attempts to create a union between a variable and an XPath node
            context.selectNodes("$var | /MAIN/A");
        
            // If no exception is thrown, the test fails
            fail("Expected a JXPathException due to comparison of pointers from different trees, but none was thrown.");
        } catch (JXPathException e) {
            // Check if the exception message matches the expected message
            String expectedMessage = "Cannot compare pointers that do not belong to the same tree";
            if (!e.getMessage().contains(expectedMessage)) {
                fail("Expected a different JXPathException message containing: " + expectedMessage);
            }
        }
    }
}
