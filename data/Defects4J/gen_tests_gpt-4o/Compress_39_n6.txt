
import org.junit.Test;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class ZipFileTest {

    @Test
    public void testTruncatedZipFile() {
        // Create a truncated zip file (in bytes)
        byte[] truncatedZip = { 
            0x50, 0x4B, 0x03, 0x04, // Local file header signature
            0x14, 0x00, // Version needed to extract
            0x00, 0x00, // General purpose bit flag
            0x08, 0x00, // Compression method (deflate)
            0x08, 0x00, // File modification time
            0x21, 0x00, // File modification date
            0x00, 0x00, 0x00, 0x00, // CRC-32
            0x00, 0x00, 0x00, 0x00, // Compressed size
            0x00, 0x00, 0x00, 0x00, // Uncompressed size
            // Rest of the data is missing, making it a truncated zip
        };

        // Try reading the truncated zip file
        try (ZipInputStream zipInputStream = new ZipInputStream(new ByteArrayInputStream(truncatedZip))) {
            ZipEntry entry;
            while ((entry = zipInputStream.getNextEntry()) != null) {
                System.out.println("Reading entry: " + entry.getName());
                zipInputStream.closeEntry();
            }
        } catch (IOException e) {
            // Assert that an EOFException occurs and test if the message is problematic
            assertTrue(e instanceof java.io.EOFException);
            String message = e.getMessage();
            // Check if the message is large or contains unnecessary byte[] data
            assertFalse("Error message contains large byte[] data", message.length() > 1000);
        }
    }
}
