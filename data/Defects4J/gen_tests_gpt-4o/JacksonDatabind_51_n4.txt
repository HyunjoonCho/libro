
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.databind.DeserializationFeature;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

// Dummy classes to demonstrate the point
class Base<T> {
    public T value;
}

class Impl extends Base<String> {
    // Additional fields or methods
}

// Custom TypeIdResolver
class CustomTypeIdResolver extends TypeIdResolverBase {
    @Override
    public void init(JavaType baseType) {
        // Initialization if needed
    }

    @Override
    public String idFromValue(Object value) {
        return null;  // Implementation here
    }

    @Override
    public JavaType typeFromId(String id) {
        // Returning a generic type with parameter
        return TypeFactory.defaultInstance().constructParametricType(Base.class, String.class);
    }

    @Override
    public String getDescForKnownTypeIds() {
        return null;  // Implementation here
    }
}

// Test class
public class CustomTypeIdResolverTest {

    @Test
    public void testGenericTypeResolution() throws Exception {
        String json = "{\"value\":\"test\"}";

        ObjectMapper mapper = new ObjectMapper();
        mapper.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        
        // Registering the custom type resolver
        mapper.setAnnotationIntrospector(mapper.getSerializationConfig().getAnnotationIntrospector()
                .withTypeIdResolver(new CustomTypeIdResolver()));

        Base<?> result = mapper.readValue(json, Base.class);

        assertEquals("test", result.value);
    }
}
