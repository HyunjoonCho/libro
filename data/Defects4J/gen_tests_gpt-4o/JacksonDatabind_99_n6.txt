
import static org.junit.Assert.assertEquals;

import org.apache.commons.collections4.map.LRUMap;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.databind.type.ReferenceType;

import org.junit.Test;

public class ReferenceTypeCanonicalStringTest {

    @Test
    public void testReferenceTypeCanonicalString() {
        TypeFactory typeFactory = new TypeFactory(new LRUMap<Object, JavaType>(0, 10000));
        JavaType objectType = typeFactory.constructType(Object.class);

        ReferenceType referenceType = new ReferenceType(objectType, new PlaceholderForType(0));

        String canonicalString = referenceType.toCanonical();

        assertEquals("java.lang.Object<$1>", canonicalString);
    }

    // Placeholder class for the sake of this test case
    private static class PlaceholderForType extends JavaType {
        private final int placeholderId;

        protected PlaceholderForType(int placeholderId) {
            super(Object.class, null, null, null, null);
            this.placeholderId = placeholderId;
        }

        @Override
        public StringBuilder getGenericSignature(StringBuilder sb) {
            return sb.append('$').append(placeholderId);
        }

        @Override
        public StringBuilder getErasedSignature(StringBuilder sb) {
            return sb.append('$').append(placeholderId);
        }

        @Override
        public JavaType withContentType(JavaType contentType) {
            return this;
        }

        @Override
        public boolean hasContentType() {
            return false;
        }

        @Override
        public String toCanonical() {
            return "$" + placeholderId;
        }
    }
}
