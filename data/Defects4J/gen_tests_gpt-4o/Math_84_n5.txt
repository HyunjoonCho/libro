
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import org.apache.commons.math4.optim.nonlinear.scalar.MultivariateOptimizer;
import org.apache.commons.math4.optim.nonlinear.scalar.MultivariateObjectiveFunction;
import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex;
import org.apache.commons.math4.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math4.optim.InitialGuess;
import org.apache.commons.math4.optim.MaxEval;
import org.junit.Test;

public class MultiDirectionalTest {

    @Test(timeout = 1000) // Use timeout to avoid infinite loop
    public void testMultiDirectionalCorrectStart() {
        // Define a simple quadratic function as the objective
        MultivariateObjectiveFunction objectiveFunction = new MultivariateObjectiveFunction(point -> {
            double x = point[0];
            return x * x;
        });

        // Initialize the MultiDirectional optimizer
        MultivariateOptimizer optimizer = new MultivariateOptimizer() {
            @Override
            protected PointValuePair doOptimize() {
                return null;
            }
        };

        // Set the initial guess to the known correct solution
        InitialGuess initialGuess = new InitialGuess(new double[]{0.0}); // The correct solution is x = 0.0

        // Initialize the simplex with a small start configuration
        MultiDirectionalSimplex simplex = new MultiDirectionalSimplex(new double[]{0.1});

        // Perform the optimization
        optimizer.optimize(
            objectiveFunction,
            GoalType.MINIMIZE,
            initialGuess,
            simplex,
            new MaxEval(100) // Limiting the evaluations to ensure test termination
        );

        // Assert that the optimal point found is close to the correct solution
        PointValuePair result = optimizer.optimize(objectiveFunction, GoalType.MINIMIZE, initialGuess, simplex);
        double[] optimalPoint = result.getPoint();
        assertEquals(0.0, optimalPoint[0], 1e-6); // Allow for a small margin of error
        assertTrue(result.getValue() < 1e-6);     // Ensure the function value is minimized
    }
}
