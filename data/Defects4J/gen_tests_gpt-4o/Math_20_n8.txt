
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.InitialGuess;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.SimpleBounds;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;

import org.junit.Test;
import static org.junit.Assert.assertTrue;

public class CMAESOptimizerTest {

    @Test
    public void testCMAESOptimizerEnforcesBounds() {
        // Objective function: simple paraboloid (min at origin)
        ObjectiveFunction objectiveFunction = new ObjectiveFunction(point -> {
            double sum = 0;
            for (double x : point) {
                sum += x * x;
            }
            return sum;
        });

        // Set the start point and bounds
        double[] startPoint = {5, 5};
        double[] lowerBounds = {-1, -1};
        double[] upperBounds = {1, 1};

        CMAESOptimizer optimizer = new CMAESOptimizer(
            10000,  // max iterations
            0,      // stop fitness
            true,   // isActiveCMA
            0,      // diagonalOnly
            0,      // checkFeasableCount (default value 0 which can cause out of bounds)
            10,     // random Seed
            CMAESOptimizer.SigmaIsThree,
            null
        );

        PointValuePair result = optimizer.optimize(
            new MaxEval(1000), // Maximum number of evaluations
            objectiveFunction,
            GoalType.MINIMIZE,
            new InitialGuess(startPoint),
            new SimpleBounds(lowerBounds, upperBounds)
        );

        double[] solution = result.getPoint();

        // Check if the solution is within bounds
        for (int i = 0; i < solution.length; i++) {
            assertTrue("Solution is out of bounds", solution[i] >= lowerBounds[i] && solution[i] <= upperBounds[i]);
        }
    }
}
