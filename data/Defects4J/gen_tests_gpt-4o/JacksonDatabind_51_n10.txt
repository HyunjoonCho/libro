
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;
import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;
import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;
import com.fasterxml.jackson.databind.type.TypeFactory;
import org.junit.Test;
import static org.junit.Assert.*;

public class GenericTypeSerializationTest {

    static class MyTypeIdResolver extends TypeIdResolverBase {
        @Override
        public String idFromValue(Object value) {
            return value.getClass().getName();
        }

        @Override
        public String idFromValueAndType(Object value, Class<?> suggestedType) {
            return suggestedType.getName();
        }

        @Override
        public JavaType typeFromId(DatabindContext context, String id) {
            try {
                Class<?> clazz = Class.forName(id);
                return TypeFactory.defaultInstance().constructType(clazz);
            } catch (ClassNotFoundException e) {
                throw new IllegalStateException("Unable to resolve class: " + id, e);
            }
        }

        @Override
        public JsonTypeInfo.Id getMechanism() {
            return JsonTypeInfo.Id.CUSTOM;
        }
    }

    @JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, include = JsonTypeInfo.As.PROPERTY, property = "@class")
    static class GenericContainer<T> {
        public T item;
    }

    static class InnerType {
        public String value;

        InnerType() {}

        InnerType(String value) {
            this.value = value;
        }
    }

    private static ObjectMapper getCustomObjectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        TypeResolverBuilder<?> typer = new StdTypeResolverBuilder(JsonTypeInfo.Id.CUSTOM, new MyTypeIdResolver());
        typer.init(JsonTypeInfo.Id.CUSTOM, new MyTypeIdResolver());
        typer.inclusion(JsonTypeInfo.As.PROPERTY);
        mapper.setDefaultTyping(typer);
        return mapper;
    }

    @Test
    public void testGenericTypeSerialization() throws JsonProcessingException {
        GenericContainer<InnerType> container = new GenericContainer<>();
        container.item = new InnerType("test");

        ObjectMapper mapper = getCustomObjectMapper();
        String json = mapper.writeValueAsString(container);

        GenericContainer<?> result = mapper.readValue(json, GenericContainer.class);
        
        assertNotNull(result.item);
        assertTrue(result.item instanceof InnerType);
        assertEquals("test", ((InnerType) result.item).value);
    }
}
