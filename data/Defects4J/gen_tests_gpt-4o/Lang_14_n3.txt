@Test
public void testStringUtilsEqualsWithDifferentCharSequenceImplementations() {
    String string = "test";
    CharSequence name = new javax.lang.model.element.Name() {
        @Override
        public char charAt(int index) {
            return string.charAt(index);
        }

        @Override
        public int length() {
            return string.length();
        }

        @Override
        public CharSequence subSequence(int start, int end) {
            return string.subSequence(start, end);
        }

        @Override
        public boolean equals(Object obj) {
            return obj instanceof javax.lang.model.element.Name && obj.toString().equals(string);
        }

        @Override
        public int hashCode() {
            return string.hashCode();
        }

        @Override
        public String toString() {
            return string;
        }
    };
    
    // Using a basic custom implemented CharSequence
    CharSequence customCharSequence = new CharSequence() {
        @Override
        public char charAt(int index) {
            return string.charAt(index);
        }

        @Override
        public int length() {
            return string.length();
        }

        @Override
        public CharSequence subSequence(int start, int end) {
            return string.subSequence(start, end);
        }

        @Override
        public String toString() {
            return string;
        }
    };
    
    boolean isEqualUsingCharSequence = string.contentEquals(name);
    boolean isEqualUsingCustomString = string.contentEquals(customCharSequence);

    // Here the assumption is StringUtils.equals(CharSequence, CharSequence) which should rely on the content comparison across different implementations, but fails due to direct reliance on equals of CharSequence
    boolean isEqualUsingUtilMethod = StringUtils.equals(name, string);
    boolean isEqualUsingUtilCustomMethod = StringUtils.equals(customCharSequence, string);

    // The expected is that equals should be true because the character sequences are equal by content and not by implementation
    assertTrue(isEqualUsingCharSequence);
    assertTrue(isEqualUsingCustomString);

    // Demonstrating the bug: Content is identical, but method may return false
    assertFalse(isEqualUsingUtilMethod); 
    assertTrue(isEqualUsingUtilCustomMethod); // This should be true if the issue is fixed
}