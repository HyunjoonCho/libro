
import com.google.javascript.jscomp.CommandLineRunner;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JSSourceFile;
import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

import static org.junit.Assert.assertTrue;

public class ClosureCompilerTest {

    @Test
    public void testDeleteOperatorWithAdvancedCompilation() {
        // JavaScript code snippet that causes the compiler error
        String jsCode = "function x() { return delete a; }";

        // Set up sources (for simplicity, it's just from a string here)
        JSSourceFile[] externs = new JSSourceFile[]{JSSourceFile.fromCode("externs.js", "")};
        JSSourceFile[] inputs = new JSSourceFile[]{JSSourceFile.fromCode("input.js", jsCode)};

        // Capture the standard error stream
        ByteArrayOutputStream errContent = new ByteArrayOutputStream();
        PrintStream originalErr = System.err;
        System.setErr(new PrintStream(errContent));

        try {
            CompilerOptions options = new CompilerOptions();
            options.setCompilationLevel(CompilerOptions.CompilationLevel.ADVANCED_OPTIMIZATIONS);

            CommandLineRunner runner = new CommandLineRunner(
                    new String[]{},
                    inputs,
                    externs,
                    null  // Output writer (stdout/stderr)
            );

            runner.setCompilerOptions(options);
            runner.doRun();

            // Check if the error message contains the expected internal compiler error
            String errorOutput = errContent.toString();
            assertTrue(errorOutput.contains("INTERNAL COMPILER ERROR"));
            assertTrue(errorOutput.contains("Unexpected expression nodeDELPROP"));

        } finally {
            // Restore the original standard error stream
            System.setErr(originalErr);
        }
    }
}
