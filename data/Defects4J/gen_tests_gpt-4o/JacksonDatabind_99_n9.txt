
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import java.util.HashMap;

public class ReferenceTypeTest {

    @Test
    public void testCanonicalStringForReferenceType() {
        // Assume ReferenceType, TypeFactory, and PlaceholderForType are part of the library being tested.
        TypeFactory typeFactory = new TypeFactory(new HashMap<Object, JavaType>());
        JavaType objectType = typeFactory.constructType(Object.class);
        PlaceholderForType placeholder = new PlaceholderForType(0);

        ReferenceType referenceType = new ReferenceType(objectType, placeholder);
        String canonical = referenceType.toCanonical();

        assertEquals("java.lang.Object<$1>", canonical);
    }
}

// Mocks / Dummies for the necessary classes to make the test self-contained.
// Replace these with the actual implementations from the library where available.

class ReferenceType {
    private JavaType mainType;
    private PlaceholderForType placeholder;

    public ReferenceType(JavaType mainType, PlaceholderForType placeholder) {
        this.mainType = mainType;
        this.placeholder = placeholder;
    }

    public String toCanonical() {
        return mainType.toString() + "<" + placeholder.toString() + ">";
    }
}

class TypeFactory {
    private HashMap<Object, JavaType> typeMap;

    public TypeFactory(HashMap<Object, JavaType> typeMap) {
        this.typeMap = typeMap;
    }

    public JavaType constructType(Class<?> cls) {
        return new JavaType(cls.getName());
    }
}

class JavaType {
    private String typeName;

    public JavaType(String typeName) {
        this.typeName = typeName;
    }

    @Override
    public String toString() {
        return typeName;
    }
}

class PlaceholderForType {
    private int index;

    public PlaceholderForType(int index) {
        this.index = index;
    }

    @Override
    public String toString() {
        return "$" + index;
    }
}
