
import org.apache.commons.math3.fraction.Fraction;
import org.apache.commons.math3.fraction.FractionConversionException;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

public class FractionTest {

    @Test
    public void testIncorrectSignAndValueApproximation() {
        try {
            Fraction fraction = new Fraction(-33655.1677817278, 371880);
            // Here we expect the fraction to be negative and reasonably close to the input value.
            // Since we can't check the exact fraction it should produce, 
            // we'll check if it approximates the correct sign
            if (fraction.getNumerator() > 0) {
                fail("Fraction has an incorrect sign. Expected negative numerator.");
            }
        } catch (FractionConversionException e) {
            fail("Unexpected FractionConversionException: " + e.getMessage());
        }
    }

    @Test
    public void testReductionFailureOnApproximation() {
        try {
            Fraction fraction = new Fraction(-43979.60679604749, 366081);
            // Verify that the fraction has been reduced.
            // Check against the manually calculated reduced fraction
            Fraction expectedReducedFraction = new Fraction(-24654898, 3831);
            assertEquals("Fraction did not reduce properly.", expectedReducedFraction, fraction);
        } catch (FractionConversionException e) {
            fail("Unexpected FractionConversionException: " + e.getMessage());
        }
    }
}
