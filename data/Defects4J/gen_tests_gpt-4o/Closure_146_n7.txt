
import static org.junit.Assert.*;

import java.util.logging.*;

import org.junit.*;

import com.google.javascript.jscomp.*;

public class BadTypeInferenceTest {

    @Test
    public void testBadTypeInference() {
        String jsInput =
            "/** @param {string} x */\n" +
            "function g(x) {}\n" +
            "\n" +
            "/** @param {undefined} x */\n" +
            "function f(x) {\n" +
            "    if (x != undefined) { g(x); }\n" +
            "}";

        Compiler compiler = new Compiler();
        
        // Create an error manager to capture compile time warnings and errors
        CompilerOptions options = new CompilerOptions();
        TestErrorManager errorManager = new TestErrorManager();
        compiler.setErrorManager(errorManager);
        
        // We want advanced compilation to match the test conditions
        CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
        
        // Compile the JavaScript code
        SourceFile input = SourceFile.fromCode("input.js", jsInput);
        SourceFile extern = SourceFile.fromCode("externs.js", ""); // No externs
        compiler.compile(extern, input, options);
        
        // Assert that the deterministic test warning is captured
        assertTrue("Expected deterministic test and type mismatch warnings",
            errorManager.getWarningCount() > 0);
        
        String expectedWarning1 = "JSC_DETERMINISTIC_TEST: condition always evaluates to false";
        String expectedWarning2 = "JSC_TYPE_MISMATCH: actual parameter 1 of g does not match formal parameter";
        
        boolean foundWarning1 = errorManager.warnings().stream()
            .anyMatch(e -> e.description.contains(expectedWarning1));
        boolean foundWarning2 = errorManager.warnings().stream()
            .anyMatch(e -> e.description.contains(expectedWarning2));
        
        assertTrue("Expected to find specific warnings about condition and parameter type",
            foundWarning1 && foundWarning2);
    }

    private static class TestErrorManager extends BasicErrorManager {
        @Override
        public void println(CheckLevel level, JSError error) {
            log(level + ": " + error.sourceName + ": " + error.description);
        }

        @Override
        protected void printSummary() {
            log("error(s): " + getErrorCount());
            log("warning(s): " + getWarningCount());
        }

        private void log(String message) {
            Logger.getLogger(BadTypeInferenceTest.class.getName()).warning(message);
        }
    }
}
