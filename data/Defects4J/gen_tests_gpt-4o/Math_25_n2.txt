
import org.apache.commons.math3.analysis.function.Sin;
import org.apache.commons.math3.exception.DimensionMismatchException;
import org.apache.commons.math3.fitting.HarmonicFitter;
import org.apache.commons.math3.fitting.WeightedObservedPoint;
import org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer;
import org.junit.Test;
import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.List;

public class HarmonicFitterTest {

    @Test
    public void testParameterGuesserFailsForAmplitude() {
        // Create a Levenberg-Marquardt optimizer instance
        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();

        // Create a Harmonic Fitter instance
        HarmonicFitter fitter = new HarmonicFitter(optimizer);

        // Add observed points that are known to lead to a failure in amplitude calculation
        List<WeightedObservedPoint> points = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            points.add(new WeightedObservedPoint(1.0, i, Math.sin(i)));
        }

        try {
            // Create a ParameterGuesser with problematic points
            HarmonicFitter.ParameterGuesser guesser = new HarmonicFitter.ParameterGuesser(points);

            // Invoke the guess method which is expected to fail
            double[] guessedParameters = guesser.guess();

            // Validate amplitude guess based on known failure condition
            // Assuming amplitude guess is the first parameter in the array
            assertFalse("Amplitude guess should not be NaN", Double.isNaN(guessedParameters[0]));
            assertTrue("Amplitude guess should be sensible", guessedParameters[0] > 0);

        } catch (DimensionMismatchException e) {
            fail("Unexpected DimensionMismatchException thrown");
        }
    }
}
