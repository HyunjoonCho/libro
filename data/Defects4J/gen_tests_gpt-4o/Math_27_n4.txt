
import org.junit.Test;
import static org.junit.Assert.*;

public class FractionTest {

    @Test
    public void testPercentageValueOverflow() {
        // Assuming Fraction class has a constructor that takes a numerator and a denominator
        int largeNumerator = Integer.MAX_VALUE / 100 + 1;
        int denominator = Integer.MAX_VALUE;
        Fraction fraction = new Fraction(largeNumerator, denominator);

        // Call the percentageValue() method
        double percentage = fraction.percentageValue();

        // The expected result should be the double precision multiplication of largeNumerator/denominator * 100
        double expectedPercentage = ((double) largeNumerator / denominator) * 100;

        assertEquals("Percentage value should be calculated without overflow", expectedPercentage, percentage, 1e-9);
    }
}

// Sample Fraction class (for conceptual testing purposes)
class Fraction {
    private final int numerator;
    private final int denominator;

    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
    }

    public double percentageValue() {
        // Existing buggy implementation causing overflow
        // return (numerator * 100 / (double) denominator);

        // New implementation suggested by the bug report
        return ((double) numerator / denominator) * 100.0;
    }
}
