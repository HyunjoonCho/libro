public void testConstructorTypeParsing() {
    String codeWithUnknownType = "/** @type {function(new:?)} */ var foo = function() {};";
    String codeWithAllType = "/** @type {function(new:*)} */ var bar = function() {};";

    JSTypeRegistry registry = new JSTypeRegistry(null);
    Compiler compiler = new Compiler();
    compiler.initOptions(new CompilerOptions());

    Node nodeWithUnknownType = parse(compiler, codeWithUnknownType);
    Node nodeWithAllType = parse(compiler, codeWithAllType);

    JSTypeExpression unknownTypeExpr = JSDocInfoParser.parseTypeString("function(new:?)");
    JSTypeExpression allTypeExpr = JSDocInfoParser.parseTypeString("function(new:*)");

    registry.evaluateTypeExpressions(unknownTypeExpr).resolve();
    registry.evaluateTypeExpressions(allTypeExpr).resolve();

    // We expect these types to be parsed without throwing syntax errors
    assertNotNull(unknownTypeExpr);
    assertNotNull(allTypeExpr);
}

private Node parse(Compiler compiler, String code) {
    CompilerInput input = new CompilerInput(SourceFile.fromCode("test", code));
    Node root = compiler.parse(input);
    assertNotNull("Parsed Node should not be null", root);
    assertTrue("Parsing should not have errors", compiler.getErrorCount() == 0);
    return root;
}