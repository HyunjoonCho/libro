
import org.junit.Test;
import static org.junit.Assert.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;

public class TarChecksumTest {

    @Test
    public void testChecksumRightAlignedZeroPadded() throws IOException {
        byte[] tarData = createTestTarWithRightAlignedChecksum();
        ByteArrayInputStream bais = new ByteArrayInputStream(tarData);
        TarArchiveInputStream tais = new TarArchiveInputStream(bais);

        boolean checksumValid = false;

        try {
            // Attempting to read the entry to trigger checksum validation
            checksumValid = (tais.getNextEntry() != null);
        } catch (Exception e) {
            // Handle any unexpected exceptions while reading the TAR entry
            e.printStackTrace();
        }

        // Assert that the checksum should be valid (this would be the bug if it fails)
        assertTrue("Checksum should be valid, but it was treated as invalid.", checksumValid);
    }

    private byte[] createTestTarWithRightAlignedChecksum() {
        // Header size for a TAR entry is 512 bytes
        byte[] header = new byte[512];

        // Example of adding a TAR header (simple example without actual file data)
        // Assuming a filename of "test.txt" starting at the 0th byte
        String fileName = "test.txt";
        System.arraycopy(fileName.getBytes(), 0, header, 0, fileName.length());

        // Length of the `mode`, `uid`, `gid`, etc. fields
        int fieldLength = 8;

        // Offset of the checksum field in the TAR header (8 spaces followed by 8 digits)
        int checksumOffset = 148;

        // Example 6-digit checksum (characters '0000745' for the bug scenario)
        String checksum = "0000745"; // Right-aligned within the field
        byte[] checksumBytes = checksum.getBytes();

        // Copy the checksum to the header, aligning to the right within the field
        System.arraycopy(checksumBytes, 0, header, checksumOffset + fieldLength - checksumBytes.length, checksumBytes.length);

        // Ensure remaining checksum field is space-padded (or NULL, depending on the implementation)
        fillSpaces(header, checksumOffset, fieldLength - checksumBytes.length);

        // Return the crafted header for testing
        return header;
    }

    private void fillSpaces(byte[] buffer, int start, int length) {
        for (int i = start; i < start + length; i++) {
            buffer[i] = ' '; // Use spaces or zero-NUL if needed for specific needs
        }
    }
}
