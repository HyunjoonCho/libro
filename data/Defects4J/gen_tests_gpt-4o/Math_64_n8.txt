
import org.apache.commons.math3.fitting.leastsquares.LevenbergMarquardtOptimizer;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresFactory;
import org.apache.commons.math3.optim.SimpleVectorValueChecker;
import org.apache.commons.math3.linear.RealVector;
import org.apache.commons.math3.linear.ArrayRealVector;
import org.junit.Assert;
import org.junit.Test;

public class LevenbergMarquardtTest {

    // Test function and target values for demonstration
    private static final double[] TARGET = {1.0, 0.0};
    private static final double[][] MODEL = {
        {2.0, 0.0},
        {0.0, 1.0}
    };

    @Test
    public void testInconsistentResultFromLevenbergMarquardt() {
        // Initialize the optimizer
        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();

        // Set up the least squares problem
        LeastSquaresProblem problem = LeastSquaresFactory.create(
            new ArrayRealVector(TARGET), // Observed values
            point -> {
                // Simple linear model
                double[] result = new double[MODEL.length];
                for (int i = 0; i < MODEL.length; i++) {
                    result[i] = MODEL[i][0] * point.getEntry(0) + MODEL[i][1] * point.getEntry(1);
                }
                return new ArrayRealVector(result);
            },
            new ArrayRealVector(new double[]{0.0, 0.0}), // Initial guess
            new SimpleVectorValueChecker(1e-10, 1e-10)   // Convergence checker
        );

        // Perform the optimization
        LeastSquaresProblem.Evaluation evaluation = optimizer.optimize(problem);

        // Retrieve results
        RealVector point = evaluation.getPoint();
        double cost = evaluation.getCost();
        RealVector residuals = evaluation.getResiduals();
        
        // Asserts to ensure the returned point is consistent with cost and residuals
        double calculatedCost = residuals.getNorm();
        Assert.assertEquals("The calculated cost doesn't match the returned cost", calculatedCost, cost, 1e-6);

        // Additional assertions to verify our expectation of the optimum
        RealVector expectedPoint = new ArrayRealVector(new double[]{0.5, 0.0});
        Assert.assertTrue("Optimum point not as expected", point.equals(expectedPoint, 1e-6));
    }
}
