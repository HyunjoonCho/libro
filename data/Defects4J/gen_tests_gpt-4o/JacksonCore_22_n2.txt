
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.filter.FilteringParserDelegate;
import com.fasterxml.jackson.core.filter.TokenFilter;
import com.fasterxml.jackson.core.filter.TokenFilter.Inclusion;
import static org.junit.Assert.assertEquals;
import org.junit.Test;

import java.io.IOException;
import java.io.StringReader;

public class FilteringParserDelegateTest {
    
    @Test
    public void testMatchCountWithFilteringParserDelegate() throws IOException {
        String json = "{\"key1\":\"value1\", \"key2\":\"value2\", \"key3\":\"value3\"}";
        
        JsonFactory jsonFactory = new JsonFactory();
        JsonParser parser = jsonFactory.createParser(new StringReader(json));

        // Custom token filter: accepts all keys that match "key1" and "key2"
        TokenFilter customFilter = new TokenFilter() {
            @Override
            public TokenFilter includeProperty(String name) {
                if ("key1".equals(name) || "key2".equals(name)) {
                    return TokenFilter.INCLUDE_ALL;
                }
                return null;
            }
        };

        FilteringParserDelegate filterParser = new FilteringParserDelegate(parser, customFilter, Inclusion.INCLUDE_ALL_AND_PATH, true);

        int matchCount = 0;

        while (filterParser.nextToken() != JsonToken.END_OBJECT) {
            if (filterParser.getCurrentToken() == JsonToken.FIELD_NAME) {
                matchCount++;
            }
        }

        // Assuming the matchCount should reflect the number of accepted entries
        assertEquals(2, matchCount);
    }
}
