
import org.junit.Test;
import static org.junit.Assert.*;

public class FunctionPropertyTest {

    @Test
    public void testFunctionPropertyPreservation() {
        // Simulated environment for the test
        MyFunctions functions = new MyFunctions();

        // Initially setting the property
        functions.f1.alwaysCall = true;

        // Function to test
        boolean called = functions.callFunctionByKey("f1");

        // The property should still exist and ensure the function is called
        assertTrue("f1 should have been called due to alwaysCall property", called);

        // Test that f2 is not called (as it doesn't have alwaysCall set)
        boolean notCalled = functions.callFunctionByKey("f2");
        assertFalse("f2 should not have been called as it has no alwaysCall property", notCalled);
    }

    // Simulating a class that holds the functions and logic as in the JavaScript example
    static class MyFunctions {
        FunctionWrapper f1 = new FunctionWrapper(() -> {
            System.out.println("f1");
        });

        FunctionWrapper f2 = new FunctionWrapper(() -> {
            System.out.println("f2");
        });

        void addToMap(String key, FunctionWrapper func) {
            map.put(key, func);
        }

        Map<String, FunctionWrapper> map = new HashMap<>();

        MyFunctions() {
            addToMap("f1", f1);
            addToMap("f2", f2);
        }

        boolean callFunctionByKey(String key) {
            FunctionWrapper f = map.get(key);
            if (f.alwaysCall != null && f.alwaysCall) {
                f.runFunction();
                return true;
            }
            return false;
        }
    }

    // Wrapping functions to simulate the "alwaysCall" property
    static class FunctionWrapper {
        Runnable function;
        Boolean alwaysCall = null;

        FunctionWrapper(Runnable function) {
            this.function = function;
        }

        void runFunction() {
            function.run();
        }
    }
}
