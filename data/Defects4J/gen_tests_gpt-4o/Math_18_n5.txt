
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.math3.optim.InitialGuess;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.SimpleBounds;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.PointValuePair;
import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class CMAESOptimizerTest {

    @Test
    public void testFittingResolutionNearBounds() {
        // Define a simple quadratic objective function for testing
        ObjectiveFunction objectiveFunction = new ObjectiveFunction(x -> {
            double sum = 0;
            for (double xi : x) {
                sum += (xi - 0.5) * (xi - 0.5);
            }
            return sum;
        });

        // Use a narrow range to observe the effect more clearly
        double[] lowerBound = {0.0};
        double[] upperBound = {1.0};
        InitialGuess initialGuess = new InitialGuess(new double[]{0.01});
        
        // Set up CMAES optimizer with bounds
        CMAESOptimizer optimizer = new CMAESOptimizer(10000, 1e-9, true, 0, 0, null, false, null);

        // Perform optimization
        PointValuePair result = optimizer.optimize(
                new MaxEval(1000),
                objectiveFunction,
                GoalType.MINIMIZE,
                initialGuess,
                new SimpleBounds(lowerBound, upperBound));

        // Extract result
        double[] optimalPoint = result.getPoint();

        // Check if the optimizer returns a point closer to the lower bound
        // (indicating high resolution near lower bounds compared to upper bounds)
        assertTrue("Optimal point is not significantly closer to lower bound than upper bound",
                optimalPoint[0] - lowerBound[0] < upperBound[0] - optimalPoint[0]);
    }
}
