public void testLevenbergMarquardtOptimizerIgnoresConvergenceChecker() {
    // Mock or create a custom VectorialConvergenceChecker
    VectorialConvergenceChecker checker = new VectorialConvergenceChecker() {
        @Override
        public boolean converged(int iteration, VectorialPointValuePair previous, VectorialPointValuePair current) {
            // Custom convergence criteria
            return iteration > 10;
        }
    };

    // Set up test data for the optimizer
    double[] startPoint = new double[] {1.0, 1.0};
    
    // Create an instance of the optimizer with the custom convergence checker
    LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(
        1e-10, 1e-10, 1e-10, checker);
    
    // Build a model function and its Jacobian
    DifferentiableMultivariateVectorFunction model = new DifferentiableMultivariateVectorFunction() {
        @Override
        public double[] value(double[] variables) {
            return new double[] {2 * variables[0] + 3 * variables[1]};
        }
        
        @Override
        public MultivariateMatrixFunction jacobian() {
            return new MultivariateMatrixFunction() {
                @Override
                public double[][] value(double[] variables) {
                    return new double[][] {{2, 3}};
                }
            };
        }
    };

    double[][] target = new double[][] {{10}};
    double[] weights = new double[] {1.0};

    // Call optimize and ensure the custom checker was respected
    try {
        optimizer.optimize(100, model, target, weights, startPoint);
        fail("Expected optimization to respect custom convergence checker and stop early.");
    } catch (MaxIterationsExceededException e) {
        // The exception should occur if the checker is ignored and max iterations are reached
        assertTrue(true);
    }
}