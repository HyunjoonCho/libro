
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.zip.ZipInputStream;

import static org.junit.Assert.*;

public class ZipFileCorruptionTest {

    @Test
    public void testZipFileCorruptionDueToHashCollisions() throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        try (ZipArchiveOutputStream zipOutputStream = new ZipArchiveOutputStream(byteArrayOutputStream)) {
            
            // Creating a large number of similar files to increase the chance of hash collisions
            for (int i = 0; i < 1000; i++) {
                String fileName = "file" + i + ".txt";
                ZipArchiveEntry entry = new ZipArchiveEntry(fileName);
                
                // Uncomment the following line to emphasize the bug:
                // entry.setName("file" + (i % 50) + ".txt"); 

                zipOutputStream.putArchiveEntry(entry);
                zipOutputStream.write(("Content for " + fileName).getBytes());
                zipOutputStream.closeArchiveEntry();
            }
        }

        // Verify the zip file by attempting to read the contents using ZipInputStream
        try (ZipInputStream zipInputStream = new ZipInputStream(new java.io.ByteArrayInputStream(byteArrayOutputStream.toByteArray()))) {
            int entryCount = 0;
            while (zipInputStream.getNextEntry() != null) {
                entryCount++;
            }
            
            // Verify that all entries have been counted correctly
            assertEquals("Unexpected number of entries in zip file, indicating corruption.", 1000, entryCount);
        }
    }
}
