
import org.mozilla.javascript.Context;
import org.mozilla.javascript.Scriptable;
import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class ClosureOptimizationTest {

    @Test
    public void testOptimizationFailsWithCatchVariable() {
        String originalScript = 
            "function getStack() {" +
            "    var getErrorObject = function() {" +
            "        try {" +
            "            throw Error('');" +
            "        } catch(err) {" +
            "            return err;" +
            "        }" +
            "    };" +
            "    return getErrorObject().stack;" +
            "}" +
            "window['getStackTrace'] = getStack;";

        String optimizedScript = 
            "function getStack() {" +
            "    try {" +
            "        throw Error('');" +
            "    } catch(a) {" +
            "    }" +
            "    return a.stack;" +
            "}" +
            "window.getStackTrace = getStack;";

        Context context = Context.enter();
        try {
            Scriptable scope = context.initStandardObjects();
            // Load the optimized script and check for errors
            context.evaluateString(scope, optimizedScript, "optimizedScript", 1, null);

            // Attempt to execute the getStackTrace function
            Object result = context.evaluateString(scope, "getStackTrace()", "testScript", 1, null);

            // In an expected optimization failure, the execution may not return the expected stack
            // Here, we check that it fails as described (as it should be incorrect)
            assertTrue("Optimization incorrectly assigns 'a' outside of catch scope", result == Context.getUndefinedValue());
        } catch (Exception e) {
            // Expecting an error due to the illegal reference to 'a'
            assertTrue("Expected error due to scope problem", e.getMessage().contains("ReferenceError: \"a\" is not defined"));
        } finally {
            Context.exit();
        }
    }
}
