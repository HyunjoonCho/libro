
import org.junit.Test;
import static org.junit.Assert.*;

public class CompilerBugTest {

    /**
     * Test to reproduce the Compiler Bug #107
     */
    @Test
    public void testWeirdObjectLiteralError() {
        String reproJsCode = "/**\n" +
                " * @param {{text: string}} opt_data\n" +
                " * @return {string}\n" +
                " */\n" +
                "function temp1(opt_data) {\n" +
                "    return opt_data.text;\n" +
                "}\n" +
                "\n" +
                "/**\n" +
                " * @param {{activity: (boolean|number|string|null|Object)}} opt_data\n" +
                " * @return {string}\n" +
                " */\n" +
                "function temp2(opt_data) {\n" +
                "    /** @notypecheck */\n" +
                "    function __inner() {\n" +
                "        return temp1(opt_data.activity);\n" +
                "    }\n" +
                "    return __inner();\n" +
                "}\n" +
                "\n" +
                "/**\n" +
                " * @param {{n: number, text: string, b: boolean}} opt_data\n" +
                " * @return {string}\n" +
                " */\n" +
                "function temp3(opt_data) {\n" +
                "    return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\n" +
                "}\n" +
                "\n" +
                "function callee() {\n" +
                "    var output = temp3({\n" +
                "        n: 0,\n" +
                "        text: 'a string',\n" +
                "        b: true\n" +
                "    });\n" +
                "    alert(output);\n" +
                "}\n" +
                "\n" +
                "callee();\n";

        // Ideally, you would integrate this JS code with an automated way to compile
        // using the Closure Compiler as described and assert on the expected output.
        // Since Java code cannot compile JavaScript via the Closure Compiler directly,
        // We're assuming this is part of an external compilation process.
        // The test serves as documentation of the intent.

        // Use an assertion to mimic the expected behavior
        try {
            compileJavaScript(reproJsCode);
            fail("Expected a compilation error due to type mismatch");
        } catch (CompilerException e) {
            assertTrue(e.getMessage().contains("ERROR - actual parameter 1 of temp3 does not match formal parameter"));
        }
    }

    private void compileJavaScript(String jsCode) throws CompilerException {
        // This is a placeholder method to represent the compilation
        // process using Google Closure Compiler as the real process
        // would be an external call.
        throw new CompilerException("Mock exception to simulate Closure Compiler error: " +
                "ERROR - actual parameter 1 of temp3 does not match formal parameter");
    }

    private static class CompilerException extends Exception {
        public CompilerException(String message) {
            super(message);
        }
    }
}
