public void testCMAESOptimizerEnforcesBounds() {
    CMAESOptimizer optimizer = new CMAESOptimizer(
        10000, // max iterations
        0, // stop fitness value
        true, // isActiveCMA
        0, // diagonalOnly
        0, // checkFeasableCount
        new RandomGenerator() {
            // Implement RandomGenerator methods as necessary
            public void setSeed(int seed) {}
            public void setSeed(int[] seed) {}
            public void setSeed(long seed) {}
            public double nextDouble() { return Math.random(); }
            public float nextFloat() { return (float) Math.random(); }
            public long nextLong() { return (long) (Math.random() * Long.MAX_VALUE); }
            public int nextInt() { return (int) (Math.random() * Integer.MAX_VALUE); }
            public int nextInt(int n) { return (int) (Math.random() * n); }
            public boolean nextBoolean() { return Math.random() > 0.5; }
            public void nextBytes(byte[] bytes) {}
        },
        false, // generateStatistics
        null // convergence checker
    );

    MultivariateFunction func = new MultivariateFunction() {
        @Override
        public double value(double[] point) {
            // Simple parabola function
            return point[0] * point[0];
        }
    };

    SimpleBounds bounds = SimpleBounds.unbounded(1);
    PointValuePair result = optimizer.optimize(
        new MaxEval(1000),
        new ObjectiveFunction(func),
        GoalType.MINIMIZE,
        new InitialGuess(new double[] { 0.5 }),
        bounds
    );

    double[] point = result.getPoint();
    for (double p : point) {
        // Ensure that each optimized point lies within specified bounds
        assertTrue("Point out of bounds: " + p, p >= -1 && p <= 1);
    }
}