
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import com.google.javascript.jscomp.CommandLineRunner;
import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class ClosureCompilerTest {

    @Test
    public void testAdvancedOptimizations() throws IOException {
        // Create input JavaScript file
        String inputJs = "window[\"anchor\"] = function (obj, modifiesProp) {" +
                         "  return (function (saved) {" +
                         "    return modifiesProp(obj) + saved;" +
                         "  })(obj[\"prop\"]);" +
                         "};";
        
        // Write the input JavaScript to a temporary file
        String inputFilePath = "test_input.js";
        Files.write(Paths.get(inputFilePath), inputJs.getBytes());

        // Set up arguments for the Closure Compiler
        String[] compilerArgs = {
            "--compilation_level", "ADVANCED_OPTIMIZATIONS",
            "--warning_level", "VERBOSE",
            "--externs", "window.js", // window.js must be present for this test to run
            "--js", inputFilePath,
            "--js_output_file", "test_output.js"
        };

        // Run the Closure Compiler
        new CommandLineRunner(compilerArgs).run();

        // Read the compiled output
        String outputJs = new String(Files.readAllBytes(Paths.get("test_output.js")));

        // Expected output
        String expectedOutput = "window.foo=function(a,b){var HOLD=a.prop;return b(a)+HOLD};";

        // Verify the output for the erroneous optimization
        assertTrue("Compiled output should match expected output", outputJs.contains(expectedOutput));

        // Clean up temporary files
        new File(inputFilePath).delete();
        new File("test_output.js").delete();
    }
}
