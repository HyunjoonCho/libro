public void testWrongParameterForFirstStepSizeGuess() {
    double[] y0 = {1.0e+6, 5.0e+4};
    double[] yDotK = {0.0, 0.0};
    double stepStart = 0.0;
    double[] yTmp = new double[y0.length];

    // Assumed tolerances similar to how GraggBulirschStoerIntegrator handles it
    double scalAbsoluteTolerance = 1.0e-5;
    double scalRelativeTolerance = 1.0e-7;

    // Correctly compute scale using the intended approach
    double[] scale = new double[y0.length];
    for (int i = 0; i < y0.length; ++i) {
        double yi = Math.abs(y0[i]);
        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;
    }

    DummyEquations equations = new DummyEquations(y0.length);
    DormandPrince853Integrator integrator = new DormandPrince853Integrator(1.0e-10, 1.0e-2, scalAbsoluteTolerance, scalRelativeTolerance);

    // Check the computed step size using a correct scale initialization
    double hNew = integrator.initializeStep(equations, true, integrator.getOrder(), scale, stepStart, y0, yDotK, yTmp, yDotK);

    // Assert that the newly computed step size is smaller than a threshold that maintains numerical stability
    // The value 1.0e-4 is an assumed threshold here to check an unexpected large step size
    assertTrue(hNew < 1.0e-4);
}

class DummyEquations implements FirstOrderDifferentialEquations {
    private final int dimension;

    public DummyEquations(int dimension) {
        this.dimension = dimension;
    }

    public int getDimension() {
        return dimension;
    }

    public void computeDerivatives(double t, double[] y, double[] yDot) {
        // no-op for this test case
    }
}