
import org.junit.Test;
import static org.junit.Assert.*;

// Hypothetical classes based on the description
class Vector3D {
    final double x, y, z;

    Vector3D(double x, double y, double z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    // Example implementation of negate
    Vector3D negate() {
        return new Vector3D(-x, -y, -z);
    }

    // Example approximate equality check for test validation
    boolean approximatelyEquals(Vector3D other, double epsilon) {
        return Math.abs(x - other.x) < epsilon &&
               Math.abs(y - other.y) < epsilon &&
               Math.abs(z - other.z) < epsilon;
    }
}

class Line {
    private Vector3D direction;

    Line(Vector3D direction) {
        this.direction = direction;
    }

    void revert() {
        // Presumably the problematic code that lacks precision
        // this.direction = new Vector3D(-this.direction.getX(), -this.direction.getY(), -this.direction.getZ());

        // Hypothetical fix to use negate() for more precision
        this.direction = this.direction.negate();
    }

    Vector3D getDirection() {
        return direction;
    }
}

public class LineTest {

    @Test
    public void testRevertPrecision() {
        Vector3D originalDirection = new Vector3D(1234567890.1234567, 9876543210.7654321, 5678901234.5678901);
        Line line = new Line(originalDirection);

        line.revert();

        // Assert that the reverted direction is the negation of the original, checking precision
        Vector3D expectedDirection = originalDirection.negate();
        assertTrue(line.getDirection().approximatelyEquals(expectedDirection, 1e-10));
    }
}
