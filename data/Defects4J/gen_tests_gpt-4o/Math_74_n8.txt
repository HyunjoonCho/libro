public void testWrongStepSizeInitialization() {
    // Setup problem and tolerances
    double[] y0 = { 1000, 0.0003 };
    double[] y0Dot = { -0.3, 0 };
    double t0 = 0.0;
    double stepSize = 1.0;
    double finalTime = 1000.0;
    
    // Tolerances
    double scalAbsoluteTolerance = 1.0e-5;
    double scalRelativeTolerance = 1.0e-5;
    
    // Create expected scale using the correct method
    double[] expectedScale = new double[y0.length];
    for (int i = 0; i < expectedScale.length; ++i) {
        double yi = Math.abs(y0[i]);
        expectedScale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;
    }

    // Initialize the integrator with wrong step size guess
    DormandPrince853Integrator integrator = new DormandPrince853Integrator(1.0e-9, stepSize, scalAbsoluteTolerance, scalRelativeTolerance);

    // Dummy equations (they won't be used in this test)
    FirstOrderDifferentialEquations dummyEquations = new FirstOrderDifferentialEquations() {
        public int getDimension() { return y0.length; }
        public void computeDerivatives(double t, double[] y, double[] yDot) {
            System.arraycopy(y0Dot, 0, yDot, 0, y0Dot.length);
        }
    };

    // Integrate the equations (invoke the method which calls initializeStep)
    try {
        integrator.integrate(dummyEquations, t0, y0, finalTime, y0);
    } catch (Exception e) {
        fail("Integration failed: " + e.getMessage());
    }
    
    // There is no direct way to retrieve the initial scale from integrator,
    // thus we assume the test passes if no exception is thrown with the given setup
}