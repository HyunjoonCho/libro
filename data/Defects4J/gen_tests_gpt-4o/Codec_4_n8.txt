
import org.apache.commons.codec.binary.Base64;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import java.nio.charset.StandardCharsets;

public class Base64Test {

    @Test
    public void testBase64Encode_noChunking_expectedBehavior() {
        Base64 codec = new Base64();
        
        // Test input strings
        String s1 = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
        String s2 = "aaaaaaaaaa";
        String s3 = "a";

        // Convert inputs to bytes
        byte[] b1 = s1.getBytes(StandardCharsets.UTF_8);
        byte[] b2 = s2.getBytes(StandardCharsets.UTF_8);
        byte[] b3 = s3.getBytes(StandardCharsets.UTF_8);

        // Encode using the instance method, which shows the different behavior in version 1.4
        byte[] encoded1 = codec.encode(b1);
        byte[] encoded2 = codec.encode(b2);
        byte[] encoded3 = codec.encode(b3);

        // Expected no chunking and no CRLF at the end like in Codec 1.3
        assertEquals("YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ==",
            new String(encoded1, StandardCharsets.UTF_8).replace("\r\n", ""));
        assertEquals("YWFhYWFhYWFhYQ==", new String(encoded2, StandardCharsets.UTF_8).replace("\r\n", ""));
        assertEquals("YQ==", new String(encoded3, StandardCharsets.UTF_8).replace("\r\n", ""));
    }
}
