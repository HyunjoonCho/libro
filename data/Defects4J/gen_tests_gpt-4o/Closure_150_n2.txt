public void testTypeCheckerWithFunctionScope() {
    // Simulate compilation in first scenario
    String codeInGlobalScope = 
        "var ns = {};\n" +
        "/** @param {string=} b */\n" +
        "ns.a = function(b) {}\n" +
        "function d() {\n" +
        " ns.a();\n" +
        " ns.a(123);\n" +
        "}\n";

    // Check that a warning is emitted for passing an integer
    CompilationResult resultGlobal = compileWithWarnings(codeInGlobalScope);
    assertTrue(resultGlobal.hasWarningForTypeMismatch());

    // Simulate compilation in second scenario
    String codeInFunctionScope = 
        "var ns = {};\n" +
        "(function() {\n" +
        " /** @param {string=} b */\n" +
        " ns.a = function(b) {}\n" +
        "})();\n" +
        "function d() {\n" +
        " ns.a();\n" +
        " ns.a(123);\n" +
        "}\n";

    // Check that the warning is emitted incorrectly for arity but missed for type mismatch
    CompilationResult resultFunction = compileWithWarnings(codeInFunctionScope);
    assertTrue(resultFunction.hasWarningForArity());
    assertFalse(resultFunction.hasWarningForTypeMismatch());

    // Simulate compilation in third scenario
    String codeNoFunctionWrapper = 
        "var ns = {};\n" +
        "(function() {\n" +
        " /** @param {string=} b */\n" +
        " ns.a = function(b) {}\n" +
        "})();\n" +
        "ns.a();\n" +
        "ns.a(123);\n";

    // Check that no warnings are emitted at all
    CompilationResult resultNoWrapper = compileWithWarnings(codeNoFunctionWrapper);
    assertFalse(resultNoWrapper.hasWarnings());
}

private CompilationResult compileWithWarnings(String code) {
    // Mock method to simulate compilation and warning capture
    // Replace with actual compilation logic of the tool
    return new CompilationResult(); // Return appropriate result based on logic
}