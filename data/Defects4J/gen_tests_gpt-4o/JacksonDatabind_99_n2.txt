
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.type.ReferenceType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import org.apache.commons.collections4.map.LRUMap;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class CanonicalStringTest {

    @Test
    public void testCanonicalStringForReferenceType() {
        TypeFactory typeFactory = new TypeFactory(new LRUMap<Object, JavaType>(0, 10000));
        JavaType baseType = typeFactory.constructType(Object.class);
        JavaType placeholder = new PlaceholderForType(0);
        ReferenceType referenceType = new ReferenceType(baseType, placeholder);

        String canonical = referenceType.toCanonical();

        assertEquals("java.lang.Object<$1>", canonical);
    }

    static class PlaceholderForType extends JavaType {
        public PlaceholderForType(int dummy) {
            // Call the parent constructor with appropriate parameters
            super(Object.class, null, null, null, null, false);
        }

        @Override
        public StringBuilder getGenericSignature(StringBuilder sb) {
            return sb.append("$1;");
        }

        @Override
        public StringBuilder getErasedSignature(StringBuilder sb) {
            return sb.append("Ljava/lang/Object;");
        }

        @Override
        public JavaType withContentType(JavaType contentType) {
            return this;
        }

        @Override
        public boolean isContainerType() {
            return false;
        }
    }
}
