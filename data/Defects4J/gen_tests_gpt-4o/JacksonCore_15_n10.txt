
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.filter.FilteringParserDelegate;
import com.fasterxml.jackson.core.filter.TokenFilter;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class FilteringParserDelegateTest {

    @Test
    public void testAllowMultipleMatches() throws IOException {
        String json = "{\"field1\":\"value1\",\"field1\":\"value2\",\"field2\":\"value3\"}";

        // A simple token filter that accepts the field we're testing
        TokenFilter tokenFilter = new TokenFilter() {
            @Override
            public TokenFilter includeProperty(String name) {
                return "field1".equals(name) ? TokenFilter.INCLUDE_ALL : null;
            }
        };

        JsonFactory jsonFactory = new JsonFactory();
        JsonParser parser = jsonFactory.createParser(json);

        // Create FilteringParserDelegate with _allowMultipleMatches mocked behavior
        FilteringParserDelegate filteringParser = new FilteringParserDelegate(
                parser, tokenFilter, false /*includePath*/, false /*_allowMultipleMatches*/);

        ObjectMapper mapper = new ObjectMapper();
        List<String> values = new ArrayList<>();

        while (!filteringParser.isClosed()) {
            filteringParser.nextToken();
            if (filteringParser.getCurrentName() != null && parser.getCurrentValue() != null) {
                values.add(filteringParser.getValueAsString());
            }
        }

        // Due to the bug, this will likely fail, demonstrating that the bug isn't fixed
        // If _allowMultipleMatches was used, it should collect both "value1" and "value2"
        assertEquals(2, values.size());
        assertEquals("value1", values.get(0));
        assertEquals("value2", values.get(1));
    }
}
