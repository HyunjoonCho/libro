
import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;
import org.apache.commons.math3.ode.FirstOrderIntegrator;
import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;
import org.apache.commons.math3.ode.sampling.StepHandler;
import org.apache.commons.math3.ode.sampling.StepInterpolator;
import org.junit.Test;

import static org.junit.Assert.*;

public class RungeKuttaIntegratorTest {

    @Test
    public void testRungeKuttaFirstStepSizeTooLarge() {
        double minStep = 1e-10;
        double maxStep = 1.0;
        double[] yStart = { 0.0 }; // initial state
        double[] yEnd = new double[yStart.length]; // state vector after computation

        FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {
            public int getDimension() {
                return 1;
            }

            public void computeDerivatives(double t, double[] y, double[] yDot) {
                yDot[0] = 1.0; // dy/dt = 1
            }
        };

        FirstOrderIntegrator integrator = new DormandPrince853Integrator(minStep, maxStep, 1e-8, 1e-8);

        StepHandler stepHandler = new StepHandler() {
            @Override
            public void handleStep(StepInterpolator interpolator, boolean isLast) {
                if (interpolator.getCurrentTime() - interpolator.getPreviousTime() > maxStep) {
                    fail("Step size exceeded the max step size");
                }
            }

            @Override
            public void init(double t0, double[] y0, double t) {
                // Initialization if needed
            }
        };
        
        integrator.addStepHandler(stepHandler);

        double t0 = 0.0;
        double t = 1e-9; // very short integration range

        integrator.integrate(ode, t0, yStart, t, yEnd);

        assertEquals(t, yEnd[0], 1e-10); // expect the state value to be close to the range end
    }
}
