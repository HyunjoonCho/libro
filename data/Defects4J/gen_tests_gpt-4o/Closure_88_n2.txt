
import static org.junit.Assert.*;

import java.util.function.Function;

import org.junit.Test;

public class ClosureCompilerTest {

    @Test
    public void testIncorrectAssignmentRemoval() {
        // Original JavaScript function behavior
        Function<NodeMock, Boolean> originalFunction = (someNode) -> {
            String nodeId;
            return ((nodeId = someNode.id) != null && (nodeId = Integer.toString(Integer.parseInt(nodeId.substring(1)))) != null && Integer.parseInt(nodeId) > 0);
        };

        // Mock Node with id "n123"
        NodeMock node = new NodeMock("n123");

        // Expected behavior: should parse and evaluate to true
        boolean expectedResult = originalFunction.apply(node);
        
        // Simulate the behavior of the compiled function
        Function<NodeMock, Boolean> compiledFunction = (b) -> {
            // Incorrect transformation of the original function
            String a;
            return (b.id != null && (a = Integer.toString(Integer.parseInt(a.substring(1)))) != null && Integer.parseInt(a) > 0);
        };

        // Result from compiled function
        boolean actualResult = compiledFunction.apply(node);

        // Assert the compiled result is incorrect, expecting it to differ from the original function
        assertNotEquals("The compiled result should not match the expected result due to the bug.", expectedResult, actualResult);
    }

    // Mock class to simulate the Node object with id
    private static class NodeMock {
        String id;

        NodeMock(String id) {
            this.id = id;
        }
    }
}
