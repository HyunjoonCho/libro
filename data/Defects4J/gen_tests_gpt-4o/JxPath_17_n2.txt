
import org.junit.Test;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

public class NamespacedAttributeTest {

    @Test
    public void testSelectNamespacedAttributeWithWildcard() throws Exception {
        // Prepare the XML document
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document doc = builder.parse(new java.io.ByteArrayInputStream(
                "<xml xmlns:x='foo' x:pop='a'/>".getBytes("UTF-8")));

        // Create an XPath expression to select attributes with wildcards
        XPathFactory xPathFactory = XPathFactory.newInstance();
        XPath xpath = xPathFactory.newXPath();

        // Using wildcard to select all attributes
        XPathExpression expr = xpath.compile("/xml/@*");
        NodeList nodeList = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);

        // Expect the nodeList not to be empty as "/xml/@*" should select namespaced attributes
        assertNotNull(nodeList);
        boolean foundNamespacedAttribute = false;

        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if ("x:pop".equals(node.getNodeName())) {
                foundNamespacedAttribute = true;
                break;
            }
        }

        // In the presence of the bug, the wildcard does not select namespaced attributes, hence should be null
        assertNull("Bug encountered: namespaced attribute should not be selected with wildcard", foundNamespacedAttribute);
    }
}
