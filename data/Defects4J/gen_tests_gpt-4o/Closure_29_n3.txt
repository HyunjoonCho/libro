public void testClosureCompilerIsFunction() {
    String originalFunction = "var isFunction = function(functionToCheck) { var getType; getType = {}; return functionToCheck && getType.toString.apply(functionToCheck) === '[object Function]'; };";
    String compiledFunction = "var isFunction = function(a) { return a && \"[object Function]\" === (void 0).apply(a) };";
   
    // Expected: compiled code should function correctly, but it doesn't. 
    // For demonstration purposes, checking if the compiled function still evaluates function object correctly
    assertFalse(executeCompiledFunction(compiledFunction, new Object()));
    assertTrue(executeCompiledFunction(compiledFunction, new Function(){}));
}

private boolean executeCompiledFunction(String compiledFunctionCode, Object testObject) {
    Context context = Context.enter();
    try {
        Scriptable scope = context.initStandardObjects();
        context.evaluateString(scope, compiledFunctionCode, "compiled", 1, null);
        Object functionObj = scope.get("isFunction", scope);
        if (!(functionObj instanceof Function)) {
            throw new IllegalStateException("isFunction is not a function");
        }
        Function function = (Function) functionObj;
        Object result = function.call(context, scope, scope, new Object[]{testObject});
        return Context.toBoolean(result);
    } finally {
        Context.exit();
    }
}