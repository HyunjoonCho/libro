
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.junit.Test;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

import static org.junit.Assert.assertEquals;

public class ZipTest {

    @Test(expected = AssertionError.class)
    public void testVersionNeededToExtractMismatch() throws IOException {
        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
        BufferedOutputStream bufferedOut = new BufferedOutputStream(byteOut);
        ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(bufferedOut);

        ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
        zipOut.putArchiveEntry(entry);
        zipOut.write("Hello, World!".getBytes());
        zipOut.closeArchiveEntry();
        zipOut.finish();

        byte[] zipBytes = byteOut.toByteArray();
        
        // Read the local file header version needed to extract
        int localHeaderVersion = readVersionNeededToExtract(zipBytes, 4);

        // Read the central directory version needed to extract
        int centralDirectoryVersion = readVersionNeededToExtract(zipBytes, findCentralDirectoryOffset(zipBytes) + 6);

        // Assert that both versions are the same
        // This fails, demonstrating the issue
        assertEquals(localHeaderVersion, centralDirectoryVersion);
    }

    // Method to read the version needed to extract from a specific offset
    private int readVersionNeededToExtract(byte[] zipBytes, int offset) {
        return ((zipBytes[offset + 1] & 0xFF) << 8) | (zipBytes[offset] & 0xFF);
    }

    // Method to find the offset of the central directory
    private int findCentralDirectoryOffset(byte[] zipBytes) {
        for (int i = zipBytes.length - 22; i >= 0; i--) { // 22 is the minimum size of end of central directory record
            if (((zipBytes[i] & 0xFF) == 0x50) && ((zipBytes[i + 1] & 0xFF) == 0x4B)
                && ((zipBytes[i + 2] & 0xFF) == 0x05) && ((zipBytes[i + 3] & 0xFF) == 0x06)) {
                return ((zipBytes[i + 16] & 0xFF) | ((zipBytes[i + 17] & 0xFF) << 8)
                        | ((zipBytes[i + 18] & 0xFF) << 16) | ((zipBytes[i + 19] & 0xFF) << 24));
            }
        }
        throw new IllegalStateException("Central directory offset not found");
    }
}
