
import com.google.javascript.jscomp.*;
import com.google.javascript.rhino.Node;
import org.junit.Test;
import static org.junit.Assert.*;

public class ClosureCompilerTest {

    @Test
    public void testTypeRefiningOfThisRaisesException() {
        // Source code with the problematic type refining on 'this'
        String jsSource = "goog.isFunction(this);";
        
        // Initialize the Closure Compiler with typical options
        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        
        // Enable the necessary checks and optimizations for the issue to arise
        CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
        WarningLevel.VERBOSE.setOptionsForWarningLevel(options);

        // Create a Compilation object with Dummy Externs needed by the compiler
        JSSourceFile extern = JSSourceFile.fromCode("externs.js", "var goog = {isFunction: function() {}, isObject: function() {}, isNull: function() {}};");
        JSSourceFile input = JSSourceFile.fromCode("test.js", jsSource);

        try {
            // Compile and expect an exception or error output
            compiler.compile(extern, input, options);
            fail("Expected IllegalArgumentException due to type refining of 'this'.");
        } catch (RuntimeException e) {
            // Verify that the exception is indeed an IllegalArgumentException
            if (e.getCause() instanceof IllegalArgumentException) {
                assertTrue(e.getCause().getMessage().contains("Node cannot be refined"));
            } else {
                fail("Expected IllegalArgumentException, but got: " + e.getCause());
            }
        }
    }
}
