
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class TypeIdMappingTest {

    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
    @JsonSubTypes({
        @JsonSubTypes.Type(value = SubTypeA.class, name = "subTypeA")
        // Intentionally not adding a type id mapping for BaseType
    })
    private static abstract class BaseType {
        public String baseField;
    }

    private static class SubTypeA extends BaseType {
        public String subFieldA;
    }

    @Test
    public void testExtraneousTypeIdMapping() throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        
        // Serialize a SubTypeA object
        SubTypeA subTypeA = new SubTypeA();
        subTypeA.baseField = "base value";
        subTypeA.subFieldA = "sub value";
        
        String json = objectMapper.writeValueAsString(subTypeA);
        System.out.println("Serialized JSON: " + json);

        // Manually create a JSON with base type id
        String baseTypeJson = "{\"type\":\"BaseType\",\"baseField\":\"base value\"}";

        // Attempt deserialization which should fail if extraneous mapping isn't correctly handled
        Exception exception = assertThrows(Exception.class, () -> {
            objectMapper.readValue(baseTypeJson, BaseType.class);
        });

        String expectedMessage = "Could not resolve type id 'BaseType'";
        String actualMessage = exception.getMessage();

        assertTrue(actualMessage.contains(expectedMessage), "Unexpected type id mapping: " + actualMessage);
    }
}
