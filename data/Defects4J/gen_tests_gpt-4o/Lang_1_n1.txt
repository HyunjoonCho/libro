
import org.apache.commons.lang3.math.NumberUtils;
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

public class NumberUtilsHexTest {

    // Test case to reproduce the issue in NumberUtils.createLong()
    @Test
    public void testCreateLongWithHex() {
        try {
            // Attempt to parse a hex number that fits within Long, but not Integer
            String hexString = "0x80000000"; // 2147483648 in decimal (exactly 2^31)

            // This should ideally parse to a Long, but currently results in an error
            Long result = NumberUtils.createLong(hexString);
            
            fail("Expected NumberFormatException was not thrown.");
        } catch (NumberFormatException e) {
            // Expected exception for current buggy behavior
            System.out.println("Caught expected NumberFormatException: " + e.getMessage());
        }
    }

    // Test case to reproduce the issue in NumberUtils.createNumber()
    @Test
    public void testCreateNumberWithLargeHex() {
        // Attempt to parse a large hex number
        String largeHexString = "0x123456789"; // Larger than Integer range

        // Currently, it incorrectly assumes it should create an Integer and fails
        Number result = NumberUtils.createNumber(largeHexString);

        // This should ideally be parsed as a Long
        assertEquals(Long.class, result.getClass());
        assertEquals(Long.decode(largeHexString), result);
    }
}
