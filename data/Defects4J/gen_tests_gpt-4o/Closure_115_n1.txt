
import static org.junit.Assert.assertEquals;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;

import com.google.javascript.jscomp.CommandLineRunner;
import org.junit.Test;

public class ClosureCompilerTest {

    @Test
    public void testAdvancedOptimization() throws IOException {
        // Define the input JavaScript to test
        String inputJs = "window[\"anchor\"] = function (obj, modifiesProp) {" +
                         "  return (function (saved) {" +
                         "    return modifiesProp(obj) + saved;" +
                         "  })(obj[\"prop\"]);" +
                         "};";

        // Write input.js file
        File inputFile = new File("input.js");
        Files.write(inputFile.toPath(), inputJs.getBytes());

        // Output file for compiled JS
        File outputFile = new File("output.js");

        // Define the command line arguments for the closure compiler
        String[] args = {
            "--compilation_level", "ADVANCED_OPTIMIZATIONS",
            "--js", inputFile.getPath(),
            "--js_output_file", outputFile.getPath()
        };

        // Compile using Closure Compiler
        CommandLineRunner runner = new CommandLineRunner(args);
        int result = runner.doRun();
        assertEquals(0, result);

        // Expected output (as per bug report)
        String expectedOutput = "window.anchor=function(a,b){var HOLD=a.prop;return b(a)+HOLD};";

        // Read the output.js file content
        String compiledJs = new String(Files.readAllBytes(outputFile.toPath()));

        // Check for equality between expected and actual compiled output
        assertEquals("Compiled output did not match expected result.", expectedOutput, compiledJs);

        // Clean up: (optional) remove temporary files
        inputFile.delete();
        outputFile.delete();
    }
}
