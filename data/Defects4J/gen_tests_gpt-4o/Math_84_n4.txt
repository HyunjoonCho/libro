
import org.apache.commons.math3.optim.SimplePointChecker;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex;
import org.apache.commons.math3.optim.*;
import org.apache.commons.math3.analysis.MultivariateFunction;
import org.junit.Test;
import static org.junit.Assert.*;

public class MultiDirectionalTest {

    @Test(timeout=5000) // Adding a timeout to prevent infinite loop
    public void testMultiDirectionalCorrectStart() {
        // Define a simple quadratic function
        MultivariateFunction quadraticFunction = new MultivariateFunction() {
            @Override
            public double value(double[] point) {
                double x = point[0];
                return x * x;
            }
        };

        // Create a MultiDirectional optimizer
        MultivariateOptimizer optimizer = new MultivariateOptimizer(
                new SimplePointChecker<PointValuePair>(1e-6, 1e-6)) {
            @Override
            protected PointValuePair doOptimize() {
                return optimize(new MaxEval(1000),
                        new ObjectiveFunction(quadraticFunction),
                        GoalType.MINIMIZE,
                        new InitialGuess(new double[]{0.0}),
                        new MultiDirectionalSimplex(new double[]{1}));
            }
        };

        // Perform the optimization starting from the known minimum (solution)
        PointValuePair result = optimizer.optimize(
            new MaxEval(1000),
            new ObjectiveFunction(quadraticFunction),
            GoalType.MINIMIZE,
            new InitialGuess(new double[]{0.0}),
            new MultiDirectionalSimplex(new double[]{1}));

        // Check if the optimizer returns the correct solution quickly
        double[] optimalPoint = result.getPoint();
        assertEquals(0.0, optimalPoint[0], 1e-6);
    }
}
