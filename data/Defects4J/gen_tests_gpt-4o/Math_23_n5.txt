
import org.apache.commons.math3.analysis.UnivariateFunction;
import org.apache.commons.math3.optim.univariate.BrentOptimizer;
import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;
import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.univariate.SearchInterval;
import org.junit.Test;
import static org.junit.Assert.assertTrue;

public class BrentOptimizerTest {

    @Test
    public void testBrentOptimizerNotReturningBestPoint() {
        // Define a simple quadratic function with a minimum
        UnivariateFunction function = (x) -> (x - 2) * (x - 2);

        // Configure the optimizer
        BrentOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);

        // Search for the minimum in the interval [0, 4]
        UnivariatePointValuePair result = optimizer.optimize(
                new MaxEval(100),
                new UnivariateObjectiveFunction(function),
                SearchInterval(0, 4)
        );

        // Check if the returned result is the best known minimum
        double bestX = result.getPoint();
        double bestY = result.getValue();

        // Since the minimum is known to be at x = 2, we check if the optimizer found it
        double expectedMinimumX = 2.0;
        assertTrue("Optimizer did not return the best point", Math.abs(bestX - expectedMinimumX) < 1e-6);
        assertTrue("Optimizer did not return the correct minimum value", Math.abs(bestY - 0.0) < 1e-6);
    }
}
