
import com.google.javascript.jscomp.CommandLineRunner;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.DiagnosticGroups;
import com.google.javascript.jscomp.JSError;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.Result;
import org.junit.Test;

import java.util.Collections;

import static org.junit.Assert.assertTrue;

public class CompilerWarningTest {

    @Test
    public void testCrypticErrorOnInvalidTypeFunctionAnnotation() {
        String jsCode = "/**\n" +
                        " * @type function\n" +
                        " */\n" +
                        "var callback;";

        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        options.setWarningLevel(DiagnosticGroups.ALL_CHECKS, CompilerOptions.WarningLevel.WARNING);

        SourceFile input = SourceFile.fromCode("test.js", jsCode);
        SourceFile extern = SourceFile.fromCode("externs.js", "");

        Result result = compiler.compile(Collections.singletonList(extern), 
                                         Collections.singletonList(input), 
                                         options);

        JSError[] warnings = compiler.getWarnings();
        boolean foundExpectedWarning = false;

        for (JSError warning : warnings) {
            // Check if there's a parse error with a message that suggests the nature of the problem
            if (warning.getDescription().contains("missing '(' after function type")) {
                foundExpectedWarning = true;
            }
        }

        assertTrue("Expected a parse error with a missing '(' message", foundExpectedWarning);
    }
}
