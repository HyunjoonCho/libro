
import static org.junit.Assert.assertEquals;
import org.junit.Test;

class Foo {
    /** 
     * @param a the first number
     * @param b the second number
     * @return the sum of a and b
     */
    public int add(int a, int b) {
        return a + b;
    }

    /** 
     * Abstract method.
     * @param a the first number
     * @param b the second number
     * @return the difference of a and b
     */
    public int sub(int a, int b) {
        throw new UnsupportedOperationException("Abstract method");
    }
}

class Bar extends Foo {
    /** @inheritDoc */
    @Override
    public int add(int one) { // Incorrectly overridden method
        return one;
    }

    /** @inheritDoc */
    @Override
    public int sub(int one) { // Incorrectly overridden method
        return one;
    }
}

public class CompilerTest {

    @Test(expected = UnsupportedOperationException.class)
    public void testAddMethodSignatureMismatch() {
        Foo foo = new Bar();
        // Calling Bar's add method with two parameters should raise an error
        // but due to mismatched signature it will invoke Foo's version.
        assertEquals(7, foo.add(3, 4)); // This would work incorrectly
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testSubMethodSignatureMismatch() {
        Foo foo = new Bar();
        // Calling Bar's sub method should raise an error
        // because Bar incorrectly tries to override it
        foo.sub(3, 4); // This should fail due to wrong argument count
    }
}
