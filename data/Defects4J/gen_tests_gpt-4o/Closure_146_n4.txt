
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.WarningLevel;
import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class ClosureCompilerTest {

    @Test
    public void testBadTypeInference() {
        String jsCode = ""
            + "/** @param {string} x */\n"
            + "function g(x) {}\n"
            + "/** @param {undefined} x */\n"
            + "function f(x) {\n"
            + "  if (x != undefined) { g(x); }\n"
            + "}\n";

        Compiler compiler = new Compiler();
        CompilerOptions options = new CompilerOptions();
        WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
        options.setCompilationLevel(CompilerOptions.CompilationLevel.ADVANCED_OPTIMIZATIONS);

        Result result = compiler.compile(SourceFile.fromCode("externs.js", ""), 
             SourceFile.fromCode("test.js", jsCode), options);

        // Expecting that the syntax tree analysis finds the condition always false 
        // but does not generate a bogus type mismatch warning for function g call
        assertTrue("Unexpected type warning", result.warnings.length == 1); 
        assertTrue("Condition always evaluates to false", 
                   result.warnings[0].getType().key.equals("JSC_DETERMINISTIC_TEST"));

        // Ensure that no type mismatch warnings occur for g function call
        for (com.google.javascript.jscomp.JSError warning : result.warnings) {
            assertTrue("Unexpected type mismatch warning",
                !warning.getType().key.equals("JSC_TYPE_MISMATCH"));
        }
    }
}
