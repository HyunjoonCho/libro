public void testExtraneousTypeIdMapping() {
    Map<String, Class<?>> typeResolver = new HashMap<>();
    typeResolver.put("Base", BaseType.class);
    typeResolver.put("Derived", DerivedType.class);

    TypeResolver resolver = new TypeResolver(typeResolver);

    Set<String> resolvedTypes = resolver.resolveTypeIds("Base");

    // Assuming 'BaseType' is concrete and has an explicit name
    assertTrue(resolvedTypes.contains("Base"));
    assertTrue(resolvedTypes.contains("Derived"));
    
    // If 'BaseType' is abstract or uses a default name, it should not map to itself
    // This part of the test would depend on how BaseType is defined
    if (BaseType.class.isAbstract()) {
        assertFalse(resolvedTypes.contains("Base"));
    }
}

Note: This test assumes that `TypeResolver` is a class that resolves type IDs, and `BaseType` and `DerivedType` are classes where `DerivedType` extends `BaseType`. Adjust the test to fit the actual class and method names in your codebase.