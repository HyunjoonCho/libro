import static org.junit.Assert.fail;
import org.junit.Test;

public class WeirdObjectLiteralErrorTest {

    @Test
    public void testWeirdObjectLiteralError() {
        try {
            Object optData = new Object() {{
                Object activity = new Object() {
                    Object text = "example";
                };
            }};

            // Simulate the error scenario by trying to access the text property
            // which should trigger a type mismatch due to the optimization issue.
            String result = temp2(optData);

            // If no exception is thrown, fail the test as the issue is not reproduced
            fail("Expected a type mismatch error due to object literal optimization");
        } catch (Exception e) {
            // Expected behavior: catch the type mismatch error
        }
    }

    // Mocked functions to simulate the behavior described in the bug report
    private String temp1(Object optData) {
        return optData.toString();
    }

    private String temp2(Object optData) {
        return temp1(optData);
    }

    private String temp3(Object optData) {
        return "n: " + ((Number) optData).intValue() + ", t: " + optData.toString() + ".";
    }
}