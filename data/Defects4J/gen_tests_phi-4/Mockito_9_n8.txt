public void testSpyingOnAbstractClass() {
    AbstractClass testSubject = mock(AbstractClass.class);
    when(testSubject.someMethod()).thenReturn("mocked");

    AbstractClass spy = spy(testSubject);
    doReturn("spied").when(spy).someMethod();

    AbstractClass testInstance = new AbstractClass() {
        @Override
        public String someMethod() {
            return someOtherMethod();
        }

        @Override
        public String someOtherMethod() {
            return "real implementation";
        }
    };

    assertEquals("spied", spy.someMethod());
}

This test demonstrates the issue where spying on an abstract class causes unexpected behavior when the real implementation calls back to the abstract method. The test ensures that the spied method returns the expected value, despite the real implementation's behavior.