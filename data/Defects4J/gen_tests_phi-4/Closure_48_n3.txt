public void testFunctionReplacement() {
    MyClass myObject = new MyClass();
    
    // Call the original function
    myObject.fn(true); // Expecting this to work without error
    
    // Replace the function with a stub
    myObject.setFn(() -> {});
    
    // Call the stubbed function, expecting no error
    myObject.fn(true); // This should not cause an error
}

class MyClass {
    private Consumer<Boolean> fn;

    public MyClass() {
        this.fn = this::fnImpl;
    }

    private void fnImpl(Boolean success) {
        // Original function implementation
    }

    public void fn(Boolean success) {
        fn.accept(success);
    }

    public void test() {
        fn(true); // Original call
        setFn(() -> {}); // Reassign function
        fn(true); // Call with stubbed function
    }

    public void setFn(Consumer<Boolean> fn) {
        this.fn = fn;
    }
}

This test simulates the behavior described in the bug report by