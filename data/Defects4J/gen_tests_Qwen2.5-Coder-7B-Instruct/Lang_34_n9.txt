public void testThreadLocalMemoryLeak() throws Exception {
    for (int i = 0; i < 1000; ++i) {
        ReflectionToStringBuilder.toString(new Object(), new CustomToStringStyle());
    }
    // Assuming that after some iterations, the thread-local still holds a reference
    // This is a very basic test and might need to be adapted based on the actual implementation details
    assertTrue(((CustomToStringStyle.ThreadLocalObjectStringStyle) CustomToStringStyle.threadLocal.get()).hasReference());
}

private static class CustomToStringStyle extends ToStringStyle {
    private static final ThreadLocal<ThreadLocalObjectStringStyle> threadLocal = new ThreadLocal<>();

    public CustomToStringStyle() {
        super();
        threadLocal.set(new ThreadLocalObjectStringStyle());
    }

    @Override
    protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {
        // Implementation doesn't matter for this test
    }

    public static boolean hasReference() {
        return threadLocal.get().hasReference;
    }

    private static class ThreadLocalObjectStringStyle {
        boolean hasReference;

        ThreadLocalObjectStringStyle() {
            hasReference = true;
        }

        void reset() {
            hasReference = false;