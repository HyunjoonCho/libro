java
public class TestPrimitiveRefinement {

    @JacksonTypeInfo
    public static class TestClass {
        @JacksonTypeRefine
        public int myInt;
    }

    @Test
    public void testPrimitiveRefinement() {
        // Test case 1: ignore primitive/wrapper override, return original type as is
        TestClass tc1 = new TestClass();
        tc1.myInt = 10;
        ObjectMapper mapper = new ObjectMapper();
        mapper.addMixInAnnotations(TestClass.class, TestClassMixIn.class);
        String json1 = mapper.writeValueAsString(tc1);
        assertEquals("{\"myInt\":10}", json1);

        // Test case 2: allow wrapper to "refine" primitive, return wrapper
        TestClass tc2 = new TestClass();
        tc2.myInt = 10;
        ObjectMapper mapper2 = new ObjectMapper();
        mapper2.addMixInAnnotations(TestClass.class, TestClassMixInWrapper.class);
        String json2 = mapper2.writeValueAsString(tc2);
        assertEquals("{\"myInt\":10}", json2);
    }
}

class TestClassMixIn {
    @JacksonTypeRefine
    public void setMyInt(int