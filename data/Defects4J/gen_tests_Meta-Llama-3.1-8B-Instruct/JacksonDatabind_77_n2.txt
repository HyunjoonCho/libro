public void testDeserializationVulnerability() throws Exception {
    ObjectMapper mapper = new ObjectMapper();
    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream("class:java.lang.Class\nclass:java.lang.Runtime\n".getBytes()));
    mapper.readValue(ois, Object.class);
    fail("Expected a ClassCastException");
}

However, to test this in a safe way, we can use a custom `ObjectInputStream` that does not actually deserialize the data, but instead returns a known object:

public void testDeserializationVulnerability() throws Exception {
    ObjectMapper mapper = new ObjectMapper();
    CustomObjectInputStream ois = new CustomObjectInputStream();
    mapper.readValue(ois, Object.class);
    fail("Expected a ClassCastException");
}

class CustomObjectInputStream extends ObjectInputStream {
    @Override
    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
        return String.class;
    }
}

This way, we can still test the deserialization vulnerability without actually causing harm.