public void testExtraneousTypeMapping() {
    Class<?> baseClass = BaseClass.class;
    Class<?> derivedClass = DerivedClass.class;
    Map<String, Class<?>> typeMap = new HashMap<>();
    typeMap.put("Base", baseClass);
    typeMap.put("Derived", derivedClass);
    
    // Test case 1: base type is concrete and has explicit name
    Map<String, Class<?>> typeResolutionList = new TypeResolver().resolveTypes(typeMap, baseClass);
    assertTrue(typeResolutionList.containsKey("Base"));
    assertTrue(typeResolutionList.containsKey("Derived"));
    
    // Test case 2: base type is concrete but has default name
    Class<?> baseClassDefaultName = new Class<?>() {};
    typeMap.put("Base", baseClassDefaultName);
    typeResolutionList = new TypeResolver().resolveTypes(typeMap, baseClassDefaultName);
    assertFalse(typeResolutionList.containsKey("Base"));
    assertTrue(typeResolutionList.containsKey("Derived"));
    
    // Test case 3: base type is abstract
    abstract class AbstractBaseClass {}
    typeMap.put("Base", AbstractBaseClass.class);
    typeResolutionList = new TypeResolver().resolveTypes(typeMap, baseClass);
    assertFalse(typeResolutionList.containsKey("