public void testIntAndIntegerRefinement() {
    Class<?> intClass = Class.forName("int");
    Class<?> integerClass = Class.forName("java.lang.Integer");
    Class<?> longClass = Class.forName("long");

    ObjectMapper mapper = new ObjectMapper();
    TypeFactory typeFactory = mapper.getTypeFactory();

    // Test ignoring primitive/wrapper override
    TypeReference<?> typeRef = typeFactory.constructType(intClass);
    assertEquals(int.class, typeRef.getType());
    typeRef = typeFactory.constructType(integerClass);
    assertEquals(Integer.class, typeRef.getType());

    // Test allowing wrapper to "refine" primitive
    TypeReference<?> refinedIntTypeRef = typeFactory.constructType(integerClass, typeFactory.constructType(intClass));
    assertEquals(Integer.class, refinedIntTypeRef.getType());

    // Test not allowing "int to long" refinement
    try {
        typeFactory.constructType(integerClass, typeFactory.constructType(longClass));
        fail("Expected IllegalArgumentException for int to long refinement");
    } catch (IllegalArgumentException e) {
        // Expected
    }
}