public void testBrentOptimizerNotAlwaysReportingBestPoint() {
    BrentOptimizer brentOptimizer = new BrentOptimizer();
    // Create a function that has a single minimum at x=1
    double[] functionValues = new double[10];
    for (int i = 0; i < 10; i++) {
        functionValues[i] = i == 1? 0 : Double.POSITIVE_INFINITY;
    }
    brentOptimizer.optimize(new BrentOptimizer.BrentFunction() {
        @Override
        public double value(double x) {
            return functionValues[Math.round(x)];
        }
    });
    // The minimum is at x=1, but due to the nature of the function, the last point evaluated might be slightly worse
    // So we can't assert that the returned point is exactly the minimum, but we can assert that it's close enough
    double bestPoint = brentOptimizer.getPoint();
    double bestValue = brentOptimizer.getFunctionValue();
    for (int i = -1; i <= 1; i++) {
        double value = functionValues[Math.round(bestPoint + i)];
        if (value < bestValue) {
            fail("The point returned by BrentOptimizer is not