java
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;
import java.util.concurrent.TimeUnit;

import static org.junit.Assert.assertTrue;

@RunWith(Suite.class)
public class MemoryLeakTest {

    private MemoryMXBean memoryMXBean;

    @Before
    public void before() {
        memoryMXBean = ManagementFactory.getMemoryMXBean();
    }

    @After
    public void after() {
        // This is the problematic part, we're not actually removing the thread local
        // but we can still check for memory leak
        HashCodeBuilder builder = new HashCodeBuilder();
        builder.setStyle(ToStringStyle.DEFAULT_STYLE);
        MemoryUsage heapMemoryUsage = memoryMXBean.getHeapMemoryUsage();
        long usedMemory = heapMemoryUsage.getUsed();
        try {
            TimeUnit.SECONDS.sleep(10); // wait for some time to see if memory usage increases
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        Memory