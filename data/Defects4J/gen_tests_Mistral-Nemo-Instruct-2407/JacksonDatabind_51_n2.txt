public void testTypeIdResolverGenericTypeIgnored() {
  // Assuming that you have a TypeIdResolver that returns a JavaType for a generic type
  // Let's say MyGenericType is a generic type with a generic parameter T
  // And you have a TypeIdResolver that returns new TypeReference<MyGenericType<T>>() {}

  ObjectMapper mapper = new ObjectMapper();
  mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);

  MyGenericType<String> myObject = new MyGenericType<>();
  myObject.setValue("Test");

  try {
    String json = mapper.writeValueAsString(myObject);
    MyGenericType<String> deserializedObject = mapper.readValue(json, MyGenericType.class);
    // This will fail because deserializedObject will have a raw type instead of MyGenericType<String>
    assertEquals(myObject, deserializedObject);
  } catch (IOException e) {
    fail("Should not throw an exception");
  }
}